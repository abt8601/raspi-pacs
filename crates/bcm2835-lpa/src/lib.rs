#![doc = "Peripheral access API for BCM2835_LPA microcontrollers (generated using svd2rust v0.30.2 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.30.2/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_bounds)]
#![deny(private_interfaces)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + PartialEq + From<Self>;
    }
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &R {
                        bits,
                        _reg: marker::PhantomData,
                    },
                    &mut W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    },
                )
                .bits,
            );
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct FieldWriter<'a, REG, const WI: u8, const O: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, const O: u8, FI, Safety> FieldWriter<'a, REG, WI, O, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>) -> Self {
                Self {
                    w,
                    _field: marker::PhantomData,
                }
            }
        }
        pub struct BitWriter<'a, REG, const O: u8, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, const O: u8, FI, M> BitWriter<'a, REG, O, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>) -> Self {
                Self {
                    w,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    #[doc(hidden)]
    pub struct Safe;
    #[doc(hidden)]
    pub struct Unsafe;
    #[doc = " Write field Proxy with unsafe `bits`"]
    pub type FieldWriter<'a, REG, const WI: u8, const O: u8, FI = u8> =
        raw::FieldWriter<'a, REG, WI, O, FI, Unsafe>;
    #[doc = " Write field Proxy with safe `bits`"]
    pub type FieldWriterSafe<'a, REG, const WI: u8, const O: u8, FI = u8> =
        raw::FieldWriter<'a, REG, WI, O, FI, Safe>;
    impl<'a, REG, const WI: u8, const OF: u8, FI> FieldWriter<'a, REG, WI, OF, FI>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << OF);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    impl<'a, REG, const WI: u8, const OF: u8, FI> FieldWriterSafe<'a, REG, WI, OF, FI>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << OF);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            self.bits(FI::Ux::from(variant))
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, const O: u8, FI = bool> =
                raw::BitWriter<'a, REG, O, FI, $mwv>;
            impl<'a, REG, const OF: u8, FI> $writer<'a, REG, OF, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::one() << OF);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::one()) << OF;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, const OF: u8, FI> BitWriter<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << OF;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << OF);
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter1S<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << OF;
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter0C<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << OF);
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter1C<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << OF;
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter0S<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << OF);
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter1T<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << OF;
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter0T<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << OF);
            self.w
        }
    }
    mod atomic {
        use super::*;
        use portable_atomic::Ordering;
        pub trait AtomicOperations {
            unsafe fn atomic_or(ptr: *mut Self, val: Self);
            unsafe fn atomic_and(ptr: *mut Self, val: Self);
            unsafe fn atomic_xor(ptr: *mut Self, val: Self);
        }
        macro_rules! impl_atomics {
            ($ U : ty , $ Atomic : ty) => {
                impl AtomicOperations for $U {
                    unsafe fn atomic_or(ptr: *mut Self, val: Self) {
                        (*(ptr as *const $Atomic)).or(val, Ordering::SeqCst);
                    }
                    unsafe fn atomic_and(ptr: *mut Self, val: Self) {
                        (*(ptr as *const $Atomic)).and(val, Ordering::SeqCst);
                    }
                    unsafe fn atomic_xor(ptr: *mut Self, val: Self) {
                        (*(ptr as *const $Atomic)).xor(val, Ordering::SeqCst);
                    }
                }
            };
        }
        impl_atomics!(u8, portable_atomic::AtomicU8);
        impl_atomics!(u16, portable_atomic::AtomicU16);
        #[cfg(not(target_pointer_width = "16"))]
        impl_atomics!(u32, portable_atomic::AtomicU32);
        #[cfg(any(target_pointer_width = "64", target_has_atomic = "64"))]
        impl_atomics!(u64, portable_atomic::AtomicU64);
        impl<REG: Readable + Writable> Reg<REG>
        where
            REG::Ux: AtomicOperations + Default + core::ops::Not<Output = REG::Ux>,
        {
            #[doc = " Set high every bit in the register that was set in the write proxy. Leave other bits"]
            #[doc = " untouched. The write is done in a single atomic instruction."]
            #[doc = ""]
            #[doc = " # Safety"]
            #[doc = ""]
            #[doc = " The resultant bit pattern may not be valid for the register."]
            #[inline(always)]
            pub unsafe fn set_bits<F>(&self, f: F)
            where
                F: FnOnce(&mut W<REG>) -> &mut W<REG>,
            {
                let bits = f(&mut W {
                    bits: Default::default(),
                    _reg: marker::PhantomData,
                })
                .bits;
                REG::Ux::atomic_or(self.register.as_ptr(), bits);
            }
            #[doc = " Clear every bit in the register that was cleared in the write proxy. Leave other bits"]
            #[doc = " untouched. The write is done in a single atomic instruction."]
            #[doc = ""]
            #[doc = " # Safety"]
            #[doc = ""]
            #[doc = " The resultant bit pattern may not be valid for the register."]
            #[inline(always)]
            pub unsafe fn clear_bits<F>(&self, f: F)
            where
                F: FnOnce(&mut W<REG>) -> &mut W<REG>,
            {
                let bits = f(&mut W {
                    bits: !REG::Ux::default(),
                    _reg: marker::PhantomData,
                })
                .bits;
                REG::Ux::atomic_and(self.register.as_ptr(), bits);
            }
            #[doc = " Toggle every bit in the register that was set in the write proxy. Leave other bits"]
            #[doc = " untouched. The write is done in a single atomic instruction."]
            #[doc = ""]
            #[doc = " # Safety"]
            #[doc = ""]
            #[doc = " The resultant bit pattern may not be valid for the register."]
            #[inline(always)]
            pub unsafe fn toggle_bits<F>(&self, f: F)
            where
                F: FnOnce(&mut W<REG>) -> &mut W<REG>,
            {
                let bits = f(&mut W {
                    bits: Default::default(),
                    _reg: marker::PhantomData,
                })
                .bits;
                REG::Ux::atomic_xor(self.register.as_ptr(), bits);
            }
        }
    }
}
#[doc(hidden)]
pub mod interrupt {
    #[doc = r"Enumeration of all the interrupts."]
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        #[doc = "0 - Timer 0 matched"]
        TIMER_0 = 0,
        #[doc = "1 - Timer 1 matched"]
        TIMER_1 = 1,
        #[doc = "2 - Timer 2 matched"]
        TIMER_2 = 2,
        #[doc = "3 - Timer 3 matched"]
        TIMER_3 = 3,
        #[doc = "9 - USB interrupt"]
        USB = 9,
        #[doc = "29 - Interrupt from AUX"]
        AUX = 29,
        #[doc = "49 - Interrupt from bank 0"]
        GPIO0 = 49,
        #[doc = "50 - Interrupt from bank 1"]
        GPIO1 = 50,
        #[doc = "51 - Interrupt from bank 2"]
        GPIO2 = 51,
        #[doc = "52 - OR of all GPIO interrupts"]
        GPIO = 52,
        #[doc = "53 - OR of all I2C interrupts"]
        I2C = 53,
        #[doc = "54 - OR of all SPI interrupts except 1 and 2"]
        SPI = 54,
        #[doc = "57 - OR of all UART interrupts except 1"]
        UART = 57,
        #[doc = "62 - OR of EMMC and EMMC2"]
        EMMC = 62,
    }
    #[doc = r" TryFromInterruptError"]
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        #[doc = r" Attempt to convert a given value into an `Interrupt`"]
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                0 => Ok(Interrupt::TIMER_0),
                1 => Ok(Interrupt::TIMER_1),
                2 => Ok(Interrupt::TIMER_2),
                3 => Ok(Interrupt::TIMER_3),
                9 => Ok(Interrupt::USB),
                29 => Ok(Interrupt::AUX),
                49 => Ok(Interrupt::GPIO0),
                50 => Ok(Interrupt::GPIO1),
                51 => Ok(Interrupt::GPIO2),
                52 => Ok(Interrupt::GPIO),
                53 => Ok(Interrupt::I2C),
                54 => Ok(Interrupt::SPI),
                57 => Ok(Interrupt::UART),
                62 => Ok(Interrupt::EMMC),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
}
pub use self::interrupt::Interrupt;
#[doc = "Mailboxes for talking to/from VideoCore"]
pub struct VCMAILBOX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VCMAILBOX {}
impl VCMAILBOX {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vcmailbox::RegisterBlock = 0x2000_b880 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vcmailbox::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for VCMAILBOX {
    type Target = vcmailbox::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VCMAILBOX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VCMAILBOX").finish()
    }
}
#[doc = "Mailboxes for talking to/from VideoCore"]
pub mod vcmailbox {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Read messages from the VideoCore"]
        pub read: READ,
        _reserved1: [u8; 0x0c],
        #[doc = "0x10 - "]
        pub peek0: PEEK0,
        #[doc = "0x14 - "]
        pub sender0: SENDER0,
        #[doc = "0x18 - "]
        pub status0: STATUS0,
        #[doc = "0x1c - "]
        pub config0: CONFIG0,
        #[doc = "0x20 - Write messages to the VideoCore"]
        pub write: WRITE,
        _reserved6: [u8; 0x0c],
        #[doc = "0x30 - "]
        pub peek1: PEEK1,
        #[doc = "0x34 - "]
        pub sender1: SENDER1,
        #[doc = "0x38 - "]
        pub status1: STATUS1,
        #[doc = "0x3c - "]
        pub config1: CONFIG1,
    }
    #[doc = "READ (r) register accessor: Read messages from the VideoCore\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`read::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@read`]
module"]
    pub type READ = crate::Reg<read::READ_SPEC>;
    #[doc = "Read messages from the VideoCore"]
    pub mod read {
        #[doc = "Register `READ` reader"]
        pub type R = crate::R<READ_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<READ_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Read messages from the VideoCore\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`read::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct READ_SPEC;
        impl crate::RegisterSpec for READ_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`read::R`](R) reader structure"]
        impl crate::Readable for READ_SPEC {}
    }
    #[doc = "PEEK0 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`peek0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`peek0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@peek0`]
module"]
    pub type PEEK0 = crate::Reg<peek0::PEEK0_SPEC>;
    #[doc = ""]
    pub mod peek0 {
        #[doc = "Register `PEEK0` reader"]
        pub type R = crate::R<PEEK0_SPEC>;
        #[doc = "Register `PEEK0` writer"]
        pub type W = crate::W<PEEK0_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PEEK0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`peek0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`peek0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PEEK0_SPEC;
        impl crate::RegisterSpec for PEEK0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`peek0::R`](R) reader structure"]
        impl crate::Readable for PEEK0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`peek0::W`](W) writer structure"]
        impl crate::Writable for PEEK0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "SENDER0 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sender0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sender0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sender0`]
module"]
    pub type SENDER0 = crate::Reg<sender0::SENDER0_SPEC>;
    #[doc = ""]
    pub mod sender0 {
        #[doc = "Register `SENDER0` reader"]
        pub type R = crate::R<SENDER0_SPEC>;
        #[doc = "Register `SENDER0` writer"]
        pub type W = crate::W<SENDER0_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<SENDER0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sender0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sender0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SENDER0_SPEC;
        impl crate::RegisterSpec for SENDER0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sender0::R`](R) reader structure"]
        impl crate::Readable for SENDER0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`sender0::W`](W) writer structure"]
        impl crate::Writable for SENDER0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "STATUS0 (r) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status0::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status0`]
module"]
    pub type STATUS0 = crate::Reg<status0::STATUS0_SPEC>;
    #[doc = ""]
    pub mod status0 {
        #[doc = "Register `STATUS0` reader"]
        pub type R = crate::R<STATUS0_SPEC>;
        #[doc = "Field `EMPTY` reader - "]
        pub type EMPTY_R = crate::BitReader;
        #[doc = "Field `FULL` reader - "]
        pub type FULL_R = crate::BitReader;
        impl R {
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn empty(&self) -> EMPTY_R {
                EMPTY_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn full(&self) -> FULL_R {
                FULL_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STATUS0")
                    .field("full", &format_args!("{}", self.full().bit()))
                    .field("empty", &format_args!("{}", self.empty().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<STATUS0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status0::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STATUS0_SPEC;
        impl crate::RegisterSpec for STATUS0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`status0::R`](R) reader structure"]
        impl crate::Readable for STATUS0_SPEC {}
    }
    #[doc = "CONFIG0 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`config0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config0`]
module"]
    pub type CONFIG0 = crate::Reg<config0::CONFIG0_SPEC>;
    #[doc = ""]
    pub mod config0 {
        #[doc = "Register `CONFIG0` reader"]
        pub type R = crate::R<CONFIG0_SPEC>;
        #[doc = "Register `CONFIG0` writer"]
        pub type W = crate::W<CONFIG0_SPEC>;
        #[doc = "Field `IRQEN` reader - Enable the interrupt when data is available"]
        pub type IRQEN_R = crate::BitReader;
        #[doc = "Field `IRQEN` writer - Enable the interrupt when data is available"]
        pub type IRQEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Enable the interrupt when data is available"]
            #[inline(always)]
            pub fn irqen(&self) -> IRQEN_R {
                IRQEN_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CONFIG0")
                    .field("irqen", &format_args!("{}", self.irqen().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CONFIG0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable the interrupt when data is available"]
            #[inline(always)]
            #[must_use]
            pub fn irqen(&mut self) -> IRQEN_W<CONFIG0_SPEC, 0> {
                IRQEN_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`config0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CONFIG0_SPEC;
        impl crate::RegisterSpec for CONFIG0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`config0::R`](R) reader structure"]
        impl crate::Readable for CONFIG0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`config0::W`](W) writer structure"]
        impl crate::Writable for CONFIG0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "WRITE (w) register accessor: Write messages to the VideoCore\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`write::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@write`]
module"]
    pub type WRITE = crate::Reg<write::WRITE_SPEC>;
    #[doc = "Write messages to the VideoCore"]
    pub mod write {
        #[doc = "Register `WRITE` writer"]
        pub type W = crate::W<WRITE_SPEC>;
        impl core::fmt::Debug for crate::generic::Reg<WRITE_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Write messages to the VideoCore\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`write::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WRITE_SPEC;
        impl crate::RegisterSpec for WRITE_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`write::W`](W) writer structure"]
        impl crate::Writable for WRITE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "PEEK1 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`peek1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`peek1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@peek1`]
module"]
    pub type PEEK1 = crate::Reg<peek1::PEEK1_SPEC>;
    #[doc = ""]
    pub mod peek1 {
        #[doc = "Register `PEEK1` reader"]
        pub type R = crate::R<PEEK1_SPEC>;
        #[doc = "Register `PEEK1` writer"]
        pub type W = crate::W<PEEK1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PEEK1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`peek1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`peek1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PEEK1_SPEC;
        impl crate::RegisterSpec for PEEK1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`peek1::R`](R) reader structure"]
        impl crate::Readable for PEEK1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`peek1::W`](W) writer structure"]
        impl crate::Writable for PEEK1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "SENDER1 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sender1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sender1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sender1`]
module"]
    pub type SENDER1 = crate::Reg<sender1::SENDER1_SPEC>;
    #[doc = ""]
    pub mod sender1 {
        #[doc = "Register `SENDER1` reader"]
        pub type R = crate::R<SENDER1_SPEC>;
        #[doc = "Register `SENDER1` writer"]
        pub type W = crate::W<SENDER1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<SENDER1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sender1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sender1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SENDER1_SPEC;
        impl crate::RegisterSpec for SENDER1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sender1::R`](R) reader structure"]
        impl crate::Readable for SENDER1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`sender1::W`](W) writer structure"]
        impl crate::Writable for SENDER1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "STATUS1 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status1`]
module"]
    pub type STATUS1 = crate::Reg<status1::STATUS1_SPEC>;
    #[doc = ""]
    pub mod status1 {
        #[doc = "Register `STATUS1` reader"]
        pub type R = crate::R<STATUS1_SPEC>;
        #[doc = "Register `STATUS1` writer"]
        pub type W = crate::W<STATUS1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<STATUS1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STATUS1_SPEC;
        impl crate::RegisterSpec for STATUS1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`status1::R`](R) reader structure"]
        impl crate::Readable for STATUS1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`status1::W`](W) writer structure"]
        impl crate::Writable for STATUS1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "CONFIG1 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`config1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config1`]
module"]
    pub type CONFIG1 = crate::Reg<config1::CONFIG1_SPEC>;
    #[doc = ""]
    pub mod config1 {
        #[doc = "Register `CONFIG1` reader"]
        pub type R = crate::R<CONFIG1_SPEC>;
        #[doc = "Register `CONFIG1` writer"]
        pub type W = crate::W<CONFIG1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CONFIG1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`config1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CONFIG1_SPEC;
        impl crate::RegisterSpec for CONFIG1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`config1::R`](R) reader structure"]
        impl crate::Readable for CONFIG1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`config1::W`](W) writer structure"]
        impl crate::Writable for CONFIG1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
}
#[doc = "Broadcom Power Manager"]
pub struct PM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PM {}
impl PM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pm::RegisterBlock = 0x2010_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PM {
    type Target = pm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PM").finish()
    }
}
#[doc = "Broadcom Power Manager"]
pub mod pm {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x1c],
        #[doc = "0x1c - Reset Control"]
        pub rstc: RSTC,
        _reserved1: [u8; 0x04],
        #[doc = "0x24 - Watchdog control"]
        pub wdog: WDOG,
    }
    #[doc = "RSTC (rw) register accessor: Reset Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rstc::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rstc::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rstc`]
module"]
    pub type RSTC = crate::Reg<rstc::RSTC_SPEC>;
    #[doc = "Reset Control"]
    pub mod rstc {
        #[doc = "Register `RSTC` reader"]
        pub type R = crate::R<RSTC_SPEC>;
        #[doc = "Register `RSTC` writer"]
        pub type W = crate::W<RSTC_SPEC>;
        #[doc = "Field `WRCFG` reader - Watchdog reset config"]
        pub type WRCFG_R = crate::FieldReader<WRCFG_A>;
        #[doc = "Watchdog reset config\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum WRCFG_A {
            #[doc = "2: `10`"]
            FULL_RESET = 2,
        }
        impl From<WRCFG_A> for u8 {
            #[inline(always)]
            fn from(variant: WRCFG_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for WRCFG_A {
            type Ux = u8;
        }
        impl WRCFG_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<WRCFG_A> {
                match self.bits {
                    2 => Some(WRCFG_A::FULL_RESET),
                    _ => None,
                }
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_full_reset(&self) -> bool {
                *self == WRCFG_A::FULL_RESET
            }
        }
        #[doc = "Field `WRCFG` writer - Watchdog reset config"]
        pub type WRCFG_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O, WRCFG_A>;
        impl<'a, REG, const O: u8> WRCFG_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`10`"]
            #[inline(always)]
            pub fn full_reset(self) -> &'a mut crate::W<REG> {
                self.variant(WRCFG_A::FULL_RESET)
            }
        }
        #[doc = "Password. Always 0x5a\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PASSWD_AW {
            #[doc = "90: `1011010`"]
            PASSWD = 90,
        }
        impl From<PASSWD_AW> for u8 {
            #[inline(always)]
            fn from(variant: PASSWD_AW) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PASSWD_AW {
            type Ux = u8;
        }
        #[doc = "Field `PASSWD` writer - Password. Always 0x5a"]
        pub type PASSWD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O, PASSWD_AW>;
        impl<'a, REG, const O: u8> PASSWD_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`1011010`"]
            #[inline(always)]
            pub fn passwd(self) -> &'a mut crate::W<REG> {
                self.variant(PASSWD_AW::PASSWD)
            }
        }
        impl R {
            #[doc = "Bits 4:5 - Watchdog reset config"]
            #[inline(always)]
            pub fn wrcfg(&self) -> WRCFG_R {
                WRCFG_R::new(((self.bits >> 4) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RSTC")
                    .field("wrcfg", &format_args!("{}", self.wrcfg().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RSTC_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 4:5 - Watchdog reset config"]
            #[inline(always)]
            #[must_use]
            pub fn wrcfg(&mut self) -> WRCFG_W<RSTC_SPEC, 4> {
                WRCFG_W::new(self)
            }
            #[doc = "Bits 24:31 - Password. Always 0x5a"]
            #[inline(always)]
            #[must_use]
            pub fn passwd(&mut self) -> PASSWD_W<RSTC_SPEC, 24> {
                PASSWD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Reset Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rstc::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rstc::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RSTC_SPEC;
        impl crate::RegisterSpec for RSTC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rstc::R`](R) reader structure"]
        impl crate::Readable for RSTC_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`rstc::W`](W) writer structure"]
        impl crate::Writable for RSTC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets RSTC to value 0x0102"]
        impl crate::Resettable for RSTC_SPEC {
            const RESET_VALUE: Self::Ux = 0x0102;
        }
    }
    #[doc = "WDOG (rw) register accessor: Watchdog control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`wdog::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdog::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wdog`]
module"]
    pub type WDOG = crate::Reg<wdog::WDOG_SPEC>;
    #[doc = "Watchdog control"]
    pub mod wdog {
        #[doc = "Register `WDOG` reader"]
        pub type R = crate::R<WDOG_SPEC>;
        #[doc = "Register `WDOG` writer"]
        pub type W = crate::W<WDOG_SPEC>;
        #[doc = "Field `TIME` reader - Time until watchdog alarm"]
        pub type TIME_R = crate::FieldReader<u32>;
        #[doc = "Field `TIME` writer - Time until watchdog alarm"]
        pub type TIME_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 20, O, u32>;
        #[doc = "Password. Always 0x5a\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PASSWD_AW {
            #[doc = "90: `1011010`"]
            PASSWD = 90,
        }
        impl From<PASSWD_AW> for u8 {
            #[inline(always)]
            fn from(variant: PASSWD_AW) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PASSWD_AW {
            type Ux = u8;
        }
        #[doc = "Field `PASSWD` writer - Password. Always 0x5a"]
        pub type PASSWD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O, PASSWD_AW>;
        impl<'a, REG, const O: u8> PASSWD_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`1011010`"]
            #[inline(always)]
            pub fn passwd(self) -> &'a mut crate::W<REG> {
                self.variant(PASSWD_AW::PASSWD)
            }
        }
        impl R {
            #[doc = "Bits 0:19 - Time until watchdog alarm"]
            #[inline(always)]
            pub fn time(&self) -> TIME_R {
                TIME_R::new(self.bits & 0x000f_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WDOG")
                    .field("time", &format_args!("{}", self.time().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<WDOG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:19 - Time until watchdog alarm"]
            #[inline(always)]
            #[must_use]
            pub fn time(&mut self) -> TIME_W<WDOG_SPEC, 0> {
                TIME_W::new(self)
            }
            #[doc = "Bits 24:31 - Password. Always 0x5a"]
            #[inline(always)]
            #[must_use]
            pub fn passwd(&mut self) -> PASSWD_W<WDOG_SPEC, 24> {
                PASSWD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Watchdog control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`wdog::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdog::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WDOG_SPEC;
        impl crate::RegisterSpec for WDOG_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`wdog::R`](R) reader structure"]
        impl crate::Readable for WDOG_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`wdog::W`](W) writer structure"]
        impl crate::Writable for WDOG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets WDOG to value 0"]
        impl crate::Resettable for WDOG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Broadcom Clock Manager"]
pub struct CM_PCM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CM_PCM {}
impl CM_PCM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cm_pcm::RegisterBlock = 0x2010_1098 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cm_pcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CM_PCM {
    type Target = cm_pcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CM_PCM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CM_PCM").finish()
    }
}
#[doc = "Broadcom Clock Manager"]
pub mod cm_pcm {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control / Status"]
        pub cs: CS,
        #[doc = "0x04 - Clock divisor"]
        pub div: DIV,
    }
    #[doc = "CS (rw) register accessor: Control / Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cs::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cs::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cs`]
module"]
    pub type CS = crate::Reg<cs::CS_SPEC>;
    #[doc = "Control / Status"]
    pub mod cs {
        #[doc = "Register `CS` reader"]
        pub type R = crate::R<CS_SPEC>;
        #[doc = "Register `CS` writer"]
        pub type W = crate::W<CS_SPEC>;
        #[doc = "Field `SRC` reader - Clock source"]
        pub type SRC_R = crate::FieldReader<SRC_A>;
        #[doc = "Clock source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SRC_A {
            #[doc = "1: `1`"]
            XOSC = 1,
            #[doc = "2: `10`"]
            TEST0 = 2,
            #[doc = "3: `11`"]
            TEST1 = 3,
            #[doc = "4: `100`"]
            PLLA = 4,
            #[doc = "5: `101`"]
            PLLB = 5,
            #[doc = "6: `110`"]
            PLLC = 6,
            #[doc = "7: `111`"]
            HDMI = 7,
        }
        impl From<SRC_A> for u8 {
            #[inline(always)]
            fn from(variant: SRC_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for SRC_A {
            type Ux = u8;
        }
        impl SRC_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<SRC_A> {
                match self.bits {
                    1 => Some(SRC_A::XOSC),
                    2 => Some(SRC_A::TEST0),
                    3 => Some(SRC_A::TEST1),
                    4 => Some(SRC_A::PLLA),
                    5 => Some(SRC_A::PLLB),
                    6 => Some(SRC_A::PLLC),
                    7 => Some(SRC_A::HDMI),
                    _ => None,
                }
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_xosc(&self) -> bool {
                *self == SRC_A::XOSC
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_test0(&self) -> bool {
                *self == SRC_A::TEST0
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_test1(&self) -> bool {
                *self == SRC_A::TEST1
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn is_plla(&self) -> bool {
                *self == SRC_A::PLLA
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn is_pllb(&self) -> bool {
                *self == SRC_A::PLLB
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn is_pllc(&self) -> bool {
                *self == SRC_A::PLLC
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn is_hdmi(&self) -> bool {
                *self == SRC_A::HDMI
            }
        }
        #[doc = "Field `SRC` writer - Clock source"]
        pub type SRC_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O, SRC_A>;
        impl<'a, REG, const O: u8> SRC_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn xosc(self) -> &'a mut crate::W<REG> {
                self.variant(SRC_A::XOSC)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn test0(self) -> &'a mut crate::W<REG> {
                self.variant(SRC_A::TEST0)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn test1(self) -> &'a mut crate::W<REG> {
                self.variant(SRC_A::TEST1)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn plla(self) -> &'a mut crate::W<REG> {
                self.variant(SRC_A::PLLA)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn pllb(self) -> &'a mut crate::W<REG> {
                self.variant(SRC_A::PLLB)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn pllc(self) -> &'a mut crate::W<REG> {
                self.variant(SRC_A::PLLC)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn hdmi(self) -> &'a mut crate::W<REG> {
                self.variant(SRC_A::HDMI)
            }
        }
        #[doc = "Field `ENAB` reader - Enable the clock generator. (Switch SRC first.)"]
        pub type ENAB_R = crate::BitReader;
        #[doc = "Field `ENAB` writer - Enable the clock generator. (Switch SRC first.)"]
        pub type ENAB_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `KILL` reader - Stop and reset the generator"]
        pub type KILL_R = crate::BitReader;
        #[doc = "Field `KILL` writer - Stop and reset the generator"]
        pub type KILL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BUSY` reader - Indicates the clock generator is running"]
        pub type BUSY_R = crate::BitReader;
        #[doc = "Field `FLIP` reader - Generate an edge on output. (For testing)"]
        pub type FLIP_R = crate::BitReader;
        #[doc = "Field `FLIP` writer - Generate an edge on output. (For testing)"]
        pub type FLIP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `MASH` reader - MASH control, stage count"]
        pub type MASH_R = crate::FieldReader;
        #[doc = "Field `MASH` writer - MASH control, stage count"]
        pub type MASH_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        #[doc = "Password. Always 0x5a\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PASSWD_AW {
            #[doc = "90: `1011010`"]
            PASSWD = 90,
        }
        impl From<PASSWD_AW> for u8 {
            #[inline(always)]
            fn from(variant: PASSWD_AW) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PASSWD_AW {
            type Ux = u8;
        }
        #[doc = "Field `PASSWD` writer - Password. Always 0x5a"]
        pub type PASSWD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O, PASSWD_AW>;
        impl<'a, REG, const O: u8> PASSWD_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`1011010`"]
            #[inline(always)]
            pub fn passwd(self) -> &'a mut crate::W<REG> {
                self.variant(PASSWD_AW::PASSWD)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Clock source"]
            #[inline(always)]
            pub fn src(&self) -> SRC_R {
                SRC_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 4 - Enable the clock generator. (Switch SRC first.)"]
            #[inline(always)]
            pub fn enab(&self) -> ENAB_R {
                ENAB_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Stop and reset the generator"]
            #[inline(always)]
            pub fn kill(&self) -> KILL_R {
                KILL_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 7 - Indicates the clock generator is running"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Generate an edge on output. (For testing)"]
            #[inline(always)]
            pub fn flip(&self) -> FLIP_R {
                FLIP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bits 9:10 - MASH control, stage count"]
            #[inline(always)]
            pub fn mash(&self) -> MASH_R {
                MASH_R::new(((self.bits >> 9) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CS")
                    .field("mash", &format_args!("{}", self.mash().bits()))
                    .field("flip", &format_args!("{}", self.flip().bit()))
                    .field("busy", &format_args!("{}", self.busy().bit()))
                    .field("kill", &format_args!("{}", self.kill().bit()))
                    .field("enab", &format_args!("{}", self.enab().bit()))
                    .field("src", &format_args!("{}", self.src().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Clock source"]
            #[inline(always)]
            #[must_use]
            pub fn src(&mut self) -> SRC_W<CS_SPEC, 0> {
                SRC_W::new(self)
            }
            #[doc = "Bit 4 - Enable the clock generator. (Switch SRC first.)"]
            #[inline(always)]
            #[must_use]
            pub fn enab(&mut self) -> ENAB_W<CS_SPEC, 4> {
                ENAB_W::new(self)
            }
            #[doc = "Bit 5 - Stop and reset the generator"]
            #[inline(always)]
            #[must_use]
            pub fn kill(&mut self) -> KILL_W<CS_SPEC, 5> {
                KILL_W::new(self)
            }
            #[doc = "Bit 8 - Generate an edge on output. (For testing)"]
            #[inline(always)]
            #[must_use]
            pub fn flip(&mut self) -> FLIP_W<CS_SPEC, 8> {
                FLIP_W::new(self)
            }
            #[doc = "Bits 9:10 - MASH control, stage count"]
            #[inline(always)]
            #[must_use]
            pub fn mash(&mut self) -> MASH_W<CS_SPEC, 9> {
                MASH_W::new(self)
            }
            #[doc = "Bits 24:31 - Password. Always 0x5a"]
            #[inline(always)]
            #[must_use]
            pub fn passwd(&mut self) -> PASSWD_W<CS_SPEC, 24> {
                PASSWD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control / Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cs::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cs::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CS_SPEC;
        impl crate::RegisterSpec for CS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cs::R`](R) reader structure"]
        impl crate::Readable for CS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cs::W`](W) writer structure"]
        impl crate::Writable for CS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CS to value 0"]
        impl crate::Resettable for CS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DIV (rw) register accessor: Clock divisor\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`]
module"]
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    #[doc = "Clock divisor"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DIV_SPEC>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DIV_SPEC>;
        #[doc = "Field `DIVF` reader - Fractional part of divisor"]
        pub type DIVF_R = crate::FieldReader<u16>;
        #[doc = "Field `DIVF` writer - Fractional part of divisor"]
        pub type DIVF_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 12, O, u16>;
        #[doc = "Field `DIVI` reader - Integer part of divisor"]
        pub type DIVI_R = crate::FieldReader<u16>;
        #[doc = "Field `DIVI` writer - Integer part of divisor"]
        pub type DIVI_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 12, O, u16>;
        #[doc = "Password. Always 0x5a\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PASSWD_AW {
            #[doc = "90: `1011010`"]
            PASSWD = 90,
        }
        impl From<PASSWD_AW> for u8 {
            #[inline(always)]
            fn from(variant: PASSWD_AW) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PASSWD_AW {
            type Ux = u8;
        }
        #[doc = "Field `PASSWD` writer - Password. Always 0x5a"]
        pub type PASSWD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O, PASSWD_AW>;
        impl<'a, REG, const O: u8> PASSWD_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`1011010`"]
            #[inline(always)]
            pub fn passwd(self) -> &'a mut crate::W<REG> {
                self.variant(PASSWD_AW::PASSWD)
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Fractional part of divisor"]
            #[inline(always)]
            pub fn divf(&self) -> DIVF_R {
                DIVF_R::new((self.bits & 0x0fff) as u16)
            }
            #[doc = "Bits 12:23 - Integer part of divisor"]
            #[inline(always)]
            pub fn divi(&self) -> DIVI_R {
                DIVI_R::new(((self.bits >> 12) & 0x0fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIV")
                    .field("divi", &format_args!("{}", self.divi().bits()))
                    .field("divf", &format_args!("{}", self.divf().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIV_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Fractional part of divisor"]
            #[inline(always)]
            #[must_use]
            pub fn divf(&mut self) -> DIVF_W<DIV_SPEC, 0> {
                DIVF_W::new(self)
            }
            #[doc = "Bits 12:23 - Integer part of divisor"]
            #[inline(always)]
            #[must_use]
            pub fn divi(&mut self) -> DIVI_W<DIV_SPEC, 12> {
                DIVI_W::new(self)
            }
            #[doc = "Bits 24:31 - Password. Always 0x5a"]
            #[inline(always)]
            #[must_use]
            pub fn passwd(&mut self) -> PASSWD_W<DIV_SPEC, 24> {
                PASSWD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Clock divisor\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DIV_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIV to value 0"]
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Broadcom Clock Manager"]
pub struct CM_PWM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CM_PWM {}
impl CM_PWM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cm_pcm::RegisterBlock = 0x2010_10a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cm_pcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CM_PWM {
    type Target = cm_pcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CM_PWM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CM_PWM").finish()
    }
}
#[doc = "Broadcom Clock Manager"]
pub use self::cm_pcm as cm_pwm;
#[doc = "Pin level and mux control"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x2020_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "Pin level and mux control"]
pub mod gpio {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - GPIO Function Select 0"]
        pub gpfsel0: GPFSEL0,
        #[doc = "0x04 - GPIO Function Select 1"]
        pub gpfsel1: GPFSEL1,
        #[doc = "0x08 - GPIO Function Select 2"]
        pub gpfsel2: GPFSEL2,
        #[doc = "0x0c - GPIO Function Select 3"]
        pub gpfsel3: GPFSEL3,
        #[doc = "0x10 - GPIO Function Select 4"]
        pub gpfsel4: GPFSEL4,
        #[doc = "0x14 - GPIO Function Select 5"]
        pub gpfsel5: GPFSEL5,
        _reserved6: [u8; 0x04],
        #[doc = "0x1c - GPIO Pin Output Set 0"]
        pub gpset0: GPSET0,
        #[doc = "0x20 - GPIO Pin Output Set 1"]
        pub gpset1: GPSET1,
        _reserved8: [u8; 0x04],
        #[doc = "0x28 - GPIO Pin Output Clear 0"]
        pub gpclr0: GPCLR0,
        #[doc = "0x2c - GPIO Pin Output Clear 1"]
        pub gpclr1: GPCLR1,
        _reserved10: [u8; 0x04],
        #[doc = "0x34 - GPIO Pin Level 0"]
        pub gplev0: GPLEV0,
        #[doc = "0x38 - GPIO Pin Level 1"]
        pub gplev1: GPLEV1,
        _reserved12: [u8; 0x04],
        #[doc = "0x40 - GPIO Pin Event Detect Status 0"]
        pub gpeds0: GPEDS0,
        #[doc = "0x44 - GPIO Pin Event Detect Status 1"]
        pub gpeds1: GPEDS1,
        _reserved14: [u8; 0x04],
        #[doc = "0x4c - GPIO Pin Rising Edge Detect Enable 0"]
        pub gpren0: GPREN0,
        #[doc = "0x50 - GPIO Pin Rising Edge Detect Enable 1"]
        pub gpren1: GPREN1,
        _reserved16: [u8; 0x04],
        #[doc = "0x58 - GPIO Pin Falling Edge Detect Enable 0"]
        pub gpfen0: GPFEN0,
        #[doc = "0x5c - GPIO Pin Falling Edge Detect Enable 1"]
        pub gpfen1: GPFEN1,
        _reserved18: [u8; 0x04],
        #[doc = "0x64 - GPIO Pin High Detect Enable 0"]
        pub gphen0: GPHEN0,
        #[doc = "0x68 - GPIO Pin High Detect Enable 1"]
        pub gphen1: GPHEN1,
        _reserved20: [u8; 0x04],
        #[doc = "0x70 - GPIO Pin Low Detect Enable 0"]
        pub gplen0: GPLEN0,
        #[doc = "0x74 - GPIO Pin Low Detect Enable 1"]
        pub gplen1: GPLEN1,
        _reserved22: [u8; 0x04],
        #[doc = "0x7c - GPIO Pin Async. Rising Edge Detect 0"]
        pub gparen0: GPAREN0,
        #[doc = "0x80 - GPIO Pin Async. Rising Edge Detect 1"]
        pub gparen1: GPAREN1,
        _reserved24: [u8; 0x04],
        #[doc = "0x88 - GPIO Pin Async. Falling Edge Detect 0"]
        pub gpafen0: GPAFEN0,
        #[doc = "0x8c - GPIO Pin Async. Falling Edge Detect 1"]
        pub gpafen1: GPAFEN1,
        _reserved26: [u8; 0x40],
        #[doc = "0xd0 - Undocumented multiplexing bits"]
        pub extra_mux: EXTRA_MUX,
        _reserved27: [u8; 0x10],
        #[doc = "0xe4 - GPIO Pull-up / Pull-down Register 0"]
        pub gpio_pup_pdn_cntrl_reg0: GPIO_PUP_PDN_CNTRL_REG0,
        #[doc = "0xe8 - GPIO Pull-up / Pull-down Register 1"]
        pub gpio_pup_pdn_cntrl_reg1: GPIO_PUP_PDN_CNTRL_REG1,
        #[doc = "0xec - GPIO Pull-up / Pull-down Register 2"]
        pub gpio_pup_pdn_cntrl_reg2: GPIO_PUP_PDN_CNTRL_REG2,
        #[doc = "0xf0 - GPIO Pull-up / Pull-down Register 3"]
        pub gpio_pup_pdn_cntrl_reg3: GPIO_PUP_PDN_CNTRL_REG3,
    }
    #[doc = "GPFSEL0 (rw) register accessor: GPIO Function Select 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpfsel0`]
module"]
    pub type GPFSEL0 = crate::Reg<gpfsel0::GPFSEL0_SPEC>;
    #[doc = "GPIO Function Select 0"]
    pub mod gpfsel0 {
        #[doc = "Register `GPFSEL0` reader"]
        pub type R = crate::R<GPFSEL0_SPEC>;
        #[doc = "Register `GPFSEL0` writer"]
        pub type W = crate::W<GPFSEL0_SPEC>;
        #[doc = "Field `FSEL0` reader - Function Select 0"]
        pub type FSEL0_R = crate::FieldReader<FSEL0_A>;
        #[doc = "Function Select 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL0_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SDA0"]
            SDA0 = 4,
            #[doc = "5: Pin is connected to SA5"]
            SA5 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL0_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL0_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL0_A {
            type Ux = u8;
        }
        impl FSEL0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL0_A {
                match self.bits {
                    0 => FSEL0_A::INPUT,
                    1 => FSEL0_A::OUTPUT,
                    4 => FSEL0_A::SDA0,
                    5 => FSEL0_A::SA5,
                    6 => FSEL0_A::RESERVED2,
                    7 => FSEL0_A::RESERVED3,
                    3 => FSEL0_A::RESERVED4,
                    2 => FSEL0_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL0_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL0_A::OUTPUT
            }
            #[doc = "Pin is connected to SDA0"]
            #[inline(always)]
            pub fn is_sda0(&self) -> bool {
                *self == FSEL0_A::SDA0
            }
            #[doc = "Pin is connected to SA5"]
            #[inline(always)]
            pub fn is_sa5(&self) -> bool {
                *self == FSEL0_A::SA5
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL0_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL0_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL0_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL0_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL0` writer - Function Select 0"]
        pub type FSEL0_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL0_A>;
        impl<'a, REG, const O: u8> FSEL0_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL0_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL0_A::OUTPUT)
            }
            #[doc = "Pin is connected to SDA0"]
            #[inline(always)]
            pub fn sda0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL0_A::SDA0)
            }
            #[doc = "Pin is connected to SA5"]
            #[inline(always)]
            pub fn sa5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL0_A::SA5)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL0_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL0_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL0_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL0_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL1` reader - Function Select 1"]
        pub type FSEL1_R = crate::FieldReader<FSEL1_A>;
        #[doc = "Function Select 1"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL1_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SCL0"]
            SCL0 = 4,
            #[doc = "5: Pin is connected to SA4"]
            SA4 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL1_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL1_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL1_A {
            type Ux = u8;
        }
        impl FSEL1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL1_A {
                match self.bits {
                    0 => FSEL1_A::INPUT,
                    1 => FSEL1_A::OUTPUT,
                    4 => FSEL1_A::SCL0,
                    5 => FSEL1_A::SA4,
                    6 => FSEL1_A::RESERVED2,
                    7 => FSEL1_A::RESERVED3,
                    3 => FSEL1_A::RESERVED4,
                    2 => FSEL1_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL1_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL1_A::OUTPUT
            }
            #[doc = "Pin is connected to SCL0"]
            #[inline(always)]
            pub fn is_scl0(&self) -> bool {
                *self == FSEL1_A::SCL0
            }
            #[doc = "Pin is connected to SA4"]
            #[inline(always)]
            pub fn is_sa4(&self) -> bool {
                *self == FSEL1_A::SA4
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL1_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL1_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL1_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL1_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL1` writer - Function Select 1"]
        pub type FSEL1_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL1_A>;
        impl<'a, REG, const O: u8> FSEL1_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL1_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL1_A::OUTPUT)
            }
            #[doc = "Pin is connected to SCL0"]
            #[inline(always)]
            pub fn scl0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL1_A::SCL0)
            }
            #[doc = "Pin is connected to SA4"]
            #[inline(always)]
            pub fn sa4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL1_A::SA4)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL1_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL1_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL1_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL1_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL2` reader - Function Select 2"]
        pub type FSEL2_R = crate::FieldReader<FSEL2_A>;
        #[doc = "Function Select 2"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL2_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SDA1"]
            SDA1 = 4,
            #[doc = "5: Pin is connected to SA3"]
            SA3 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL2_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL2_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL2_A {
            type Ux = u8;
        }
        impl FSEL2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL2_A {
                match self.bits {
                    0 => FSEL2_A::INPUT,
                    1 => FSEL2_A::OUTPUT,
                    4 => FSEL2_A::SDA1,
                    5 => FSEL2_A::SA3,
                    6 => FSEL2_A::RESERVED2,
                    7 => FSEL2_A::RESERVED3,
                    3 => FSEL2_A::RESERVED4,
                    2 => FSEL2_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL2_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL2_A::OUTPUT
            }
            #[doc = "Pin is connected to SDA1"]
            #[inline(always)]
            pub fn is_sda1(&self) -> bool {
                *self == FSEL2_A::SDA1
            }
            #[doc = "Pin is connected to SA3"]
            #[inline(always)]
            pub fn is_sa3(&self) -> bool {
                *self == FSEL2_A::SA3
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL2_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL2_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL2_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL2_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL2` writer - Function Select 2"]
        pub type FSEL2_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL2_A>;
        impl<'a, REG, const O: u8> FSEL2_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL2_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL2_A::OUTPUT)
            }
            #[doc = "Pin is connected to SDA1"]
            #[inline(always)]
            pub fn sda1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL2_A::SDA1)
            }
            #[doc = "Pin is connected to SA3"]
            #[inline(always)]
            pub fn sa3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL2_A::SA3)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL2_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL2_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL2_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL2_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL3` reader - Function Select 3"]
        pub type FSEL3_R = crate::FieldReader<FSEL3_A>;
        #[doc = "Function Select 3"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL3_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SCL1"]
            SCL1 = 4,
            #[doc = "5: Pin is connected to SA2"]
            SA2 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL3_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL3_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL3_A {
            type Ux = u8;
        }
        impl FSEL3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL3_A {
                match self.bits {
                    0 => FSEL3_A::INPUT,
                    1 => FSEL3_A::OUTPUT,
                    4 => FSEL3_A::SCL1,
                    5 => FSEL3_A::SA2,
                    6 => FSEL3_A::RESERVED2,
                    7 => FSEL3_A::RESERVED3,
                    3 => FSEL3_A::RESERVED4,
                    2 => FSEL3_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL3_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL3_A::OUTPUT
            }
            #[doc = "Pin is connected to SCL1"]
            #[inline(always)]
            pub fn is_scl1(&self) -> bool {
                *self == FSEL3_A::SCL1
            }
            #[doc = "Pin is connected to SA2"]
            #[inline(always)]
            pub fn is_sa2(&self) -> bool {
                *self == FSEL3_A::SA2
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL3_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL3_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL3_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL3_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL3` writer - Function Select 3"]
        pub type FSEL3_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL3_A>;
        impl<'a, REG, const O: u8> FSEL3_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL3_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL3_A::OUTPUT)
            }
            #[doc = "Pin is connected to SCL1"]
            #[inline(always)]
            pub fn scl1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL3_A::SCL1)
            }
            #[doc = "Pin is connected to SA2"]
            #[inline(always)]
            pub fn sa2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL3_A::SA2)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL3_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL3_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL3_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL3_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL4` reader - Function Select 4"]
        pub type FSEL4_R = crate::FieldReader<FSEL4_A>;
        #[doc = "Function Select 4"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL4_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to GPCLK0"]
            GPCLK0 = 4,
            #[doc = "5: Pin is connected to SA1"]
            SA1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to ARM_TDI"]
            ARM_TDI = 2,
        }
        impl From<FSEL4_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL4_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL4_A {
            type Ux = u8;
        }
        impl FSEL4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL4_A {
                match self.bits {
                    0 => FSEL4_A::INPUT,
                    1 => FSEL4_A::OUTPUT,
                    4 => FSEL4_A::GPCLK0,
                    5 => FSEL4_A::SA1,
                    6 => FSEL4_A::RESERVED2,
                    7 => FSEL4_A::RESERVED3,
                    3 => FSEL4_A::RESERVED4,
                    2 => FSEL4_A::ARM_TDI,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL4_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL4_A::OUTPUT
            }
            #[doc = "Pin is connected to GPCLK0"]
            #[inline(always)]
            pub fn is_gpclk0(&self) -> bool {
                *self == FSEL4_A::GPCLK0
            }
            #[doc = "Pin is connected to SA1"]
            #[inline(always)]
            pub fn is_sa1(&self) -> bool {
                *self == FSEL4_A::SA1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL4_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL4_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL4_A::RESERVED4
            }
            #[doc = "Pin is connected to ARM_TDI"]
            #[inline(always)]
            pub fn is_arm_tdi(&self) -> bool {
                *self == FSEL4_A::ARM_TDI
            }
        }
        #[doc = "Field `FSEL4` writer - Function Select 4"]
        pub type FSEL4_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL4_A>;
        impl<'a, REG, const O: u8> FSEL4_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL4_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL4_A::OUTPUT)
            }
            #[doc = "Pin is connected to GPCLK0"]
            #[inline(always)]
            pub fn gpclk0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL4_A::GPCLK0)
            }
            #[doc = "Pin is connected to SA1"]
            #[inline(always)]
            pub fn sa1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL4_A::SA1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL4_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL4_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL4_A::RESERVED4)
            }
            #[doc = "Pin is connected to ARM_TDI"]
            #[inline(always)]
            pub fn arm_tdi(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL4_A::ARM_TDI)
            }
        }
        #[doc = "Field `FSEL5` reader - Function Select 5"]
        pub type FSEL5_R = crate::FieldReader<FSEL5_A>;
        #[doc = "Function Select 5"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL5_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to GPCLK1"]
            GPCLK1 = 4,
            #[doc = "5: Pin is connected to SA0"]
            SA0 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to ARM_TDO"]
            ARM_TDO = 2,
        }
        impl From<FSEL5_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL5_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL5_A {
            type Ux = u8;
        }
        impl FSEL5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL5_A {
                match self.bits {
                    0 => FSEL5_A::INPUT,
                    1 => FSEL5_A::OUTPUT,
                    4 => FSEL5_A::GPCLK1,
                    5 => FSEL5_A::SA0,
                    6 => FSEL5_A::RESERVED2,
                    7 => FSEL5_A::RESERVED3,
                    3 => FSEL5_A::RESERVED4,
                    2 => FSEL5_A::ARM_TDO,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL5_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL5_A::OUTPUT
            }
            #[doc = "Pin is connected to GPCLK1"]
            #[inline(always)]
            pub fn is_gpclk1(&self) -> bool {
                *self == FSEL5_A::GPCLK1
            }
            #[doc = "Pin is connected to SA0"]
            #[inline(always)]
            pub fn is_sa0(&self) -> bool {
                *self == FSEL5_A::SA0
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL5_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL5_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL5_A::RESERVED4
            }
            #[doc = "Pin is connected to ARM_TDO"]
            #[inline(always)]
            pub fn is_arm_tdo(&self) -> bool {
                *self == FSEL5_A::ARM_TDO
            }
        }
        #[doc = "Field `FSEL5` writer - Function Select 5"]
        pub type FSEL5_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL5_A>;
        impl<'a, REG, const O: u8> FSEL5_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL5_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL5_A::OUTPUT)
            }
            #[doc = "Pin is connected to GPCLK1"]
            #[inline(always)]
            pub fn gpclk1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL5_A::GPCLK1)
            }
            #[doc = "Pin is connected to SA0"]
            #[inline(always)]
            pub fn sa0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL5_A::SA0)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL5_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL5_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL5_A::RESERVED4)
            }
            #[doc = "Pin is connected to ARM_TDO"]
            #[inline(always)]
            pub fn arm_tdo(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL5_A::ARM_TDO)
            }
        }
        #[doc = "Field `FSEL6` reader - Function Select 6"]
        pub type FSEL6_R = crate::FieldReader<FSEL6_A>;
        #[doc = "Function Select 6"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL6_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to GPCLK2"]
            GPCLK2 = 4,
            #[doc = "5: Pin is connected to SOE_N"]
            SOE_N = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to ARM_RTCK"]
            ARM_RTCK = 2,
        }
        impl From<FSEL6_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL6_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL6_A {
            type Ux = u8;
        }
        impl FSEL6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL6_A {
                match self.bits {
                    0 => FSEL6_A::INPUT,
                    1 => FSEL6_A::OUTPUT,
                    4 => FSEL6_A::GPCLK2,
                    5 => FSEL6_A::SOE_N,
                    6 => FSEL6_A::RESERVED2,
                    7 => FSEL6_A::RESERVED3,
                    3 => FSEL6_A::RESERVED4,
                    2 => FSEL6_A::ARM_RTCK,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL6_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL6_A::OUTPUT
            }
            #[doc = "Pin is connected to GPCLK2"]
            #[inline(always)]
            pub fn is_gpclk2(&self) -> bool {
                *self == FSEL6_A::GPCLK2
            }
            #[doc = "Pin is connected to SOE_N"]
            #[inline(always)]
            pub fn is_soe_n(&self) -> bool {
                *self == FSEL6_A::SOE_N
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL6_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL6_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL6_A::RESERVED4
            }
            #[doc = "Pin is connected to ARM_RTCK"]
            #[inline(always)]
            pub fn is_arm_rtck(&self) -> bool {
                *self == FSEL6_A::ARM_RTCK
            }
        }
        #[doc = "Field `FSEL6` writer - Function Select 6"]
        pub type FSEL6_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL6_A>;
        impl<'a, REG, const O: u8> FSEL6_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL6_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL6_A::OUTPUT)
            }
            #[doc = "Pin is connected to GPCLK2"]
            #[inline(always)]
            pub fn gpclk2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL6_A::GPCLK2)
            }
            #[doc = "Pin is connected to SOE_N"]
            #[inline(always)]
            pub fn soe_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL6_A::SOE_N)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL6_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL6_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL6_A::RESERVED4)
            }
            #[doc = "Pin is connected to ARM_RTCK"]
            #[inline(always)]
            pub fn arm_rtck(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL6_A::ARM_RTCK)
            }
        }
        #[doc = "Field `FSEL7` reader - Function Select 7"]
        pub type FSEL7_R = crate::FieldReader<FSEL7_A>;
        #[doc = "Function Select 7"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL7_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_CE1_N"]
            SPI0_CE1_N = 4,
            #[doc = "5: Pin is connected to SWE_N"]
            SWE_N = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL7_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL7_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL7_A {
            type Ux = u8;
        }
        impl FSEL7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL7_A {
                match self.bits {
                    0 => FSEL7_A::INPUT,
                    1 => FSEL7_A::OUTPUT,
                    4 => FSEL7_A::SPI0_CE1_N,
                    5 => FSEL7_A::SWE_N,
                    6 => FSEL7_A::RESERVED2,
                    7 => FSEL7_A::RESERVED3,
                    3 => FSEL7_A::RESERVED4,
                    2 => FSEL7_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL7_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL7_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_CE1_N"]
            #[inline(always)]
            pub fn is_spi0_ce1_n(&self) -> bool {
                *self == FSEL7_A::SPI0_CE1_N
            }
            #[doc = "Pin is connected to SWE_N"]
            #[inline(always)]
            pub fn is_swe_n(&self) -> bool {
                *self == FSEL7_A::SWE_N
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL7_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL7_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL7_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL7_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL7` writer - Function Select 7"]
        pub type FSEL7_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL7_A>;
        impl<'a, REG, const O: u8> FSEL7_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL7_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL7_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_CE1_N"]
            #[inline(always)]
            pub fn spi0_ce1_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL7_A::SPI0_CE1_N)
            }
            #[doc = "Pin is connected to SWE_N"]
            #[inline(always)]
            pub fn swe_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL7_A::SWE_N)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL7_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL7_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL7_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL7_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL8` reader - Function Select 8"]
        pub type FSEL8_R = crate::FieldReader<FSEL8_A>;
        #[doc = "Function Select 8"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL8_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_CE0_N"]
            SPI0_CE0_N = 4,
            #[doc = "5: Pin is connected to SD0"]
            SD0 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL8_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL8_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL8_A {
            type Ux = u8;
        }
        impl FSEL8_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL8_A {
                match self.bits {
                    0 => FSEL8_A::INPUT,
                    1 => FSEL8_A::OUTPUT,
                    4 => FSEL8_A::SPI0_CE0_N,
                    5 => FSEL8_A::SD0,
                    6 => FSEL8_A::RESERVED2,
                    7 => FSEL8_A::RESERVED3,
                    3 => FSEL8_A::RESERVED4,
                    2 => FSEL8_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL8_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL8_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_CE0_N"]
            #[inline(always)]
            pub fn is_spi0_ce0_n(&self) -> bool {
                *self == FSEL8_A::SPI0_CE0_N
            }
            #[doc = "Pin is connected to SD0"]
            #[inline(always)]
            pub fn is_sd0(&self) -> bool {
                *self == FSEL8_A::SD0
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL8_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL8_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL8_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL8_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL8` writer - Function Select 8"]
        pub type FSEL8_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL8_A>;
        impl<'a, REG, const O: u8> FSEL8_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL8_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL8_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_CE0_N"]
            #[inline(always)]
            pub fn spi0_ce0_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL8_A::SPI0_CE0_N)
            }
            #[doc = "Pin is connected to SD0"]
            #[inline(always)]
            pub fn sd0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL8_A::SD0)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL8_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL8_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL8_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL8_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL9` reader - Function Select 9"]
        pub type FSEL9_R = crate::FieldReader<FSEL9_A>;
        #[doc = "Function Select 9"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL9_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_MISO"]
            SPI0_MISO = 4,
            #[doc = "5: Pin is connected to SD1"]
            SD1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL9_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL9_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL9_A {
            type Ux = u8;
        }
        impl FSEL9_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL9_A {
                match self.bits {
                    0 => FSEL9_A::INPUT,
                    1 => FSEL9_A::OUTPUT,
                    4 => FSEL9_A::SPI0_MISO,
                    5 => FSEL9_A::SD1,
                    6 => FSEL9_A::RESERVED2,
                    7 => FSEL9_A::RESERVED3,
                    3 => FSEL9_A::RESERVED4,
                    2 => FSEL9_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL9_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL9_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_MISO"]
            #[inline(always)]
            pub fn is_spi0_miso(&self) -> bool {
                *self == FSEL9_A::SPI0_MISO
            }
            #[doc = "Pin is connected to SD1"]
            #[inline(always)]
            pub fn is_sd1(&self) -> bool {
                *self == FSEL9_A::SD1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL9_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL9_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL9_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL9_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL9` writer - Function Select 9"]
        pub type FSEL9_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL9_A>;
        impl<'a, REG, const O: u8> FSEL9_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL9_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL9_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_MISO"]
            #[inline(always)]
            pub fn spi0_miso(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL9_A::SPI0_MISO)
            }
            #[doc = "Pin is connected to SD1"]
            #[inline(always)]
            pub fn sd1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL9_A::SD1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL9_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL9_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL9_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL9_A::RESERVED5)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Function Select 0"]
            #[inline(always)]
            pub fn fsel0(&self) -> FSEL0_R {
                FSEL0_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:5 - Function Select 1"]
            #[inline(always)]
            pub fn fsel1(&self) -> FSEL1_R {
                FSEL1_R::new(((self.bits >> 3) & 7) as u8)
            }
            #[doc = "Bits 6:8 - Function Select 2"]
            #[inline(always)]
            pub fn fsel2(&self) -> FSEL2_R {
                FSEL2_R::new(((self.bits >> 6) & 7) as u8)
            }
            #[doc = "Bits 9:11 - Function Select 3"]
            #[inline(always)]
            pub fn fsel3(&self) -> FSEL3_R {
                FSEL3_R::new(((self.bits >> 9) & 7) as u8)
            }
            #[doc = "Bits 12:14 - Function Select 4"]
            #[inline(always)]
            pub fn fsel4(&self) -> FSEL4_R {
                FSEL4_R::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bits 15:17 - Function Select 5"]
            #[inline(always)]
            pub fn fsel5(&self) -> FSEL5_R {
                FSEL5_R::new(((self.bits >> 15) & 7) as u8)
            }
            #[doc = "Bits 18:20 - Function Select 6"]
            #[inline(always)]
            pub fn fsel6(&self) -> FSEL6_R {
                FSEL6_R::new(((self.bits >> 18) & 7) as u8)
            }
            #[doc = "Bits 21:23 - Function Select 7"]
            #[inline(always)]
            pub fn fsel7(&self) -> FSEL7_R {
                FSEL7_R::new(((self.bits >> 21) & 7) as u8)
            }
            #[doc = "Bits 24:26 - Function Select 8"]
            #[inline(always)]
            pub fn fsel8(&self) -> FSEL8_R {
                FSEL8_R::new(((self.bits >> 24) & 7) as u8)
            }
            #[doc = "Bits 27:29 - Function Select 9"]
            #[inline(always)]
            pub fn fsel9(&self) -> FSEL9_R {
                FSEL9_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPFSEL0")
                    .field("fsel0", &format_args!("{}", self.fsel0().bits()))
                    .field("fsel1", &format_args!("{}", self.fsel1().bits()))
                    .field("fsel2", &format_args!("{}", self.fsel2().bits()))
                    .field("fsel3", &format_args!("{}", self.fsel3().bits()))
                    .field("fsel4", &format_args!("{}", self.fsel4().bits()))
                    .field("fsel5", &format_args!("{}", self.fsel5().bits()))
                    .field("fsel6", &format_args!("{}", self.fsel6().bits()))
                    .field("fsel7", &format_args!("{}", self.fsel7().bits()))
                    .field("fsel8", &format_args!("{}", self.fsel8().bits()))
                    .field("fsel9", &format_args!("{}", self.fsel9().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPFSEL0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Function Select 0"]
            #[inline(always)]
            #[must_use]
            pub fn fsel0(&mut self) -> FSEL0_W<GPFSEL0_SPEC, 0> {
                FSEL0_W::new(self)
            }
            #[doc = "Bits 3:5 - Function Select 1"]
            #[inline(always)]
            #[must_use]
            pub fn fsel1(&mut self) -> FSEL1_W<GPFSEL0_SPEC, 3> {
                FSEL1_W::new(self)
            }
            #[doc = "Bits 6:8 - Function Select 2"]
            #[inline(always)]
            #[must_use]
            pub fn fsel2(&mut self) -> FSEL2_W<GPFSEL0_SPEC, 6> {
                FSEL2_W::new(self)
            }
            #[doc = "Bits 9:11 - Function Select 3"]
            #[inline(always)]
            #[must_use]
            pub fn fsel3(&mut self) -> FSEL3_W<GPFSEL0_SPEC, 9> {
                FSEL3_W::new(self)
            }
            #[doc = "Bits 12:14 - Function Select 4"]
            #[inline(always)]
            #[must_use]
            pub fn fsel4(&mut self) -> FSEL4_W<GPFSEL0_SPEC, 12> {
                FSEL4_W::new(self)
            }
            #[doc = "Bits 15:17 - Function Select 5"]
            #[inline(always)]
            #[must_use]
            pub fn fsel5(&mut self) -> FSEL5_W<GPFSEL0_SPEC, 15> {
                FSEL5_W::new(self)
            }
            #[doc = "Bits 18:20 - Function Select 6"]
            #[inline(always)]
            #[must_use]
            pub fn fsel6(&mut self) -> FSEL6_W<GPFSEL0_SPEC, 18> {
                FSEL6_W::new(self)
            }
            #[doc = "Bits 21:23 - Function Select 7"]
            #[inline(always)]
            #[must_use]
            pub fn fsel7(&mut self) -> FSEL7_W<GPFSEL0_SPEC, 21> {
                FSEL7_W::new(self)
            }
            #[doc = "Bits 24:26 - Function Select 8"]
            #[inline(always)]
            #[must_use]
            pub fn fsel8(&mut self) -> FSEL8_W<GPFSEL0_SPEC, 24> {
                FSEL8_W::new(self)
            }
            #[doc = "Bits 27:29 - Function Select 9"]
            #[inline(always)]
            #[must_use]
            pub fn fsel9(&mut self) -> FSEL9_W<GPFSEL0_SPEC, 27> {
                FSEL9_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Function Select 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPFSEL0_SPEC;
        impl crate::RegisterSpec for GPFSEL0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpfsel0::R`](R) reader structure"]
        impl crate::Readable for GPFSEL0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpfsel0::W`](W) writer structure"]
        impl crate::Writable for GPFSEL0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPFSEL1 (rw) register accessor: GPIO Function Select 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpfsel1`]
module"]
    pub type GPFSEL1 = crate::Reg<gpfsel1::GPFSEL1_SPEC>;
    #[doc = "GPIO Function Select 1"]
    pub mod gpfsel1 {
        #[doc = "Register `GPFSEL1` reader"]
        pub type R = crate::R<GPFSEL1_SPEC>;
        #[doc = "Register `GPFSEL1` writer"]
        pub type W = crate::W<GPFSEL1_SPEC>;
        #[doc = "Field `FSEL10` reader - Function Select 10"]
        pub type FSEL10_R = crate::FieldReader<FSEL10_A>;
        #[doc = "Function Select 10"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL10_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_MOSI"]
            SPI0_MOSI = 4,
            #[doc = "5: Pin is connected to SD2"]
            SD2 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL10_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL10_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL10_A {
            type Ux = u8;
        }
        impl FSEL10_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL10_A {
                match self.bits {
                    0 => FSEL10_A::INPUT,
                    1 => FSEL10_A::OUTPUT,
                    4 => FSEL10_A::SPI0_MOSI,
                    5 => FSEL10_A::SD2,
                    6 => FSEL10_A::RESERVED2,
                    7 => FSEL10_A::RESERVED3,
                    3 => FSEL10_A::RESERVED4,
                    2 => FSEL10_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL10_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL10_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_MOSI"]
            #[inline(always)]
            pub fn is_spi0_mosi(&self) -> bool {
                *self == FSEL10_A::SPI0_MOSI
            }
            #[doc = "Pin is connected to SD2"]
            #[inline(always)]
            pub fn is_sd2(&self) -> bool {
                *self == FSEL10_A::SD2
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL10_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL10_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL10_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL10_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL10` writer - Function Select 10"]
        pub type FSEL10_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL10_A>;
        impl<'a, REG, const O: u8> FSEL10_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL10_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL10_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_MOSI"]
            #[inline(always)]
            pub fn spi0_mosi(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL10_A::SPI0_MOSI)
            }
            #[doc = "Pin is connected to SD2"]
            #[inline(always)]
            pub fn sd2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL10_A::SD2)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL10_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL10_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL10_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL10_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL11` reader - Function Select 11"]
        pub type FSEL11_R = crate::FieldReader<FSEL11_A>;
        #[doc = "Function Select 11"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL11_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_SCLK"]
            SPI0_SCLK = 4,
            #[doc = "5: Pin is connected to SD3"]
            SD3 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL11_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL11_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL11_A {
            type Ux = u8;
        }
        impl FSEL11_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL11_A {
                match self.bits {
                    0 => FSEL11_A::INPUT,
                    1 => FSEL11_A::OUTPUT,
                    4 => FSEL11_A::SPI0_SCLK,
                    5 => FSEL11_A::SD3,
                    6 => FSEL11_A::RESERVED2,
                    7 => FSEL11_A::RESERVED3,
                    3 => FSEL11_A::RESERVED4,
                    2 => FSEL11_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL11_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL11_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_SCLK"]
            #[inline(always)]
            pub fn is_spi0_sclk(&self) -> bool {
                *self == FSEL11_A::SPI0_SCLK
            }
            #[doc = "Pin is connected to SD3"]
            #[inline(always)]
            pub fn is_sd3(&self) -> bool {
                *self == FSEL11_A::SD3
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL11_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL11_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL11_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL11_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL11` writer - Function Select 11"]
        pub type FSEL11_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL11_A>;
        impl<'a, REG, const O: u8> FSEL11_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL11_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL11_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_SCLK"]
            #[inline(always)]
            pub fn spi0_sclk(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL11_A::SPI0_SCLK)
            }
            #[doc = "Pin is connected to SD3"]
            #[inline(always)]
            pub fn sd3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL11_A::SD3)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL11_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL11_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL11_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL11_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL12` reader - Function Select 12"]
        pub type FSEL12_R = crate::FieldReader<FSEL12_A>;
        #[doc = "Function Select 12"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL12_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PWM0_0"]
            PWM0_0 = 4,
            #[doc = "5: Pin is connected to SD4"]
            SD4 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to ARM_TMS"]
            ARM_TMS = 2,
        }
        impl From<FSEL12_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL12_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL12_A {
            type Ux = u8;
        }
        impl FSEL12_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL12_A {
                match self.bits {
                    0 => FSEL12_A::INPUT,
                    1 => FSEL12_A::OUTPUT,
                    4 => FSEL12_A::PWM0_0,
                    5 => FSEL12_A::SD4,
                    6 => FSEL12_A::RESERVED2,
                    7 => FSEL12_A::RESERVED3,
                    3 => FSEL12_A::RESERVED4,
                    2 => FSEL12_A::ARM_TMS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL12_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL12_A::OUTPUT
            }
            #[doc = "Pin is connected to PWM0_0"]
            #[inline(always)]
            pub fn is_pwm0_0(&self) -> bool {
                *self == FSEL12_A::PWM0_0
            }
            #[doc = "Pin is connected to SD4"]
            #[inline(always)]
            pub fn is_sd4(&self) -> bool {
                *self == FSEL12_A::SD4
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL12_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL12_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL12_A::RESERVED4
            }
            #[doc = "Pin is connected to ARM_TMS"]
            #[inline(always)]
            pub fn is_arm_tms(&self) -> bool {
                *self == FSEL12_A::ARM_TMS
            }
        }
        #[doc = "Field `FSEL12` writer - Function Select 12"]
        pub type FSEL12_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL12_A>;
        impl<'a, REG, const O: u8> FSEL12_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL12_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL12_A::OUTPUT)
            }
            #[doc = "Pin is connected to PWM0_0"]
            #[inline(always)]
            pub fn pwm0_0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL12_A::PWM0_0)
            }
            #[doc = "Pin is connected to SD4"]
            #[inline(always)]
            pub fn sd4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL12_A::SD4)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL12_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL12_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL12_A::RESERVED4)
            }
            #[doc = "Pin is connected to ARM_TMS"]
            #[inline(always)]
            pub fn arm_tms(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL12_A::ARM_TMS)
            }
        }
        #[doc = "Field `FSEL13` reader - Function Select 13"]
        pub type FSEL13_R = crate::FieldReader<FSEL13_A>;
        #[doc = "Function Select 13"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL13_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PWM0_1"]
            PWM0_1 = 4,
            #[doc = "5: Pin is connected to SD5"]
            SD5 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to ARM_TCK"]
            ARM_TCK = 2,
        }
        impl From<FSEL13_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL13_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL13_A {
            type Ux = u8;
        }
        impl FSEL13_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL13_A {
                match self.bits {
                    0 => FSEL13_A::INPUT,
                    1 => FSEL13_A::OUTPUT,
                    4 => FSEL13_A::PWM0_1,
                    5 => FSEL13_A::SD5,
                    6 => FSEL13_A::RESERVED2,
                    7 => FSEL13_A::RESERVED3,
                    3 => FSEL13_A::RESERVED4,
                    2 => FSEL13_A::ARM_TCK,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL13_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL13_A::OUTPUT
            }
            #[doc = "Pin is connected to PWM0_1"]
            #[inline(always)]
            pub fn is_pwm0_1(&self) -> bool {
                *self == FSEL13_A::PWM0_1
            }
            #[doc = "Pin is connected to SD5"]
            #[inline(always)]
            pub fn is_sd5(&self) -> bool {
                *self == FSEL13_A::SD5
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL13_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL13_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL13_A::RESERVED4
            }
            #[doc = "Pin is connected to ARM_TCK"]
            #[inline(always)]
            pub fn is_arm_tck(&self) -> bool {
                *self == FSEL13_A::ARM_TCK
            }
        }
        #[doc = "Field `FSEL13` writer - Function Select 13"]
        pub type FSEL13_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL13_A>;
        impl<'a, REG, const O: u8> FSEL13_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL13_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL13_A::OUTPUT)
            }
            #[doc = "Pin is connected to PWM0_1"]
            #[inline(always)]
            pub fn pwm0_1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL13_A::PWM0_1)
            }
            #[doc = "Pin is connected to SD5"]
            #[inline(always)]
            pub fn sd5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL13_A::SD5)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL13_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL13_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL13_A::RESERVED4)
            }
            #[doc = "Pin is connected to ARM_TCK"]
            #[inline(always)]
            pub fn arm_tck(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL13_A::ARM_TCK)
            }
        }
        #[doc = "Field `FSEL14` reader - Function Select 14"]
        pub type FSEL14_R = crate::FieldReader<FSEL14_A>;
        #[doc = "Function Select 14"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL14_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to TXD0"]
            TXD0 = 4,
            #[doc = "5: Pin is connected to SD6"]
            SD6 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to TXD1"]
            TXD1 = 2,
        }
        impl From<FSEL14_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL14_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL14_A {
            type Ux = u8;
        }
        impl FSEL14_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL14_A {
                match self.bits {
                    0 => FSEL14_A::INPUT,
                    1 => FSEL14_A::OUTPUT,
                    4 => FSEL14_A::TXD0,
                    5 => FSEL14_A::SD6,
                    6 => FSEL14_A::RESERVED2,
                    7 => FSEL14_A::RESERVED3,
                    3 => FSEL14_A::RESERVED4,
                    2 => FSEL14_A::TXD1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL14_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL14_A::OUTPUT
            }
            #[doc = "Pin is connected to TXD0"]
            #[inline(always)]
            pub fn is_txd0(&self) -> bool {
                *self == FSEL14_A::TXD0
            }
            #[doc = "Pin is connected to SD6"]
            #[inline(always)]
            pub fn is_sd6(&self) -> bool {
                *self == FSEL14_A::SD6
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL14_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL14_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL14_A::RESERVED4
            }
            #[doc = "Pin is connected to TXD1"]
            #[inline(always)]
            pub fn is_txd1(&self) -> bool {
                *self == FSEL14_A::TXD1
            }
        }
        #[doc = "Field `FSEL14` writer - Function Select 14"]
        pub type FSEL14_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL14_A>;
        impl<'a, REG, const O: u8> FSEL14_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL14_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL14_A::OUTPUT)
            }
            #[doc = "Pin is connected to TXD0"]
            #[inline(always)]
            pub fn txd0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL14_A::TXD0)
            }
            #[doc = "Pin is connected to SD6"]
            #[inline(always)]
            pub fn sd6(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL14_A::SD6)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL14_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL14_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL14_A::RESERVED4)
            }
            #[doc = "Pin is connected to TXD1"]
            #[inline(always)]
            pub fn txd1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL14_A::TXD1)
            }
        }
        #[doc = "Field `FSEL15` reader - Function Select 15"]
        pub type FSEL15_R = crate::FieldReader<FSEL15_A>;
        #[doc = "Function Select 15"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL15_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to RXD0"]
            RXD0 = 4,
            #[doc = "5: Pin is connected to SD7"]
            SD7 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to RXD1"]
            RXD1 = 2,
        }
        impl From<FSEL15_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL15_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL15_A {
            type Ux = u8;
        }
        impl FSEL15_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL15_A {
                match self.bits {
                    0 => FSEL15_A::INPUT,
                    1 => FSEL15_A::OUTPUT,
                    4 => FSEL15_A::RXD0,
                    5 => FSEL15_A::SD7,
                    6 => FSEL15_A::RESERVED2,
                    7 => FSEL15_A::RESERVED3,
                    3 => FSEL15_A::RESERVED4,
                    2 => FSEL15_A::RXD1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL15_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL15_A::OUTPUT
            }
            #[doc = "Pin is connected to RXD0"]
            #[inline(always)]
            pub fn is_rxd0(&self) -> bool {
                *self == FSEL15_A::RXD0
            }
            #[doc = "Pin is connected to SD7"]
            #[inline(always)]
            pub fn is_sd7(&self) -> bool {
                *self == FSEL15_A::SD7
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL15_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL15_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL15_A::RESERVED4
            }
            #[doc = "Pin is connected to RXD1"]
            #[inline(always)]
            pub fn is_rxd1(&self) -> bool {
                *self == FSEL15_A::RXD1
            }
        }
        #[doc = "Field `FSEL15` writer - Function Select 15"]
        pub type FSEL15_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL15_A>;
        impl<'a, REG, const O: u8> FSEL15_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL15_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL15_A::OUTPUT)
            }
            #[doc = "Pin is connected to RXD0"]
            #[inline(always)]
            pub fn rxd0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL15_A::RXD0)
            }
            #[doc = "Pin is connected to SD7"]
            #[inline(always)]
            pub fn sd7(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL15_A::SD7)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL15_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL15_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL15_A::RESERVED4)
            }
            #[doc = "Pin is connected to RXD1"]
            #[inline(always)]
            pub fn rxd1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL15_A::RXD1)
            }
        }
        #[doc = "Field `FSEL16` reader - Function Select 16"]
        pub type FSEL16_R = crate::FieldReader<FSEL16_A>;
        #[doc = "Function Select 16"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL16_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SD8"]
            SD8 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to CTS0"]
            CTS0 = 7,
            #[doc = "3: Pin is connected to SPI1_CE2_N"]
            SPI1_CE2_N = 3,
            #[doc = "2: Pin is connected to CTS1"]
            CTS1 = 2,
        }
        impl From<FSEL16_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL16_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL16_A {
            type Ux = u8;
        }
        impl FSEL16_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL16_A {
                match self.bits {
                    0 => FSEL16_A::INPUT,
                    1 => FSEL16_A::OUTPUT,
                    4 => FSEL16_A::RESERVED0,
                    5 => FSEL16_A::SD8,
                    6 => FSEL16_A::RESERVED2,
                    7 => FSEL16_A::CTS0,
                    3 => FSEL16_A::SPI1_CE2_N,
                    2 => FSEL16_A::CTS1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL16_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL16_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL16_A::RESERVED0
            }
            #[doc = "Pin is connected to SD8"]
            #[inline(always)]
            pub fn is_sd8(&self) -> bool {
                *self == FSEL16_A::SD8
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL16_A::RESERVED2
            }
            #[doc = "Pin is connected to CTS0"]
            #[inline(always)]
            pub fn is_cts0(&self) -> bool {
                *self == FSEL16_A::CTS0
            }
            #[doc = "Pin is connected to SPI1_CE2_N"]
            #[inline(always)]
            pub fn is_spi1_ce2_n(&self) -> bool {
                *self == FSEL16_A::SPI1_CE2_N
            }
            #[doc = "Pin is connected to CTS1"]
            #[inline(always)]
            pub fn is_cts1(&self) -> bool {
                *self == FSEL16_A::CTS1
            }
        }
        #[doc = "Field `FSEL16` writer - Function Select 16"]
        pub type FSEL16_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL16_A>;
        impl<'a, REG, const O: u8> FSEL16_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL16_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL16_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL16_A::RESERVED0)
            }
            #[doc = "Pin is connected to SD8"]
            #[inline(always)]
            pub fn sd8(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL16_A::SD8)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL16_A::RESERVED2)
            }
            #[doc = "Pin is connected to CTS0"]
            #[inline(always)]
            pub fn cts0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL16_A::CTS0)
            }
            #[doc = "Pin is connected to SPI1_CE2_N"]
            #[inline(always)]
            pub fn spi1_ce2_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL16_A::SPI1_CE2_N)
            }
            #[doc = "Pin is connected to CTS1"]
            #[inline(always)]
            pub fn cts1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL16_A::CTS1)
            }
        }
        #[doc = "Field `FSEL17` reader - Function Select 17"]
        pub type FSEL17_R = crate::FieldReader<FSEL17_A>;
        #[doc = "Function Select 17"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL17_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SD9"]
            SD9 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to RTS0"]
            RTS0 = 7,
            #[doc = "3: Pin is connected to SPI1_CE1_N"]
            SPI1_CE1_N = 3,
            #[doc = "2: Pin is connected to RTS1"]
            RTS1 = 2,
        }
        impl From<FSEL17_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL17_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL17_A {
            type Ux = u8;
        }
        impl FSEL17_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL17_A {
                match self.bits {
                    0 => FSEL17_A::INPUT,
                    1 => FSEL17_A::OUTPUT,
                    4 => FSEL17_A::RESERVED0,
                    5 => FSEL17_A::SD9,
                    6 => FSEL17_A::RESERVED2,
                    7 => FSEL17_A::RTS0,
                    3 => FSEL17_A::SPI1_CE1_N,
                    2 => FSEL17_A::RTS1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL17_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL17_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL17_A::RESERVED0
            }
            #[doc = "Pin is connected to SD9"]
            #[inline(always)]
            pub fn is_sd9(&self) -> bool {
                *self == FSEL17_A::SD9
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL17_A::RESERVED2
            }
            #[doc = "Pin is connected to RTS0"]
            #[inline(always)]
            pub fn is_rts0(&self) -> bool {
                *self == FSEL17_A::RTS0
            }
            #[doc = "Pin is connected to SPI1_CE1_N"]
            #[inline(always)]
            pub fn is_spi1_ce1_n(&self) -> bool {
                *self == FSEL17_A::SPI1_CE1_N
            }
            #[doc = "Pin is connected to RTS1"]
            #[inline(always)]
            pub fn is_rts1(&self) -> bool {
                *self == FSEL17_A::RTS1
            }
        }
        #[doc = "Field `FSEL17` writer - Function Select 17"]
        pub type FSEL17_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL17_A>;
        impl<'a, REG, const O: u8> FSEL17_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL17_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL17_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL17_A::RESERVED0)
            }
            #[doc = "Pin is connected to SD9"]
            #[inline(always)]
            pub fn sd9(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL17_A::SD9)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL17_A::RESERVED2)
            }
            #[doc = "Pin is connected to RTS0"]
            #[inline(always)]
            pub fn rts0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL17_A::RTS0)
            }
            #[doc = "Pin is connected to SPI1_CE1_N"]
            #[inline(always)]
            pub fn spi1_ce1_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL17_A::SPI1_CE1_N)
            }
            #[doc = "Pin is connected to RTS1"]
            #[inline(always)]
            pub fn rts1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL17_A::RTS1)
            }
        }
        #[doc = "Field `FSEL18` reader - Function Select 18"]
        pub type FSEL18_R = crate::FieldReader<FSEL18_A>;
        #[doc = "Function Select 18"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL18_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PCM_CLK"]
            PCM_CLK = 4,
            #[doc = "5: Pin is connected to SD10"]
            SD10 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Pin is connected to SPI1_CE0_N"]
            SPI1_CE0_N = 3,
            #[doc = "2: Pin is connected to PWM0_0"]
            PWM0_0 = 2,
        }
        impl From<FSEL18_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL18_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL18_A {
            type Ux = u8;
        }
        impl FSEL18_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL18_A {
                match self.bits {
                    0 => FSEL18_A::INPUT,
                    1 => FSEL18_A::OUTPUT,
                    4 => FSEL18_A::PCM_CLK,
                    5 => FSEL18_A::SD10,
                    6 => FSEL18_A::RESERVED2,
                    7 => FSEL18_A::RESERVED3,
                    3 => FSEL18_A::SPI1_CE0_N,
                    2 => FSEL18_A::PWM0_0,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL18_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL18_A::OUTPUT
            }
            #[doc = "Pin is connected to PCM_CLK"]
            #[inline(always)]
            pub fn is_pcm_clk(&self) -> bool {
                *self == FSEL18_A::PCM_CLK
            }
            #[doc = "Pin is connected to SD10"]
            #[inline(always)]
            pub fn is_sd10(&self) -> bool {
                *self == FSEL18_A::SD10
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL18_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL18_A::RESERVED3
            }
            #[doc = "Pin is connected to SPI1_CE0_N"]
            #[inline(always)]
            pub fn is_spi1_ce0_n(&self) -> bool {
                *self == FSEL18_A::SPI1_CE0_N
            }
            #[doc = "Pin is connected to PWM0_0"]
            #[inline(always)]
            pub fn is_pwm0_0(&self) -> bool {
                *self == FSEL18_A::PWM0_0
            }
        }
        #[doc = "Field `FSEL18` writer - Function Select 18"]
        pub type FSEL18_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL18_A>;
        impl<'a, REG, const O: u8> FSEL18_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL18_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL18_A::OUTPUT)
            }
            #[doc = "Pin is connected to PCM_CLK"]
            #[inline(always)]
            pub fn pcm_clk(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL18_A::PCM_CLK)
            }
            #[doc = "Pin is connected to SD10"]
            #[inline(always)]
            pub fn sd10(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL18_A::SD10)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL18_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL18_A::RESERVED3)
            }
            #[doc = "Pin is connected to SPI1_CE0_N"]
            #[inline(always)]
            pub fn spi1_ce0_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL18_A::SPI1_CE0_N)
            }
            #[doc = "Pin is connected to PWM0_0"]
            #[inline(always)]
            pub fn pwm0_0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL18_A::PWM0_0)
            }
        }
        #[doc = "Field `FSEL19` reader - Function Select 19"]
        pub type FSEL19_R = crate::FieldReader<FSEL19_A>;
        #[doc = "Function Select 19"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL19_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PCM_FS"]
            PCM_FS = 4,
            #[doc = "5: Pin is connected to SD11"]
            SD11 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Pin is connected to SPI1_MISO"]
            SPI1_MISO = 3,
            #[doc = "2: Pin is connected to PWM0_1"]
            PWM0_1 = 2,
        }
        impl From<FSEL19_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL19_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL19_A {
            type Ux = u8;
        }
        impl FSEL19_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL19_A {
                match self.bits {
                    0 => FSEL19_A::INPUT,
                    1 => FSEL19_A::OUTPUT,
                    4 => FSEL19_A::PCM_FS,
                    5 => FSEL19_A::SD11,
                    6 => FSEL19_A::RESERVED2,
                    7 => FSEL19_A::RESERVED3,
                    3 => FSEL19_A::SPI1_MISO,
                    2 => FSEL19_A::PWM0_1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL19_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL19_A::OUTPUT
            }
            #[doc = "Pin is connected to PCM_FS"]
            #[inline(always)]
            pub fn is_pcm_fs(&self) -> bool {
                *self == FSEL19_A::PCM_FS
            }
            #[doc = "Pin is connected to SD11"]
            #[inline(always)]
            pub fn is_sd11(&self) -> bool {
                *self == FSEL19_A::SD11
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL19_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL19_A::RESERVED3
            }
            #[doc = "Pin is connected to SPI1_MISO"]
            #[inline(always)]
            pub fn is_spi1_miso(&self) -> bool {
                *self == FSEL19_A::SPI1_MISO
            }
            #[doc = "Pin is connected to PWM0_1"]
            #[inline(always)]
            pub fn is_pwm0_1(&self) -> bool {
                *self == FSEL19_A::PWM0_1
            }
        }
        #[doc = "Field `FSEL19` writer - Function Select 19"]
        pub type FSEL19_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL19_A>;
        impl<'a, REG, const O: u8> FSEL19_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL19_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL19_A::OUTPUT)
            }
            #[doc = "Pin is connected to PCM_FS"]
            #[inline(always)]
            pub fn pcm_fs(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL19_A::PCM_FS)
            }
            #[doc = "Pin is connected to SD11"]
            #[inline(always)]
            pub fn sd11(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL19_A::SD11)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL19_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL19_A::RESERVED3)
            }
            #[doc = "Pin is connected to SPI1_MISO"]
            #[inline(always)]
            pub fn spi1_miso(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL19_A::SPI1_MISO)
            }
            #[doc = "Pin is connected to PWM0_1"]
            #[inline(always)]
            pub fn pwm0_1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL19_A::PWM0_1)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Function Select 10"]
            #[inline(always)]
            pub fn fsel10(&self) -> FSEL10_R {
                FSEL10_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:5 - Function Select 11"]
            #[inline(always)]
            pub fn fsel11(&self) -> FSEL11_R {
                FSEL11_R::new(((self.bits >> 3) & 7) as u8)
            }
            #[doc = "Bits 6:8 - Function Select 12"]
            #[inline(always)]
            pub fn fsel12(&self) -> FSEL12_R {
                FSEL12_R::new(((self.bits >> 6) & 7) as u8)
            }
            #[doc = "Bits 9:11 - Function Select 13"]
            #[inline(always)]
            pub fn fsel13(&self) -> FSEL13_R {
                FSEL13_R::new(((self.bits >> 9) & 7) as u8)
            }
            #[doc = "Bits 12:14 - Function Select 14"]
            #[inline(always)]
            pub fn fsel14(&self) -> FSEL14_R {
                FSEL14_R::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bits 15:17 - Function Select 15"]
            #[inline(always)]
            pub fn fsel15(&self) -> FSEL15_R {
                FSEL15_R::new(((self.bits >> 15) & 7) as u8)
            }
            #[doc = "Bits 18:20 - Function Select 16"]
            #[inline(always)]
            pub fn fsel16(&self) -> FSEL16_R {
                FSEL16_R::new(((self.bits >> 18) & 7) as u8)
            }
            #[doc = "Bits 21:23 - Function Select 17"]
            #[inline(always)]
            pub fn fsel17(&self) -> FSEL17_R {
                FSEL17_R::new(((self.bits >> 21) & 7) as u8)
            }
            #[doc = "Bits 24:26 - Function Select 18"]
            #[inline(always)]
            pub fn fsel18(&self) -> FSEL18_R {
                FSEL18_R::new(((self.bits >> 24) & 7) as u8)
            }
            #[doc = "Bits 27:29 - Function Select 19"]
            #[inline(always)]
            pub fn fsel19(&self) -> FSEL19_R {
                FSEL19_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPFSEL1")
                    .field("fsel10", &format_args!("{}", self.fsel10().bits()))
                    .field("fsel11", &format_args!("{}", self.fsel11().bits()))
                    .field("fsel12", &format_args!("{}", self.fsel12().bits()))
                    .field("fsel13", &format_args!("{}", self.fsel13().bits()))
                    .field("fsel14", &format_args!("{}", self.fsel14().bits()))
                    .field("fsel15", &format_args!("{}", self.fsel15().bits()))
                    .field("fsel16", &format_args!("{}", self.fsel16().bits()))
                    .field("fsel17", &format_args!("{}", self.fsel17().bits()))
                    .field("fsel18", &format_args!("{}", self.fsel18().bits()))
                    .field("fsel19", &format_args!("{}", self.fsel19().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPFSEL1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Function Select 10"]
            #[inline(always)]
            #[must_use]
            pub fn fsel10(&mut self) -> FSEL10_W<GPFSEL1_SPEC, 0> {
                FSEL10_W::new(self)
            }
            #[doc = "Bits 3:5 - Function Select 11"]
            #[inline(always)]
            #[must_use]
            pub fn fsel11(&mut self) -> FSEL11_W<GPFSEL1_SPEC, 3> {
                FSEL11_W::new(self)
            }
            #[doc = "Bits 6:8 - Function Select 12"]
            #[inline(always)]
            #[must_use]
            pub fn fsel12(&mut self) -> FSEL12_W<GPFSEL1_SPEC, 6> {
                FSEL12_W::new(self)
            }
            #[doc = "Bits 9:11 - Function Select 13"]
            #[inline(always)]
            #[must_use]
            pub fn fsel13(&mut self) -> FSEL13_W<GPFSEL1_SPEC, 9> {
                FSEL13_W::new(self)
            }
            #[doc = "Bits 12:14 - Function Select 14"]
            #[inline(always)]
            #[must_use]
            pub fn fsel14(&mut self) -> FSEL14_W<GPFSEL1_SPEC, 12> {
                FSEL14_W::new(self)
            }
            #[doc = "Bits 15:17 - Function Select 15"]
            #[inline(always)]
            #[must_use]
            pub fn fsel15(&mut self) -> FSEL15_W<GPFSEL1_SPEC, 15> {
                FSEL15_W::new(self)
            }
            #[doc = "Bits 18:20 - Function Select 16"]
            #[inline(always)]
            #[must_use]
            pub fn fsel16(&mut self) -> FSEL16_W<GPFSEL1_SPEC, 18> {
                FSEL16_W::new(self)
            }
            #[doc = "Bits 21:23 - Function Select 17"]
            #[inline(always)]
            #[must_use]
            pub fn fsel17(&mut self) -> FSEL17_W<GPFSEL1_SPEC, 21> {
                FSEL17_W::new(self)
            }
            #[doc = "Bits 24:26 - Function Select 18"]
            #[inline(always)]
            #[must_use]
            pub fn fsel18(&mut self) -> FSEL18_W<GPFSEL1_SPEC, 24> {
                FSEL18_W::new(self)
            }
            #[doc = "Bits 27:29 - Function Select 19"]
            #[inline(always)]
            #[must_use]
            pub fn fsel19(&mut self) -> FSEL19_W<GPFSEL1_SPEC, 27> {
                FSEL19_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Function Select 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPFSEL1_SPEC;
        impl crate::RegisterSpec for GPFSEL1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpfsel1::R`](R) reader structure"]
        impl crate::Readable for GPFSEL1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpfsel1::W`](W) writer structure"]
        impl crate::Writable for GPFSEL1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPFSEL2 (rw) register accessor: GPIO Function Select 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel2::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpfsel2`]
module"]
    pub type GPFSEL2 = crate::Reg<gpfsel2::GPFSEL2_SPEC>;
    #[doc = "GPIO Function Select 2"]
    pub mod gpfsel2 {
        #[doc = "Register `GPFSEL2` reader"]
        pub type R = crate::R<GPFSEL2_SPEC>;
        #[doc = "Register `GPFSEL2` writer"]
        pub type W = crate::W<GPFSEL2_SPEC>;
        #[doc = "Field `FSEL20` reader - Function Select 20"]
        pub type FSEL20_R = crate::FieldReader<FSEL20_A>;
        #[doc = "Function Select 20"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL20_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PCM_DIN"]
            PCM_DIN = 4,
            #[doc = "5: Pin is connected to SD12"]
            SD12 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Pin is connected to SPI1_MOSI"]
            SPI1_MOSI = 3,
            #[doc = "2: Pin is connected to GPCLK0"]
            GPCLK0 = 2,
        }
        impl From<FSEL20_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL20_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL20_A {
            type Ux = u8;
        }
        impl FSEL20_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL20_A {
                match self.bits {
                    0 => FSEL20_A::INPUT,
                    1 => FSEL20_A::OUTPUT,
                    4 => FSEL20_A::PCM_DIN,
                    5 => FSEL20_A::SD12,
                    6 => FSEL20_A::RESERVED2,
                    7 => FSEL20_A::RESERVED3,
                    3 => FSEL20_A::SPI1_MOSI,
                    2 => FSEL20_A::GPCLK0,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL20_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL20_A::OUTPUT
            }
            #[doc = "Pin is connected to PCM_DIN"]
            #[inline(always)]
            pub fn is_pcm_din(&self) -> bool {
                *self == FSEL20_A::PCM_DIN
            }
            #[doc = "Pin is connected to SD12"]
            #[inline(always)]
            pub fn is_sd12(&self) -> bool {
                *self == FSEL20_A::SD12
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL20_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL20_A::RESERVED3
            }
            #[doc = "Pin is connected to SPI1_MOSI"]
            #[inline(always)]
            pub fn is_spi1_mosi(&self) -> bool {
                *self == FSEL20_A::SPI1_MOSI
            }
            #[doc = "Pin is connected to GPCLK0"]
            #[inline(always)]
            pub fn is_gpclk0(&self) -> bool {
                *self == FSEL20_A::GPCLK0
            }
        }
        #[doc = "Field `FSEL20` writer - Function Select 20"]
        pub type FSEL20_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL20_A>;
        impl<'a, REG, const O: u8> FSEL20_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL20_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL20_A::OUTPUT)
            }
            #[doc = "Pin is connected to PCM_DIN"]
            #[inline(always)]
            pub fn pcm_din(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL20_A::PCM_DIN)
            }
            #[doc = "Pin is connected to SD12"]
            #[inline(always)]
            pub fn sd12(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL20_A::SD12)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL20_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL20_A::RESERVED3)
            }
            #[doc = "Pin is connected to SPI1_MOSI"]
            #[inline(always)]
            pub fn spi1_mosi(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL20_A::SPI1_MOSI)
            }
            #[doc = "Pin is connected to GPCLK0"]
            #[inline(always)]
            pub fn gpclk0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL20_A::GPCLK0)
            }
        }
        #[doc = "Field `FSEL21` reader - Function Select 21"]
        pub type FSEL21_R = crate::FieldReader<FSEL21_A>;
        #[doc = "Function Select 21"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL21_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PCM_DOUT"]
            PCM_DOUT = 4,
            #[doc = "5: Pin is connected to SD13"]
            SD13 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Pin is connected to SPI1_SCLK"]
            SPI1_SCLK = 3,
            #[doc = "2: Pin is connected to GPCLK1"]
            GPCLK1 = 2,
        }
        impl From<FSEL21_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL21_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL21_A {
            type Ux = u8;
        }
        impl FSEL21_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL21_A {
                match self.bits {
                    0 => FSEL21_A::INPUT,
                    1 => FSEL21_A::OUTPUT,
                    4 => FSEL21_A::PCM_DOUT,
                    5 => FSEL21_A::SD13,
                    6 => FSEL21_A::RESERVED2,
                    7 => FSEL21_A::RESERVED3,
                    3 => FSEL21_A::SPI1_SCLK,
                    2 => FSEL21_A::GPCLK1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL21_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL21_A::OUTPUT
            }
            #[doc = "Pin is connected to PCM_DOUT"]
            #[inline(always)]
            pub fn is_pcm_dout(&self) -> bool {
                *self == FSEL21_A::PCM_DOUT
            }
            #[doc = "Pin is connected to SD13"]
            #[inline(always)]
            pub fn is_sd13(&self) -> bool {
                *self == FSEL21_A::SD13
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL21_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL21_A::RESERVED3
            }
            #[doc = "Pin is connected to SPI1_SCLK"]
            #[inline(always)]
            pub fn is_spi1_sclk(&self) -> bool {
                *self == FSEL21_A::SPI1_SCLK
            }
            #[doc = "Pin is connected to GPCLK1"]
            #[inline(always)]
            pub fn is_gpclk1(&self) -> bool {
                *self == FSEL21_A::GPCLK1
            }
        }
        #[doc = "Field `FSEL21` writer - Function Select 21"]
        pub type FSEL21_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL21_A>;
        impl<'a, REG, const O: u8> FSEL21_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL21_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL21_A::OUTPUT)
            }
            #[doc = "Pin is connected to PCM_DOUT"]
            #[inline(always)]
            pub fn pcm_dout(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL21_A::PCM_DOUT)
            }
            #[doc = "Pin is connected to SD13"]
            #[inline(always)]
            pub fn sd13(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL21_A::SD13)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL21_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL21_A::RESERVED3)
            }
            #[doc = "Pin is connected to SPI1_SCLK"]
            #[inline(always)]
            pub fn spi1_sclk(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL21_A::SPI1_SCLK)
            }
            #[doc = "Pin is connected to GPCLK1"]
            #[inline(always)]
            pub fn gpclk1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL21_A::GPCLK1)
            }
        }
        #[doc = "Field `FSEL22` reader - Function Select 22"]
        pub type FSEL22_R = crate::FieldReader<FSEL22_A>;
        #[doc = "Function Select 22"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL22_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SD14"]
            SD14 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_CLK"]
            SD1_CLK = 7,
            #[doc = "3: Pin is connected to ARM_TRST"]
            ARM_TRST = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL22_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL22_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL22_A {
            type Ux = u8;
        }
        impl FSEL22_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL22_A {
                match self.bits {
                    0 => FSEL22_A::INPUT,
                    1 => FSEL22_A::OUTPUT,
                    4 => FSEL22_A::RESERVED0,
                    5 => FSEL22_A::SD14,
                    6 => FSEL22_A::RESERVED2,
                    7 => FSEL22_A::SD1_CLK,
                    3 => FSEL22_A::ARM_TRST,
                    2 => FSEL22_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL22_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL22_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL22_A::RESERVED0
            }
            #[doc = "Pin is connected to SD14"]
            #[inline(always)]
            pub fn is_sd14(&self) -> bool {
                *self == FSEL22_A::SD14
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL22_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_CLK"]
            #[inline(always)]
            pub fn is_sd1_clk(&self) -> bool {
                *self == FSEL22_A::SD1_CLK
            }
            #[doc = "Pin is connected to ARM_TRST"]
            #[inline(always)]
            pub fn is_arm_trst(&self) -> bool {
                *self == FSEL22_A::ARM_TRST
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL22_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL22` writer - Function Select 22"]
        pub type FSEL22_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL22_A>;
        impl<'a, REG, const O: u8> FSEL22_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL22_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL22_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL22_A::RESERVED0)
            }
            #[doc = "Pin is connected to SD14"]
            #[inline(always)]
            pub fn sd14(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL22_A::SD14)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL22_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_CLK"]
            #[inline(always)]
            pub fn sd1_clk(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL22_A::SD1_CLK)
            }
            #[doc = "Pin is connected to ARM_TRST"]
            #[inline(always)]
            pub fn arm_trst(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL22_A::ARM_TRST)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL22_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL23` reader - Function Select 23"]
        pub type FSEL23_R = crate::FieldReader<FSEL23_A>;
        #[doc = "Function Select 23"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL23_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SD15"]
            SD15 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_CMD"]
            SD1_CMD = 7,
            #[doc = "3: Pin is connected to ARM_RTCK"]
            ARM_RTCK = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL23_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL23_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL23_A {
            type Ux = u8;
        }
        impl FSEL23_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL23_A {
                match self.bits {
                    0 => FSEL23_A::INPUT,
                    1 => FSEL23_A::OUTPUT,
                    4 => FSEL23_A::RESERVED0,
                    5 => FSEL23_A::SD15,
                    6 => FSEL23_A::RESERVED2,
                    7 => FSEL23_A::SD1_CMD,
                    3 => FSEL23_A::ARM_RTCK,
                    2 => FSEL23_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL23_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL23_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL23_A::RESERVED0
            }
            #[doc = "Pin is connected to SD15"]
            #[inline(always)]
            pub fn is_sd15(&self) -> bool {
                *self == FSEL23_A::SD15
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL23_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_CMD"]
            #[inline(always)]
            pub fn is_sd1_cmd(&self) -> bool {
                *self == FSEL23_A::SD1_CMD
            }
            #[doc = "Pin is connected to ARM_RTCK"]
            #[inline(always)]
            pub fn is_arm_rtck(&self) -> bool {
                *self == FSEL23_A::ARM_RTCK
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL23_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL23` writer - Function Select 23"]
        pub type FSEL23_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL23_A>;
        impl<'a, REG, const O: u8> FSEL23_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL23_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL23_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL23_A::RESERVED0)
            }
            #[doc = "Pin is connected to SD15"]
            #[inline(always)]
            pub fn sd15(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL23_A::SD15)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL23_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_CMD"]
            #[inline(always)]
            pub fn sd1_cmd(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL23_A::SD1_CMD)
            }
            #[doc = "Pin is connected to ARM_RTCK"]
            #[inline(always)]
            pub fn arm_rtck(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL23_A::ARM_RTCK)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL23_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL24` reader - Function Select 24"]
        pub type FSEL24_R = crate::FieldReader<FSEL24_A>;
        #[doc = "Function Select 24"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL24_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SD16"]
            SD16 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_DAT0"]
            SD1_DAT0 = 7,
            #[doc = "3: Pin is connected to ARM_TDO"]
            ARM_TDO = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL24_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL24_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL24_A {
            type Ux = u8;
        }
        impl FSEL24_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL24_A {
                match self.bits {
                    0 => FSEL24_A::INPUT,
                    1 => FSEL24_A::OUTPUT,
                    4 => FSEL24_A::RESERVED0,
                    5 => FSEL24_A::SD16,
                    6 => FSEL24_A::RESERVED2,
                    7 => FSEL24_A::SD1_DAT0,
                    3 => FSEL24_A::ARM_TDO,
                    2 => FSEL24_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL24_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL24_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL24_A::RESERVED0
            }
            #[doc = "Pin is connected to SD16"]
            #[inline(always)]
            pub fn is_sd16(&self) -> bool {
                *self == FSEL24_A::SD16
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL24_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_DAT0"]
            #[inline(always)]
            pub fn is_sd1_dat0(&self) -> bool {
                *self == FSEL24_A::SD1_DAT0
            }
            #[doc = "Pin is connected to ARM_TDO"]
            #[inline(always)]
            pub fn is_arm_tdo(&self) -> bool {
                *self == FSEL24_A::ARM_TDO
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL24_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL24` writer - Function Select 24"]
        pub type FSEL24_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL24_A>;
        impl<'a, REG, const O: u8> FSEL24_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL24_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL24_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL24_A::RESERVED0)
            }
            #[doc = "Pin is connected to SD16"]
            #[inline(always)]
            pub fn sd16(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL24_A::SD16)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL24_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_DAT0"]
            #[inline(always)]
            pub fn sd1_dat0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL24_A::SD1_DAT0)
            }
            #[doc = "Pin is connected to ARM_TDO"]
            #[inline(always)]
            pub fn arm_tdo(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL24_A::ARM_TDO)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL24_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL25` reader - Function Select 25"]
        pub type FSEL25_R = crate::FieldReader<FSEL25_A>;
        #[doc = "Function Select 25"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL25_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SD17"]
            SD17 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_DAT1"]
            SD1_DAT1 = 7,
            #[doc = "3: Pin is connected to ARM_TCK"]
            ARM_TCK = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL25_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL25_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL25_A {
            type Ux = u8;
        }
        impl FSEL25_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL25_A {
                match self.bits {
                    0 => FSEL25_A::INPUT,
                    1 => FSEL25_A::OUTPUT,
                    4 => FSEL25_A::RESERVED0,
                    5 => FSEL25_A::SD17,
                    6 => FSEL25_A::RESERVED2,
                    7 => FSEL25_A::SD1_DAT1,
                    3 => FSEL25_A::ARM_TCK,
                    2 => FSEL25_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL25_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL25_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL25_A::RESERVED0
            }
            #[doc = "Pin is connected to SD17"]
            #[inline(always)]
            pub fn is_sd17(&self) -> bool {
                *self == FSEL25_A::SD17
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL25_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_DAT1"]
            #[inline(always)]
            pub fn is_sd1_dat1(&self) -> bool {
                *self == FSEL25_A::SD1_DAT1
            }
            #[doc = "Pin is connected to ARM_TCK"]
            #[inline(always)]
            pub fn is_arm_tck(&self) -> bool {
                *self == FSEL25_A::ARM_TCK
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL25_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL25` writer - Function Select 25"]
        pub type FSEL25_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL25_A>;
        impl<'a, REG, const O: u8> FSEL25_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL25_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL25_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL25_A::RESERVED0)
            }
            #[doc = "Pin is connected to SD17"]
            #[inline(always)]
            pub fn sd17(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL25_A::SD17)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL25_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_DAT1"]
            #[inline(always)]
            pub fn sd1_dat1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL25_A::SD1_DAT1)
            }
            #[doc = "Pin is connected to ARM_TCK"]
            #[inline(always)]
            pub fn arm_tck(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL25_A::ARM_TCK)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL25_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL26` reader - Function Select 26"]
        pub type FSEL26_R = crate::FieldReader<FSEL26_A>;
        #[doc = "Function Select 26"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL26_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_DAT2"]
            SD1_DAT2 = 7,
            #[doc = "3: Pin is connected to ARM_TDI"]
            ARM_TDI = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL26_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL26_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL26_A {
            type Ux = u8;
        }
        impl FSEL26_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL26_A {
                match self.bits {
                    0 => FSEL26_A::INPUT,
                    1 => FSEL26_A::OUTPUT,
                    4 => FSEL26_A::RESERVED0,
                    5 => FSEL26_A::RESERVED1,
                    6 => FSEL26_A::RESERVED2,
                    7 => FSEL26_A::SD1_DAT2,
                    3 => FSEL26_A::ARM_TDI,
                    2 => FSEL26_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL26_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL26_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL26_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL26_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL26_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_DAT2"]
            #[inline(always)]
            pub fn is_sd1_dat2(&self) -> bool {
                *self == FSEL26_A::SD1_DAT2
            }
            #[doc = "Pin is connected to ARM_TDI"]
            #[inline(always)]
            pub fn is_arm_tdi(&self) -> bool {
                *self == FSEL26_A::ARM_TDI
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL26_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL26` writer - Function Select 26"]
        pub type FSEL26_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL26_A>;
        impl<'a, REG, const O: u8> FSEL26_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL26_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL26_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL26_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL26_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL26_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_DAT2"]
            #[inline(always)]
            pub fn sd1_dat2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL26_A::SD1_DAT2)
            }
            #[doc = "Pin is connected to ARM_TDI"]
            #[inline(always)]
            pub fn arm_tdi(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL26_A::ARM_TDI)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL26_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL27` reader - Function Select 27"]
        pub type FSEL27_R = crate::FieldReader<FSEL27_A>;
        #[doc = "Function Select 27"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL27_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_DAT3"]
            SD1_DAT3 = 7,
            #[doc = "3: Pin is connected to ARM_TMS"]
            ARM_TMS = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL27_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL27_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL27_A {
            type Ux = u8;
        }
        impl FSEL27_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL27_A {
                match self.bits {
                    0 => FSEL27_A::INPUT,
                    1 => FSEL27_A::OUTPUT,
                    4 => FSEL27_A::RESERVED0,
                    5 => FSEL27_A::RESERVED1,
                    6 => FSEL27_A::RESERVED2,
                    7 => FSEL27_A::SD1_DAT3,
                    3 => FSEL27_A::ARM_TMS,
                    2 => FSEL27_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL27_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL27_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL27_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL27_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL27_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_DAT3"]
            #[inline(always)]
            pub fn is_sd1_dat3(&self) -> bool {
                *self == FSEL27_A::SD1_DAT3
            }
            #[doc = "Pin is connected to ARM_TMS"]
            #[inline(always)]
            pub fn is_arm_tms(&self) -> bool {
                *self == FSEL27_A::ARM_TMS
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL27_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL27` writer - Function Select 27"]
        pub type FSEL27_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL27_A>;
        impl<'a, REG, const O: u8> FSEL27_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL27_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL27_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL27_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL27_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL27_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_DAT3"]
            #[inline(always)]
            pub fn sd1_dat3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL27_A::SD1_DAT3)
            }
            #[doc = "Pin is connected to ARM_TMS"]
            #[inline(always)]
            pub fn arm_tms(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL27_A::ARM_TMS)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL27_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL28` reader - Function Select 28"]
        pub type FSEL28_R = crate::FieldReader<FSEL28_A>;
        #[doc = "Function Select 28"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL28_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SDA0"]
            SDA0 = 4,
            #[doc = "5: Pin is connected to SA5"]
            SA5 = 5,
            #[doc = "6: Pin is connected to PCM_CLK"]
            PCM_CLK = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL28_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL28_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL28_A {
            type Ux = u8;
        }
        impl FSEL28_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL28_A {
                match self.bits {
                    0 => FSEL28_A::INPUT,
                    1 => FSEL28_A::OUTPUT,
                    4 => FSEL28_A::SDA0,
                    5 => FSEL28_A::SA5,
                    6 => FSEL28_A::PCM_CLK,
                    7 => FSEL28_A::RESERVED3,
                    3 => FSEL28_A::RESERVED4,
                    2 => FSEL28_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL28_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL28_A::OUTPUT
            }
            #[doc = "Pin is connected to SDA0"]
            #[inline(always)]
            pub fn is_sda0(&self) -> bool {
                *self == FSEL28_A::SDA0
            }
            #[doc = "Pin is connected to SA5"]
            #[inline(always)]
            pub fn is_sa5(&self) -> bool {
                *self == FSEL28_A::SA5
            }
            #[doc = "Pin is connected to PCM_CLK"]
            #[inline(always)]
            pub fn is_pcm_clk(&self) -> bool {
                *self == FSEL28_A::PCM_CLK
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL28_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL28_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL28_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL28` writer - Function Select 28"]
        pub type FSEL28_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL28_A>;
        impl<'a, REG, const O: u8> FSEL28_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL28_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL28_A::OUTPUT)
            }
            #[doc = "Pin is connected to SDA0"]
            #[inline(always)]
            pub fn sda0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL28_A::SDA0)
            }
            #[doc = "Pin is connected to SA5"]
            #[inline(always)]
            pub fn sa5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL28_A::SA5)
            }
            #[doc = "Pin is connected to PCM_CLK"]
            #[inline(always)]
            pub fn pcm_clk(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL28_A::PCM_CLK)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL28_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL28_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL28_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL29` reader - Function Select 29"]
        pub type FSEL29_R = crate::FieldReader<FSEL29_A>;
        #[doc = "Function Select 29"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL29_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SCL0"]
            SCL0 = 4,
            #[doc = "5: Pin is connected to SA4"]
            SA4 = 5,
            #[doc = "6: Pin is connected to PCM_FS"]
            PCM_FS = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL29_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL29_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL29_A {
            type Ux = u8;
        }
        impl FSEL29_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL29_A {
                match self.bits {
                    0 => FSEL29_A::INPUT,
                    1 => FSEL29_A::OUTPUT,
                    4 => FSEL29_A::SCL0,
                    5 => FSEL29_A::SA4,
                    6 => FSEL29_A::PCM_FS,
                    7 => FSEL29_A::RESERVED3,
                    3 => FSEL29_A::RESERVED4,
                    2 => FSEL29_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL29_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL29_A::OUTPUT
            }
            #[doc = "Pin is connected to SCL0"]
            #[inline(always)]
            pub fn is_scl0(&self) -> bool {
                *self == FSEL29_A::SCL0
            }
            #[doc = "Pin is connected to SA4"]
            #[inline(always)]
            pub fn is_sa4(&self) -> bool {
                *self == FSEL29_A::SA4
            }
            #[doc = "Pin is connected to PCM_FS"]
            #[inline(always)]
            pub fn is_pcm_fs(&self) -> bool {
                *self == FSEL29_A::PCM_FS
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL29_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL29_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL29_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL29` writer - Function Select 29"]
        pub type FSEL29_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL29_A>;
        impl<'a, REG, const O: u8> FSEL29_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL29_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL29_A::OUTPUT)
            }
            #[doc = "Pin is connected to SCL0"]
            #[inline(always)]
            pub fn scl0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL29_A::SCL0)
            }
            #[doc = "Pin is connected to SA4"]
            #[inline(always)]
            pub fn sa4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL29_A::SA4)
            }
            #[doc = "Pin is connected to PCM_FS"]
            #[inline(always)]
            pub fn pcm_fs(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL29_A::PCM_FS)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL29_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL29_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL29_A::RESERVED5)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Function Select 20"]
            #[inline(always)]
            pub fn fsel20(&self) -> FSEL20_R {
                FSEL20_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:5 - Function Select 21"]
            #[inline(always)]
            pub fn fsel21(&self) -> FSEL21_R {
                FSEL21_R::new(((self.bits >> 3) & 7) as u8)
            }
            #[doc = "Bits 6:8 - Function Select 22"]
            #[inline(always)]
            pub fn fsel22(&self) -> FSEL22_R {
                FSEL22_R::new(((self.bits >> 6) & 7) as u8)
            }
            #[doc = "Bits 9:11 - Function Select 23"]
            #[inline(always)]
            pub fn fsel23(&self) -> FSEL23_R {
                FSEL23_R::new(((self.bits >> 9) & 7) as u8)
            }
            #[doc = "Bits 12:14 - Function Select 24"]
            #[inline(always)]
            pub fn fsel24(&self) -> FSEL24_R {
                FSEL24_R::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bits 15:17 - Function Select 25"]
            #[inline(always)]
            pub fn fsel25(&self) -> FSEL25_R {
                FSEL25_R::new(((self.bits >> 15) & 7) as u8)
            }
            #[doc = "Bits 18:20 - Function Select 26"]
            #[inline(always)]
            pub fn fsel26(&self) -> FSEL26_R {
                FSEL26_R::new(((self.bits >> 18) & 7) as u8)
            }
            #[doc = "Bits 21:23 - Function Select 27"]
            #[inline(always)]
            pub fn fsel27(&self) -> FSEL27_R {
                FSEL27_R::new(((self.bits >> 21) & 7) as u8)
            }
            #[doc = "Bits 24:26 - Function Select 28"]
            #[inline(always)]
            pub fn fsel28(&self) -> FSEL28_R {
                FSEL28_R::new(((self.bits >> 24) & 7) as u8)
            }
            #[doc = "Bits 27:29 - Function Select 29"]
            #[inline(always)]
            pub fn fsel29(&self) -> FSEL29_R {
                FSEL29_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPFSEL2")
                    .field("fsel20", &format_args!("{}", self.fsel20().bits()))
                    .field("fsel21", &format_args!("{}", self.fsel21().bits()))
                    .field("fsel22", &format_args!("{}", self.fsel22().bits()))
                    .field("fsel23", &format_args!("{}", self.fsel23().bits()))
                    .field("fsel24", &format_args!("{}", self.fsel24().bits()))
                    .field("fsel25", &format_args!("{}", self.fsel25().bits()))
                    .field("fsel26", &format_args!("{}", self.fsel26().bits()))
                    .field("fsel27", &format_args!("{}", self.fsel27().bits()))
                    .field("fsel28", &format_args!("{}", self.fsel28().bits()))
                    .field("fsel29", &format_args!("{}", self.fsel29().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPFSEL2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Function Select 20"]
            #[inline(always)]
            #[must_use]
            pub fn fsel20(&mut self) -> FSEL20_W<GPFSEL2_SPEC, 0> {
                FSEL20_W::new(self)
            }
            #[doc = "Bits 3:5 - Function Select 21"]
            #[inline(always)]
            #[must_use]
            pub fn fsel21(&mut self) -> FSEL21_W<GPFSEL2_SPEC, 3> {
                FSEL21_W::new(self)
            }
            #[doc = "Bits 6:8 - Function Select 22"]
            #[inline(always)]
            #[must_use]
            pub fn fsel22(&mut self) -> FSEL22_W<GPFSEL2_SPEC, 6> {
                FSEL22_W::new(self)
            }
            #[doc = "Bits 9:11 - Function Select 23"]
            #[inline(always)]
            #[must_use]
            pub fn fsel23(&mut self) -> FSEL23_W<GPFSEL2_SPEC, 9> {
                FSEL23_W::new(self)
            }
            #[doc = "Bits 12:14 - Function Select 24"]
            #[inline(always)]
            #[must_use]
            pub fn fsel24(&mut self) -> FSEL24_W<GPFSEL2_SPEC, 12> {
                FSEL24_W::new(self)
            }
            #[doc = "Bits 15:17 - Function Select 25"]
            #[inline(always)]
            #[must_use]
            pub fn fsel25(&mut self) -> FSEL25_W<GPFSEL2_SPEC, 15> {
                FSEL25_W::new(self)
            }
            #[doc = "Bits 18:20 - Function Select 26"]
            #[inline(always)]
            #[must_use]
            pub fn fsel26(&mut self) -> FSEL26_W<GPFSEL2_SPEC, 18> {
                FSEL26_W::new(self)
            }
            #[doc = "Bits 21:23 - Function Select 27"]
            #[inline(always)]
            #[must_use]
            pub fn fsel27(&mut self) -> FSEL27_W<GPFSEL2_SPEC, 21> {
                FSEL27_W::new(self)
            }
            #[doc = "Bits 24:26 - Function Select 28"]
            #[inline(always)]
            #[must_use]
            pub fn fsel28(&mut self) -> FSEL28_W<GPFSEL2_SPEC, 24> {
                FSEL28_W::new(self)
            }
            #[doc = "Bits 27:29 - Function Select 29"]
            #[inline(always)]
            #[must_use]
            pub fn fsel29(&mut self) -> FSEL29_W<GPFSEL2_SPEC, 27> {
                FSEL29_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Function Select 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel2::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPFSEL2_SPEC;
        impl crate::RegisterSpec for GPFSEL2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpfsel2::R`](R) reader structure"]
        impl crate::Readable for GPFSEL2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpfsel2::W`](W) writer structure"]
        impl crate::Writable for GPFSEL2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPFSEL3 (rw) register accessor: GPIO Function Select 3\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel3::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpfsel3`]
module"]
    pub type GPFSEL3 = crate::Reg<gpfsel3::GPFSEL3_SPEC>;
    #[doc = "GPIO Function Select 3"]
    pub mod gpfsel3 {
        #[doc = "Register `GPFSEL3` reader"]
        pub type R = crate::R<GPFSEL3_SPEC>;
        #[doc = "Register `GPFSEL3` writer"]
        pub type W = crate::W<GPFSEL3_SPEC>;
        #[doc = "Field `FSEL30` reader - Function Select 30"]
        pub type FSEL30_R = crate::FieldReader<FSEL30_A>;
        #[doc = "Function Select 30"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL30_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SA3"]
            SA3 = 5,
            #[doc = "6: Pin is connected to PCM_DIN"]
            PCM_DIN = 6,
            #[doc = "7: Pin is connected to CTS0"]
            CTS0 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to CTS1"]
            CTS1 = 2,
        }
        impl From<FSEL30_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL30_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL30_A {
            type Ux = u8;
        }
        impl FSEL30_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL30_A {
                match self.bits {
                    0 => FSEL30_A::INPUT,
                    1 => FSEL30_A::OUTPUT,
                    4 => FSEL30_A::RESERVED0,
                    5 => FSEL30_A::SA3,
                    6 => FSEL30_A::PCM_DIN,
                    7 => FSEL30_A::CTS0,
                    3 => FSEL30_A::RESERVED4,
                    2 => FSEL30_A::CTS1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL30_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL30_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL30_A::RESERVED0
            }
            #[doc = "Pin is connected to SA3"]
            #[inline(always)]
            pub fn is_sa3(&self) -> bool {
                *self == FSEL30_A::SA3
            }
            #[doc = "Pin is connected to PCM_DIN"]
            #[inline(always)]
            pub fn is_pcm_din(&self) -> bool {
                *self == FSEL30_A::PCM_DIN
            }
            #[doc = "Pin is connected to CTS0"]
            #[inline(always)]
            pub fn is_cts0(&self) -> bool {
                *self == FSEL30_A::CTS0
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL30_A::RESERVED4
            }
            #[doc = "Pin is connected to CTS1"]
            #[inline(always)]
            pub fn is_cts1(&self) -> bool {
                *self == FSEL30_A::CTS1
            }
        }
        #[doc = "Field `FSEL30` writer - Function Select 30"]
        pub type FSEL30_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL30_A>;
        impl<'a, REG, const O: u8> FSEL30_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL30_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL30_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL30_A::RESERVED0)
            }
            #[doc = "Pin is connected to SA3"]
            #[inline(always)]
            pub fn sa3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL30_A::SA3)
            }
            #[doc = "Pin is connected to PCM_DIN"]
            #[inline(always)]
            pub fn pcm_din(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL30_A::PCM_DIN)
            }
            #[doc = "Pin is connected to CTS0"]
            #[inline(always)]
            pub fn cts0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL30_A::CTS0)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL30_A::RESERVED4)
            }
            #[doc = "Pin is connected to CTS1"]
            #[inline(always)]
            pub fn cts1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL30_A::CTS1)
            }
        }
        #[doc = "Field `FSEL31` reader - Function Select 31"]
        pub type FSEL31_R = crate::FieldReader<FSEL31_A>;
        #[doc = "Function Select 31"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL31_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SA2"]
            SA2 = 5,
            #[doc = "6: Pin is connected to PCM_DOUT"]
            PCM_DOUT = 6,
            #[doc = "7: Pin is connected to RTS0"]
            RTS0 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to RTS1"]
            RTS1 = 2,
        }
        impl From<FSEL31_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL31_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL31_A {
            type Ux = u8;
        }
        impl FSEL31_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL31_A {
                match self.bits {
                    0 => FSEL31_A::INPUT,
                    1 => FSEL31_A::OUTPUT,
                    4 => FSEL31_A::RESERVED0,
                    5 => FSEL31_A::SA2,
                    6 => FSEL31_A::PCM_DOUT,
                    7 => FSEL31_A::RTS0,
                    3 => FSEL31_A::RESERVED4,
                    2 => FSEL31_A::RTS1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL31_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL31_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL31_A::RESERVED0
            }
            #[doc = "Pin is connected to SA2"]
            #[inline(always)]
            pub fn is_sa2(&self) -> bool {
                *self == FSEL31_A::SA2
            }
            #[doc = "Pin is connected to PCM_DOUT"]
            #[inline(always)]
            pub fn is_pcm_dout(&self) -> bool {
                *self == FSEL31_A::PCM_DOUT
            }
            #[doc = "Pin is connected to RTS0"]
            #[inline(always)]
            pub fn is_rts0(&self) -> bool {
                *self == FSEL31_A::RTS0
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL31_A::RESERVED4
            }
            #[doc = "Pin is connected to RTS1"]
            #[inline(always)]
            pub fn is_rts1(&self) -> bool {
                *self == FSEL31_A::RTS1
            }
        }
        #[doc = "Field `FSEL31` writer - Function Select 31"]
        pub type FSEL31_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL31_A>;
        impl<'a, REG, const O: u8> FSEL31_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL31_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL31_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL31_A::RESERVED0)
            }
            #[doc = "Pin is connected to SA2"]
            #[inline(always)]
            pub fn sa2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL31_A::SA2)
            }
            #[doc = "Pin is connected to PCM_DOUT"]
            #[inline(always)]
            pub fn pcm_dout(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL31_A::PCM_DOUT)
            }
            #[doc = "Pin is connected to RTS0"]
            #[inline(always)]
            pub fn rts0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL31_A::RTS0)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL31_A::RESERVED4)
            }
            #[doc = "Pin is connected to RTS1"]
            #[inline(always)]
            pub fn rts1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL31_A::RTS1)
            }
        }
        #[doc = "Field `FSEL32` reader - Function Select 32"]
        pub type FSEL32_R = crate::FieldReader<FSEL32_A>;
        #[doc = "Function Select 32"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL32_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to GPCLK0"]
            GPCLK0 = 4,
            #[doc = "5: Pin is connected to SA1"]
            SA1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to TXD0"]
            TXD0 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to TXD1"]
            TXD1 = 2,
        }
        impl From<FSEL32_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL32_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL32_A {
            type Ux = u8;
        }
        impl FSEL32_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL32_A {
                match self.bits {
                    0 => FSEL32_A::INPUT,
                    1 => FSEL32_A::OUTPUT,
                    4 => FSEL32_A::GPCLK0,
                    5 => FSEL32_A::SA1,
                    6 => FSEL32_A::RESERVED2,
                    7 => FSEL32_A::TXD0,
                    3 => FSEL32_A::RESERVED4,
                    2 => FSEL32_A::TXD1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL32_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL32_A::OUTPUT
            }
            #[doc = "Pin is connected to GPCLK0"]
            #[inline(always)]
            pub fn is_gpclk0(&self) -> bool {
                *self == FSEL32_A::GPCLK0
            }
            #[doc = "Pin is connected to SA1"]
            #[inline(always)]
            pub fn is_sa1(&self) -> bool {
                *self == FSEL32_A::SA1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL32_A::RESERVED2
            }
            #[doc = "Pin is connected to TXD0"]
            #[inline(always)]
            pub fn is_txd0(&self) -> bool {
                *self == FSEL32_A::TXD0
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL32_A::RESERVED4
            }
            #[doc = "Pin is connected to TXD1"]
            #[inline(always)]
            pub fn is_txd1(&self) -> bool {
                *self == FSEL32_A::TXD1
            }
        }
        #[doc = "Field `FSEL32` writer - Function Select 32"]
        pub type FSEL32_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL32_A>;
        impl<'a, REG, const O: u8> FSEL32_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL32_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL32_A::OUTPUT)
            }
            #[doc = "Pin is connected to GPCLK0"]
            #[inline(always)]
            pub fn gpclk0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL32_A::GPCLK0)
            }
            #[doc = "Pin is connected to SA1"]
            #[inline(always)]
            pub fn sa1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL32_A::SA1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL32_A::RESERVED2)
            }
            #[doc = "Pin is connected to TXD0"]
            #[inline(always)]
            pub fn txd0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL32_A::TXD0)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL32_A::RESERVED4)
            }
            #[doc = "Pin is connected to TXD1"]
            #[inline(always)]
            pub fn txd1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL32_A::TXD1)
            }
        }
        #[doc = "Field `FSEL33` reader - Function Select 33"]
        pub type FSEL33_R = crate::FieldReader<FSEL33_A>;
        #[doc = "Function Select 33"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL33_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Pin is connected to SA0"]
            SA0 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to RXD0"]
            RXD0 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to RXD1"]
            RXD1 = 2,
        }
        impl From<FSEL33_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL33_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL33_A {
            type Ux = u8;
        }
        impl FSEL33_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL33_A {
                match self.bits {
                    0 => FSEL33_A::INPUT,
                    1 => FSEL33_A::OUTPUT,
                    4 => FSEL33_A::RESERVED0,
                    5 => FSEL33_A::SA0,
                    6 => FSEL33_A::RESERVED2,
                    7 => FSEL33_A::RXD0,
                    3 => FSEL33_A::RESERVED4,
                    2 => FSEL33_A::RXD1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL33_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL33_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL33_A::RESERVED0
            }
            #[doc = "Pin is connected to SA0"]
            #[inline(always)]
            pub fn is_sa0(&self) -> bool {
                *self == FSEL33_A::SA0
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL33_A::RESERVED2
            }
            #[doc = "Pin is connected to RXD0"]
            #[inline(always)]
            pub fn is_rxd0(&self) -> bool {
                *self == FSEL33_A::RXD0
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL33_A::RESERVED4
            }
            #[doc = "Pin is connected to RXD1"]
            #[inline(always)]
            pub fn is_rxd1(&self) -> bool {
                *self == FSEL33_A::RXD1
            }
        }
        #[doc = "Field `FSEL33` writer - Function Select 33"]
        pub type FSEL33_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL33_A>;
        impl<'a, REG, const O: u8> FSEL33_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL33_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL33_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL33_A::RESERVED0)
            }
            #[doc = "Pin is connected to SA0"]
            #[inline(always)]
            pub fn sa0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL33_A::SA0)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL33_A::RESERVED2)
            }
            #[doc = "Pin is connected to RXD0"]
            #[inline(always)]
            pub fn rxd0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL33_A::RXD0)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL33_A::RESERVED4)
            }
            #[doc = "Pin is connected to RXD1"]
            #[inline(always)]
            pub fn rxd1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL33_A::RXD1)
            }
        }
        #[doc = "Field `FSEL34` reader - Function Select 34"]
        pub type FSEL34_R = crate::FieldReader<FSEL34_A>;
        #[doc = "Function Select 34"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL34_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to GPCLK0"]
            GPCLK0 = 4,
            #[doc = "5: Pin is connected to SOE_N"]
            SOE_N = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL34_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL34_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL34_A {
            type Ux = u8;
        }
        impl FSEL34_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL34_A {
                match self.bits {
                    0 => FSEL34_A::INPUT,
                    1 => FSEL34_A::OUTPUT,
                    4 => FSEL34_A::GPCLK0,
                    5 => FSEL34_A::SOE_N,
                    6 => FSEL34_A::RESERVED2,
                    7 => FSEL34_A::RESERVED3,
                    3 => FSEL34_A::RESERVED4,
                    2 => FSEL34_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL34_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL34_A::OUTPUT
            }
            #[doc = "Pin is connected to GPCLK0"]
            #[inline(always)]
            pub fn is_gpclk0(&self) -> bool {
                *self == FSEL34_A::GPCLK0
            }
            #[doc = "Pin is connected to SOE_N"]
            #[inline(always)]
            pub fn is_soe_n(&self) -> bool {
                *self == FSEL34_A::SOE_N
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL34_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL34_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL34_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL34_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL34` writer - Function Select 34"]
        pub type FSEL34_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL34_A>;
        impl<'a, REG, const O: u8> FSEL34_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL34_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL34_A::OUTPUT)
            }
            #[doc = "Pin is connected to GPCLK0"]
            #[inline(always)]
            pub fn gpclk0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL34_A::GPCLK0)
            }
            #[doc = "Pin is connected to SOE_N"]
            #[inline(always)]
            pub fn soe_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL34_A::SOE_N)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL34_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL34_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL34_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL34_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL35` reader - Function Select 35"]
        pub type FSEL35_R = crate::FieldReader<FSEL35_A>;
        #[doc = "Function Select 35"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL35_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_CE1_N"]
            SPI0_CE1_N = 4,
            #[doc = "5: Pin is connected to SWE_N"]
            SWE_N = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL35_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL35_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL35_A {
            type Ux = u8;
        }
        impl FSEL35_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL35_A {
                match self.bits {
                    0 => FSEL35_A::INPUT,
                    1 => FSEL35_A::OUTPUT,
                    4 => FSEL35_A::SPI0_CE1_N,
                    5 => FSEL35_A::SWE_N,
                    6 => FSEL35_A::RESERVED2,
                    7 => FSEL35_A::RESERVED3,
                    3 => FSEL35_A::RESERVED4,
                    2 => FSEL35_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL35_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL35_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_CE1_N"]
            #[inline(always)]
            pub fn is_spi0_ce1_n(&self) -> bool {
                *self == FSEL35_A::SPI0_CE1_N
            }
            #[doc = "Pin is connected to SWE_N"]
            #[inline(always)]
            pub fn is_swe_n(&self) -> bool {
                *self == FSEL35_A::SWE_N
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL35_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL35_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL35_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL35_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL35` writer - Function Select 35"]
        pub type FSEL35_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL35_A>;
        impl<'a, REG, const O: u8> FSEL35_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL35_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL35_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_CE1_N"]
            #[inline(always)]
            pub fn spi0_ce1_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL35_A::SPI0_CE1_N)
            }
            #[doc = "Pin is connected to SWE_N"]
            #[inline(always)]
            pub fn swe_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL35_A::SWE_N)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL35_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL35_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL35_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL35_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL36` reader - Function Select 36"]
        pub type FSEL36_R = crate::FieldReader<FSEL36_A>;
        #[doc = "Function Select 36"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL36_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_CE0_N"]
            SPI0_CE0_N = 4,
            #[doc = "5: Pin is connected to SD0"]
            SD0 = 5,
            #[doc = "6: Pin is connected to TXD0"]
            TXD0 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL36_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL36_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL36_A {
            type Ux = u8;
        }
        impl FSEL36_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL36_A {
                match self.bits {
                    0 => FSEL36_A::INPUT,
                    1 => FSEL36_A::OUTPUT,
                    4 => FSEL36_A::SPI0_CE0_N,
                    5 => FSEL36_A::SD0,
                    6 => FSEL36_A::TXD0,
                    7 => FSEL36_A::RESERVED3,
                    3 => FSEL36_A::RESERVED4,
                    2 => FSEL36_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL36_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL36_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_CE0_N"]
            #[inline(always)]
            pub fn is_spi0_ce0_n(&self) -> bool {
                *self == FSEL36_A::SPI0_CE0_N
            }
            #[doc = "Pin is connected to SD0"]
            #[inline(always)]
            pub fn is_sd0(&self) -> bool {
                *self == FSEL36_A::SD0
            }
            #[doc = "Pin is connected to TXD0"]
            #[inline(always)]
            pub fn is_txd0(&self) -> bool {
                *self == FSEL36_A::TXD0
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL36_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL36_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL36_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL36` writer - Function Select 36"]
        pub type FSEL36_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL36_A>;
        impl<'a, REG, const O: u8> FSEL36_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL36_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL36_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_CE0_N"]
            #[inline(always)]
            pub fn spi0_ce0_n(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL36_A::SPI0_CE0_N)
            }
            #[doc = "Pin is connected to SD0"]
            #[inline(always)]
            pub fn sd0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL36_A::SD0)
            }
            #[doc = "Pin is connected to TXD0"]
            #[inline(always)]
            pub fn txd0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL36_A::TXD0)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL36_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL36_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL36_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL37` reader - Function Select 37"]
        pub type FSEL37_R = crate::FieldReader<FSEL37_A>;
        #[doc = "Function Select 37"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL37_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_MISO"]
            SPI0_MISO = 4,
            #[doc = "5: Pin is connected to SD1"]
            SD1 = 5,
            #[doc = "6: Pin is connected to RXD0"]
            RXD0 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL37_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL37_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL37_A {
            type Ux = u8;
        }
        impl FSEL37_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL37_A {
                match self.bits {
                    0 => FSEL37_A::INPUT,
                    1 => FSEL37_A::OUTPUT,
                    4 => FSEL37_A::SPI0_MISO,
                    5 => FSEL37_A::SD1,
                    6 => FSEL37_A::RXD0,
                    7 => FSEL37_A::RESERVED3,
                    3 => FSEL37_A::RESERVED4,
                    2 => FSEL37_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL37_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL37_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_MISO"]
            #[inline(always)]
            pub fn is_spi0_miso(&self) -> bool {
                *self == FSEL37_A::SPI0_MISO
            }
            #[doc = "Pin is connected to SD1"]
            #[inline(always)]
            pub fn is_sd1(&self) -> bool {
                *self == FSEL37_A::SD1
            }
            #[doc = "Pin is connected to RXD0"]
            #[inline(always)]
            pub fn is_rxd0(&self) -> bool {
                *self == FSEL37_A::RXD0
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL37_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL37_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL37_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL37` writer - Function Select 37"]
        pub type FSEL37_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL37_A>;
        impl<'a, REG, const O: u8> FSEL37_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL37_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL37_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_MISO"]
            #[inline(always)]
            pub fn spi0_miso(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL37_A::SPI0_MISO)
            }
            #[doc = "Pin is connected to SD1"]
            #[inline(always)]
            pub fn sd1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL37_A::SD1)
            }
            #[doc = "Pin is connected to RXD0"]
            #[inline(always)]
            pub fn rxd0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL37_A::RXD0)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL37_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL37_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL37_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL38` reader - Function Select 38"]
        pub type FSEL38_R = crate::FieldReader<FSEL38_A>;
        #[doc = "Function Select 38"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL38_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_MOSI"]
            SPI0_MOSI = 4,
            #[doc = "5: Pin is connected to SD2"]
            SD2 = 5,
            #[doc = "6: Pin is connected to CTS0"]
            CTS0 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL38_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL38_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL38_A {
            type Ux = u8;
        }
        impl FSEL38_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL38_A {
                match self.bits {
                    0 => FSEL38_A::INPUT,
                    1 => FSEL38_A::OUTPUT,
                    4 => FSEL38_A::SPI0_MOSI,
                    5 => FSEL38_A::SD2,
                    6 => FSEL38_A::CTS0,
                    7 => FSEL38_A::RESERVED3,
                    3 => FSEL38_A::RESERVED4,
                    2 => FSEL38_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL38_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL38_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_MOSI"]
            #[inline(always)]
            pub fn is_spi0_mosi(&self) -> bool {
                *self == FSEL38_A::SPI0_MOSI
            }
            #[doc = "Pin is connected to SD2"]
            #[inline(always)]
            pub fn is_sd2(&self) -> bool {
                *self == FSEL38_A::SD2
            }
            #[doc = "Pin is connected to CTS0"]
            #[inline(always)]
            pub fn is_cts0(&self) -> bool {
                *self == FSEL38_A::CTS0
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL38_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL38_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL38_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL38` writer - Function Select 38"]
        pub type FSEL38_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL38_A>;
        impl<'a, REG, const O: u8> FSEL38_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL38_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL38_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_MOSI"]
            #[inline(always)]
            pub fn spi0_mosi(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL38_A::SPI0_MOSI)
            }
            #[doc = "Pin is connected to SD2"]
            #[inline(always)]
            pub fn sd2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL38_A::SD2)
            }
            #[doc = "Pin is connected to CTS0"]
            #[inline(always)]
            pub fn cts0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL38_A::CTS0)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL38_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL38_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL38_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL39` reader - Function Select 39"]
        pub type FSEL39_R = crate::FieldReader<FSEL39_A>;
        #[doc = "Function Select 39"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL39_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to SPI0_SCLK"]
            SPI0_SCLK = 4,
            #[doc = "5: Pin is connected to SD3"]
            SD3 = 5,
            #[doc = "6: Pin is connected to RTS0"]
            RTS0 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL39_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL39_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL39_A {
            type Ux = u8;
        }
        impl FSEL39_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL39_A {
                match self.bits {
                    0 => FSEL39_A::INPUT,
                    1 => FSEL39_A::OUTPUT,
                    4 => FSEL39_A::SPI0_SCLK,
                    5 => FSEL39_A::SD3,
                    6 => FSEL39_A::RTS0,
                    7 => FSEL39_A::RESERVED3,
                    3 => FSEL39_A::RESERVED4,
                    2 => FSEL39_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL39_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL39_A::OUTPUT
            }
            #[doc = "Pin is connected to SPI0_SCLK"]
            #[inline(always)]
            pub fn is_spi0_sclk(&self) -> bool {
                *self == FSEL39_A::SPI0_SCLK
            }
            #[doc = "Pin is connected to SD3"]
            #[inline(always)]
            pub fn is_sd3(&self) -> bool {
                *self == FSEL39_A::SD3
            }
            #[doc = "Pin is connected to RTS0"]
            #[inline(always)]
            pub fn is_rts0(&self) -> bool {
                *self == FSEL39_A::RTS0
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL39_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL39_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL39_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL39` writer - Function Select 39"]
        pub type FSEL39_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL39_A>;
        impl<'a, REG, const O: u8> FSEL39_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL39_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL39_A::OUTPUT)
            }
            #[doc = "Pin is connected to SPI0_SCLK"]
            #[inline(always)]
            pub fn spi0_sclk(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL39_A::SPI0_SCLK)
            }
            #[doc = "Pin is connected to SD3"]
            #[inline(always)]
            pub fn sd3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL39_A::SD3)
            }
            #[doc = "Pin is connected to RTS0"]
            #[inline(always)]
            pub fn rts0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL39_A::RTS0)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL39_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL39_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL39_A::RESERVED5)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Function Select 30"]
            #[inline(always)]
            pub fn fsel30(&self) -> FSEL30_R {
                FSEL30_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:5 - Function Select 31"]
            #[inline(always)]
            pub fn fsel31(&self) -> FSEL31_R {
                FSEL31_R::new(((self.bits >> 3) & 7) as u8)
            }
            #[doc = "Bits 6:8 - Function Select 32"]
            #[inline(always)]
            pub fn fsel32(&self) -> FSEL32_R {
                FSEL32_R::new(((self.bits >> 6) & 7) as u8)
            }
            #[doc = "Bits 9:11 - Function Select 33"]
            #[inline(always)]
            pub fn fsel33(&self) -> FSEL33_R {
                FSEL33_R::new(((self.bits >> 9) & 7) as u8)
            }
            #[doc = "Bits 12:14 - Function Select 34"]
            #[inline(always)]
            pub fn fsel34(&self) -> FSEL34_R {
                FSEL34_R::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bits 15:17 - Function Select 35"]
            #[inline(always)]
            pub fn fsel35(&self) -> FSEL35_R {
                FSEL35_R::new(((self.bits >> 15) & 7) as u8)
            }
            #[doc = "Bits 18:20 - Function Select 36"]
            #[inline(always)]
            pub fn fsel36(&self) -> FSEL36_R {
                FSEL36_R::new(((self.bits >> 18) & 7) as u8)
            }
            #[doc = "Bits 21:23 - Function Select 37"]
            #[inline(always)]
            pub fn fsel37(&self) -> FSEL37_R {
                FSEL37_R::new(((self.bits >> 21) & 7) as u8)
            }
            #[doc = "Bits 24:26 - Function Select 38"]
            #[inline(always)]
            pub fn fsel38(&self) -> FSEL38_R {
                FSEL38_R::new(((self.bits >> 24) & 7) as u8)
            }
            #[doc = "Bits 27:29 - Function Select 39"]
            #[inline(always)]
            pub fn fsel39(&self) -> FSEL39_R {
                FSEL39_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPFSEL3")
                    .field("fsel30", &format_args!("{}", self.fsel30().bits()))
                    .field("fsel31", &format_args!("{}", self.fsel31().bits()))
                    .field("fsel32", &format_args!("{}", self.fsel32().bits()))
                    .field("fsel33", &format_args!("{}", self.fsel33().bits()))
                    .field("fsel34", &format_args!("{}", self.fsel34().bits()))
                    .field("fsel35", &format_args!("{}", self.fsel35().bits()))
                    .field("fsel36", &format_args!("{}", self.fsel36().bits()))
                    .field("fsel37", &format_args!("{}", self.fsel37().bits()))
                    .field("fsel38", &format_args!("{}", self.fsel38().bits()))
                    .field("fsel39", &format_args!("{}", self.fsel39().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPFSEL3_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Function Select 30"]
            #[inline(always)]
            #[must_use]
            pub fn fsel30(&mut self) -> FSEL30_W<GPFSEL3_SPEC, 0> {
                FSEL30_W::new(self)
            }
            #[doc = "Bits 3:5 - Function Select 31"]
            #[inline(always)]
            #[must_use]
            pub fn fsel31(&mut self) -> FSEL31_W<GPFSEL3_SPEC, 3> {
                FSEL31_W::new(self)
            }
            #[doc = "Bits 6:8 - Function Select 32"]
            #[inline(always)]
            #[must_use]
            pub fn fsel32(&mut self) -> FSEL32_W<GPFSEL3_SPEC, 6> {
                FSEL32_W::new(self)
            }
            #[doc = "Bits 9:11 - Function Select 33"]
            #[inline(always)]
            #[must_use]
            pub fn fsel33(&mut self) -> FSEL33_W<GPFSEL3_SPEC, 9> {
                FSEL33_W::new(self)
            }
            #[doc = "Bits 12:14 - Function Select 34"]
            #[inline(always)]
            #[must_use]
            pub fn fsel34(&mut self) -> FSEL34_W<GPFSEL3_SPEC, 12> {
                FSEL34_W::new(self)
            }
            #[doc = "Bits 15:17 - Function Select 35"]
            #[inline(always)]
            #[must_use]
            pub fn fsel35(&mut self) -> FSEL35_W<GPFSEL3_SPEC, 15> {
                FSEL35_W::new(self)
            }
            #[doc = "Bits 18:20 - Function Select 36"]
            #[inline(always)]
            #[must_use]
            pub fn fsel36(&mut self) -> FSEL36_W<GPFSEL3_SPEC, 18> {
                FSEL36_W::new(self)
            }
            #[doc = "Bits 21:23 - Function Select 37"]
            #[inline(always)]
            #[must_use]
            pub fn fsel37(&mut self) -> FSEL37_W<GPFSEL3_SPEC, 21> {
                FSEL37_W::new(self)
            }
            #[doc = "Bits 24:26 - Function Select 38"]
            #[inline(always)]
            #[must_use]
            pub fn fsel38(&mut self) -> FSEL38_W<GPFSEL3_SPEC, 24> {
                FSEL38_W::new(self)
            }
            #[doc = "Bits 27:29 - Function Select 39"]
            #[inline(always)]
            #[must_use]
            pub fn fsel39(&mut self) -> FSEL39_W<GPFSEL3_SPEC, 27> {
                FSEL39_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Function Select 3\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel3::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPFSEL3_SPEC;
        impl crate::RegisterSpec for GPFSEL3_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpfsel3::R`](R) reader structure"]
        impl crate::Readable for GPFSEL3_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpfsel3::W`](W) writer structure"]
        impl crate::Writable for GPFSEL3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPFSEL4 (rw) register accessor: GPIO Function Select 4\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel4::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpfsel4`]
module"]
    pub type GPFSEL4 = crate::Reg<gpfsel4::GPFSEL4_SPEC>;
    #[doc = "GPIO Function Select 4"]
    pub mod gpfsel4 {
        #[doc = "Register `GPFSEL4` reader"]
        pub type R = crate::R<GPFSEL4_SPEC>;
        #[doc = "Register `GPFSEL4` writer"]
        pub type W = crate::W<GPFSEL4_SPEC>;
        #[doc = "Field `FSEL40` reader - Function Select 40"]
        pub type FSEL40_R = crate::FieldReader<FSEL40_A>;
        #[doc = "Function Select 40"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL40_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PWM0_0"]
            PWM0_0 = 4,
            #[doc = "5: Pin is connected to SD4"]
            SD4 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to TXD1"]
            TXD1 = 2,
        }
        impl From<FSEL40_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL40_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL40_A {
            type Ux = u8;
        }
        impl FSEL40_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL40_A {
                match self.bits {
                    0 => FSEL40_A::INPUT,
                    1 => FSEL40_A::OUTPUT,
                    4 => FSEL40_A::PWM0_0,
                    5 => FSEL40_A::SD4,
                    6 => FSEL40_A::RESERVED2,
                    7 => FSEL40_A::RESERVED3,
                    3 => FSEL40_A::RESERVED4,
                    2 => FSEL40_A::TXD1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL40_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL40_A::OUTPUT
            }
            #[doc = "Pin is connected to PWM0_0"]
            #[inline(always)]
            pub fn is_pwm0_0(&self) -> bool {
                *self == FSEL40_A::PWM0_0
            }
            #[doc = "Pin is connected to SD4"]
            #[inline(always)]
            pub fn is_sd4(&self) -> bool {
                *self == FSEL40_A::SD4
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL40_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL40_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL40_A::RESERVED4
            }
            #[doc = "Pin is connected to TXD1"]
            #[inline(always)]
            pub fn is_txd1(&self) -> bool {
                *self == FSEL40_A::TXD1
            }
        }
        #[doc = "Field `FSEL40` writer - Function Select 40"]
        pub type FSEL40_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL40_A>;
        impl<'a, REG, const O: u8> FSEL40_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL40_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL40_A::OUTPUT)
            }
            #[doc = "Pin is connected to PWM0_0"]
            #[inline(always)]
            pub fn pwm0_0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL40_A::PWM0_0)
            }
            #[doc = "Pin is connected to SD4"]
            #[inline(always)]
            pub fn sd4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL40_A::SD4)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL40_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL40_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL40_A::RESERVED4)
            }
            #[doc = "Pin is connected to TXD1"]
            #[inline(always)]
            pub fn txd1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL40_A::TXD1)
            }
        }
        #[doc = "Field `FSEL41` reader - Function Select 41"]
        pub type FSEL41_R = crate::FieldReader<FSEL41_A>;
        #[doc = "Function Select 41"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL41_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PWM0_1"]
            PWM0_1 = 4,
            #[doc = "5: Pin is connected to SD5"]
            SD5 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to RXD1"]
            RXD1 = 2,
        }
        impl From<FSEL41_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL41_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL41_A {
            type Ux = u8;
        }
        impl FSEL41_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL41_A {
                match self.bits {
                    0 => FSEL41_A::INPUT,
                    1 => FSEL41_A::OUTPUT,
                    4 => FSEL41_A::PWM0_1,
                    5 => FSEL41_A::SD5,
                    6 => FSEL41_A::RESERVED2,
                    7 => FSEL41_A::RESERVED3,
                    3 => FSEL41_A::RESERVED4,
                    2 => FSEL41_A::RXD1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL41_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL41_A::OUTPUT
            }
            #[doc = "Pin is connected to PWM0_1"]
            #[inline(always)]
            pub fn is_pwm0_1(&self) -> bool {
                *self == FSEL41_A::PWM0_1
            }
            #[doc = "Pin is connected to SD5"]
            #[inline(always)]
            pub fn is_sd5(&self) -> bool {
                *self == FSEL41_A::SD5
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL41_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL41_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL41_A::RESERVED4
            }
            #[doc = "Pin is connected to RXD1"]
            #[inline(always)]
            pub fn is_rxd1(&self) -> bool {
                *self == FSEL41_A::RXD1
            }
        }
        #[doc = "Field `FSEL41` writer - Function Select 41"]
        pub type FSEL41_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL41_A>;
        impl<'a, REG, const O: u8> FSEL41_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL41_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL41_A::OUTPUT)
            }
            #[doc = "Pin is connected to PWM0_1"]
            #[inline(always)]
            pub fn pwm0_1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL41_A::PWM0_1)
            }
            #[doc = "Pin is connected to SD5"]
            #[inline(always)]
            pub fn sd5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL41_A::SD5)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL41_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL41_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL41_A::RESERVED4)
            }
            #[doc = "Pin is connected to RXD1"]
            #[inline(always)]
            pub fn rxd1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL41_A::RXD1)
            }
        }
        #[doc = "Field `FSEL42` reader - Function Select 42"]
        pub type FSEL42_R = crate::FieldReader<FSEL42_A>;
        #[doc = "Function Select 42"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL42_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to GPCLK1"]
            GPCLK1 = 4,
            #[doc = "5: Pin is connected to SD6"]
            SD6 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to CTS1"]
            CTS1 = 2,
        }
        impl From<FSEL42_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL42_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL42_A {
            type Ux = u8;
        }
        impl FSEL42_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL42_A {
                match self.bits {
                    0 => FSEL42_A::INPUT,
                    1 => FSEL42_A::OUTPUT,
                    4 => FSEL42_A::GPCLK1,
                    5 => FSEL42_A::SD6,
                    6 => FSEL42_A::RESERVED2,
                    7 => FSEL42_A::RESERVED3,
                    3 => FSEL42_A::RESERVED4,
                    2 => FSEL42_A::CTS1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL42_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL42_A::OUTPUT
            }
            #[doc = "Pin is connected to GPCLK1"]
            #[inline(always)]
            pub fn is_gpclk1(&self) -> bool {
                *self == FSEL42_A::GPCLK1
            }
            #[doc = "Pin is connected to SD6"]
            #[inline(always)]
            pub fn is_sd6(&self) -> bool {
                *self == FSEL42_A::SD6
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL42_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL42_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL42_A::RESERVED4
            }
            #[doc = "Pin is connected to CTS1"]
            #[inline(always)]
            pub fn is_cts1(&self) -> bool {
                *self == FSEL42_A::CTS1
            }
        }
        #[doc = "Field `FSEL42` writer - Function Select 42"]
        pub type FSEL42_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL42_A>;
        impl<'a, REG, const O: u8> FSEL42_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL42_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL42_A::OUTPUT)
            }
            #[doc = "Pin is connected to GPCLK1"]
            #[inline(always)]
            pub fn gpclk1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL42_A::GPCLK1)
            }
            #[doc = "Pin is connected to SD6"]
            #[inline(always)]
            pub fn sd6(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL42_A::SD6)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL42_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL42_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL42_A::RESERVED4)
            }
            #[doc = "Pin is connected to CTS1"]
            #[inline(always)]
            pub fn cts1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL42_A::CTS1)
            }
        }
        #[doc = "Field `FSEL43` reader - Function Select 43"]
        pub type FSEL43_R = crate::FieldReader<FSEL43_A>;
        #[doc = "Function Select 43"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL43_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to GPCLK2"]
            GPCLK2 = 4,
            #[doc = "5: Pin is connected to SD7"]
            SD7 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Pin is connected to RTS1"]
            RTS1 = 2,
        }
        impl From<FSEL43_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL43_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL43_A {
            type Ux = u8;
        }
        impl FSEL43_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL43_A {
                match self.bits {
                    0 => FSEL43_A::INPUT,
                    1 => FSEL43_A::OUTPUT,
                    4 => FSEL43_A::GPCLK2,
                    5 => FSEL43_A::SD7,
                    6 => FSEL43_A::RESERVED2,
                    7 => FSEL43_A::RESERVED3,
                    3 => FSEL43_A::RESERVED4,
                    2 => FSEL43_A::RTS1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL43_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL43_A::OUTPUT
            }
            #[doc = "Pin is connected to GPCLK2"]
            #[inline(always)]
            pub fn is_gpclk2(&self) -> bool {
                *self == FSEL43_A::GPCLK2
            }
            #[doc = "Pin is connected to SD7"]
            #[inline(always)]
            pub fn is_sd7(&self) -> bool {
                *self == FSEL43_A::SD7
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL43_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL43_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL43_A::RESERVED4
            }
            #[doc = "Pin is connected to RTS1"]
            #[inline(always)]
            pub fn is_rts1(&self) -> bool {
                *self == FSEL43_A::RTS1
            }
        }
        #[doc = "Field `FSEL43` writer - Function Select 43"]
        pub type FSEL43_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL43_A>;
        impl<'a, REG, const O: u8> FSEL43_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL43_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL43_A::OUTPUT)
            }
            #[doc = "Pin is connected to GPCLK2"]
            #[inline(always)]
            pub fn gpclk2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL43_A::GPCLK2)
            }
            #[doc = "Pin is connected to SD7"]
            #[inline(always)]
            pub fn sd7(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL43_A::SD7)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL43_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL43_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL43_A::RESERVED4)
            }
            #[doc = "Pin is connected to RTS1"]
            #[inline(always)]
            pub fn rts1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL43_A::RTS1)
            }
        }
        #[doc = "Field `FSEL44` reader - Function Select 44"]
        pub type FSEL44_R = crate::FieldReader<FSEL44_A>;
        #[doc = "Function Select 44"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL44_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to GPCLK1"]
            GPCLK1 = 4,
            #[doc = "5: Pin is connected to SDA0"]
            SDA0 = 5,
            #[doc = "6: Pin is connected to SDA1"]
            SDA1 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL44_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL44_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL44_A {
            type Ux = u8;
        }
        impl FSEL44_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL44_A {
                match self.bits {
                    0 => FSEL44_A::INPUT,
                    1 => FSEL44_A::OUTPUT,
                    4 => FSEL44_A::GPCLK1,
                    5 => FSEL44_A::SDA0,
                    6 => FSEL44_A::SDA1,
                    7 => FSEL44_A::RESERVED3,
                    3 => FSEL44_A::RESERVED4,
                    2 => FSEL44_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL44_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL44_A::OUTPUT
            }
            #[doc = "Pin is connected to GPCLK1"]
            #[inline(always)]
            pub fn is_gpclk1(&self) -> bool {
                *self == FSEL44_A::GPCLK1
            }
            #[doc = "Pin is connected to SDA0"]
            #[inline(always)]
            pub fn is_sda0(&self) -> bool {
                *self == FSEL44_A::SDA0
            }
            #[doc = "Pin is connected to SDA1"]
            #[inline(always)]
            pub fn is_sda1(&self) -> bool {
                *self == FSEL44_A::SDA1
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL44_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL44_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL44_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL44` writer - Function Select 44"]
        pub type FSEL44_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL44_A>;
        impl<'a, REG, const O: u8> FSEL44_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL44_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL44_A::OUTPUT)
            }
            #[doc = "Pin is connected to GPCLK1"]
            #[inline(always)]
            pub fn gpclk1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL44_A::GPCLK1)
            }
            #[doc = "Pin is connected to SDA0"]
            #[inline(always)]
            pub fn sda0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL44_A::SDA0)
            }
            #[doc = "Pin is connected to SDA1"]
            #[inline(always)]
            pub fn sda1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL44_A::SDA1)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL44_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL44_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL44_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL45` reader - Function Select 45"]
        pub type FSEL45_R = crate::FieldReader<FSEL45_A>;
        #[doc = "Function Select 45"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL45_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Pin is connected to PWM0_1"]
            PWM0_1 = 4,
            #[doc = "5: Pin is connected to SCL0"]
            SCL0 = 5,
            #[doc = "6: Pin is connected to SCL1"]
            SCL1 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL45_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL45_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL45_A {
            type Ux = u8;
        }
        impl FSEL45_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL45_A {
                match self.bits {
                    0 => FSEL45_A::INPUT,
                    1 => FSEL45_A::OUTPUT,
                    4 => FSEL45_A::PWM0_1,
                    5 => FSEL45_A::SCL0,
                    6 => FSEL45_A::SCL1,
                    7 => FSEL45_A::RESERVED3,
                    3 => FSEL45_A::RESERVED4,
                    2 => FSEL45_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL45_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL45_A::OUTPUT
            }
            #[doc = "Pin is connected to PWM0_1"]
            #[inline(always)]
            pub fn is_pwm0_1(&self) -> bool {
                *self == FSEL45_A::PWM0_1
            }
            #[doc = "Pin is connected to SCL0"]
            #[inline(always)]
            pub fn is_scl0(&self) -> bool {
                *self == FSEL45_A::SCL0
            }
            #[doc = "Pin is connected to SCL1"]
            #[inline(always)]
            pub fn is_scl1(&self) -> bool {
                *self == FSEL45_A::SCL1
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL45_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL45_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL45_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL45` writer - Function Select 45"]
        pub type FSEL45_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL45_A>;
        impl<'a, REG, const O: u8> FSEL45_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL45_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL45_A::OUTPUT)
            }
            #[doc = "Pin is connected to PWM0_1"]
            #[inline(always)]
            pub fn pwm0_1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL45_A::PWM0_1)
            }
            #[doc = "Pin is connected to SCL0"]
            #[inline(always)]
            pub fn scl0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL45_A::SCL0)
            }
            #[doc = "Pin is connected to SCL1"]
            #[inline(always)]
            pub fn scl1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL45_A::SCL1)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL45_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL45_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL45_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL46` reader - Function Select 46"]
        pub type FSEL46_R = crate::FieldReader<FSEL46_A>;
        #[doc = "Function Select 46"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL46_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL46_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL46_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL46_A {
            type Ux = u8;
        }
        impl FSEL46_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL46_A {
                match self.bits {
                    0 => FSEL46_A::INPUT,
                    1 => FSEL46_A::OUTPUT,
                    4 => FSEL46_A::RESERVED0,
                    5 => FSEL46_A::RESERVED1,
                    6 => FSEL46_A::RESERVED2,
                    7 => FSEL46_A::RESERVED3,
                    3 => FSEL46_A::RESERVED4,
                    2 => FSEL46_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL46_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL46_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL46_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL46_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL46_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL46_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL46_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL46_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL46` writer - Function Select 46"]
        pub type FSEL46_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL46_A>;
        impl<'a, REG, const O: u8> FSEL46_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL46_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL46_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL46_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL46_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL46_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL46_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL46_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL46_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL47` reader - Function Select 47"]
        pub type FSEL47_R = crate::FieldReader<FSEL47_A>;
        #[doc = "Function Select 47"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL47_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Alt function 3 reserved"]
            RESERVED3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL47_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL47_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL47_A {
            type Ux = u8;
        }
        impl FSEL47_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL47_A {
                match self.bits {
                    0 => FSEL47_A::INPUT,
                    1 => FSEL47_A::OUTPUT,
                    4 => FSEL47_A::RESERVED0,
                    5 => FSEL47_A::RESERVED1,
                    6 => FSEL47_A::RESERVED2,
                    7 => FSEL47_A::RESERVED3,
                    3 => FSEL47_A::RESERVED4,
                    2 => FSEL47_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL47_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL47_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL47_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL47_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL47_A::RESERVED2
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn is_reserved3(&self) -> bool {
                *self == FSEL47_A::RESERVED3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL47_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL47_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL47` writer - Function Select 47"]
        pub type FSEL47_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL47_A>;
        impl<'a, REG, const O: u8> FSEL47_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL47_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL47_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL47_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL47_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL47_A::RESERVED2)
            }
            #[doc = "Alt function 3 reserved"]
            #[inline(always)]
            pub fn reserved3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL47_A::RESERVED3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL47_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL47_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL48` reader - Function Select 48"]
        pub type FSEL48_R = crate::FieldReader<FSEL48_A>;
        #[doc = "Function Select 48"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL48_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_CLK"]
            SD1_CLK = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL48_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL48_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL48_A {
            type Ux = u8;
        }
        impl FSEL48_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL48_A {
                match self.bits {
                    0 => FSEL48_A::INPUT,
                    1 => FSEL48_A::OUTPUT,
                    4 => FSEL48_A::RESERVED0,
                    5 => FSEL48_A::RESERVED1,
                    6 => FSEL48_A::RESERVED2,
                    7 => FSEL48_A::SD1_CLK,
                    3 => FSEL48_A::RESERVED4,
                    2 => FSEL48_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL48_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL48_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL48_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL48_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL48_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_CLK"]
            #[inline(always)]
            pub fn is_sd1_clk(&self) -> bool {
                *self == FSEL48_A::SD1_CLK
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL48_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL48_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL48` writer - Function Select 48"]
        pub type FSEL48_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL48_A>;
        impl<'a, REG, const O: u8> FSEL48_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL48_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL48_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL48_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL48_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL48_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_CLK"]
            #[inline(always)]
            pub fn sd1_clk(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL48_A::SD1_CLK)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL48_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL48_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL49` reader - Function Select 49"]
        pub type FSEL49_R = crate::FieldReader<FSEL49_A>;
        #[doc = "Function Select 49"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL49_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_CMD"]
            SD1_CMD = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL49_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL49_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL49_A {
            type Ux = u8;
        }
        impl FSEL49_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL49_A {
                match self.bits {
                    0 => FSEL49_A::INPUT,
                    1 => FSEL49_A::OUTPUT,
                    4 => FSEL49_A::RESERVED0,
                    5 => FSEL49_A::RESERVED1,
                    6 => FSEL49_A::RESERVED2,
                    7 => FSEL49_A::SD1_CMD,
                    3 => FSEL49_A::RESERVED4,
                    2 => FSEL49_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL49_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL49_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL49_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL49_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL49_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_CMD"]
            #[inline(always)]
            pub fn is_sd1_cmd(&self) -> bool {
                *self == FSEL49_A::SD1_CMD
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL49_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL49_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL49` writer - Function Select 49"]
        pub type FSEL49_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL49_A>;
        impl<'a, REG, const O: u8> FSEL49_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL49_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL49_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL49_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL49_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL49_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_CMD"]
            #[inline(always)]
            pub fn sd1_cmd(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL49_A::SD1_CMD)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL49_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL49_A::RESERVED5)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Function Select 40"]
            #[inline(always)]
            pub fn fsel40(&self) -> FSEL40_R {
                FSEL40_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:5 - Function Select 41"]
            #[inline(always)]
            pub fn fsel41(&self) -> FSEL41_R {
                FSEL41_R::new(((self.bits >> 3) & 7) as u8)
            }
            #[doc = "Bits 6:8 - Function Select 42"]
            #[inline(always)]
            pub fn fsel42(&self) -> FSEL42_R {
                FSEL42_R::new(((self.bits >> 6) & 7) as u8)
            }
            #[doc = "Bits 9:11 - Function Select 43"]
            #[inline(always)]
            pub fn fsel43(&self) -> FSEL43_R {
                FSEL43_R::new(((self.bits >> 9) & 7) as u8)
            }
            #[doc = "Bits 12:14 - Function Select 44"]
            #[inline(always)]
            pub fn fsel44(&self) -> FSEL44_R {
                FSEL44_R::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bits 15:17 - Function Select 45"]
            #[inline(always)]
            pub fn fsel45(&self) -> FSEL45_R {
                FSEL45_R::new(((self.bits >> 15) & 7) as u8)
            }
            #[doc = "Bits 18:20 - Function Select 46"]
            #[inline(always)]
            pub fn fsel46(&self) -> FSEL46_R {
                FSEL46_R::new(((self.bits >> 18) & 7) as u8)
            }
            #[doc = "Bits 21:23 - Function Select 47"]
            #[inline(always)]
            pub fn fsel47(&self) -> FSEL47_R {
                FSEL47_R::new(((self.bits >> 21) & 7) as u8)
            }
            #[doc = "Bits 24:26 - Function Select 48"]
            #[inline(always)]
            pub fn fsel48(&self) -> FSEL48_R {
                FSEL48_R::new(((self.bits >> 24) & 7) as u8)
            }
            #[doc = "Bits 27:29 - Function Select 49"]
            #[inline(always)]
            pub fn fsel49(&self) -> FSEL49_R {
                FSEL49_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPFSEL4")
                    .field("fsel40", &format_args!("{}", self.fsel40().bits()))
                    .field("fsel41", &format_args!("{}", self.fsel41().bits()))
                    .field("fsel42", &format_args!("{}", self.fsel42().bits()))
                    .field("fsel43", &format_args!("{}", self.fsel43().bits()))
                    .field("fsel44", &format_args!("{}", self.fsel44().bits()))
                    .field("fsel45", &format_args!("{}", self.fsel45().bits()))
                    .field("fsel46", &format_args!("{}", self.fsel46().bits()))
                    .field("fsel47", &format_args!("{}", self.fsel47().bits()))
                    .field("fsel48", &format_args!("{}", self.fsel48().bits()))
                    .field("fsel49", &format_args!("{}", self.fsel49().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPFSEL4_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Function Select 40"]
            #[inline(always)]
            #[must_use]
            pub fn fsel40(&mut self) -> FSEL40_W<GPFSEL4_SPEC, 0> {
                FSEL40_W::new(self)
            }
            #[doc = "Bits 3:5 - Function Select 41"]
            #[inline(always)]
            #[must_use]
            pub fn fsel41(&mut self) -> FSEL41_W<GPFSEL4_SPEC, 3> {
                FSEL41_W::new(self)
            }
            #[doc = "Bits 6:8 - Function Select 42"]
            #[inline(always)]
            #[must_use]
            pub fn fsel42(&mut self) -> FSEL42_W<GPFSEL4_SPEC, 6> {
                FSEL42_W::new(self)
            }
            #[doc = "Bits 9:11 - Function Select 43"]
            #[inline(always)]
            #[must_use]
            pub fn fsel43(&mut self) -> FSEL43_W<GPFSEL4_SPEC, 9> {
                FSEL43_W::new(self)
            }
            #[doc = "Bits 12:14 - Function Select 44"]
            #[inline(always)]
            #[must_use]
            pub fn fsel44(&mut self) -> FSEL44_W<GPFSEL4_SPEC, 12> {
                FSEL44_W::new(self)
            }
            #[doc = "Bits 15:17 - Function Select 45"]
            #[inline(always)]
            #[must_use]
            pub fn fsel45(&mut self) -> FSEL45_W<GPFSEL4_SPEC, 15> {
                FSEL45_W::new(self)
            }
            #[doc = "Bits 18:20 - Function Select 46"]
            #[inline(always)]
            #[must_use]
            pub fn fsel46(&mut self) -> FSEL46_W<GPFSEL4_SPEC, 18> {
                FSEL46_W::new(self)
            }
            #[doc = "Bits 21:23 - Function Select 47"]
            #[inline(always)]
            #[must_use]
            pub fn fsel47(&mut self) -> FSEL47_W<GPFSEL4_SPEC, 21> {
                FSEL47_W::new(self)
            }
            #[doc = "Bits 24:26 - Function Select 48"]
            #[inline(always)]
            #[must_use]
            pub fn fsel48(&mut self) -> FSEL48_W<GPFSEL4_SPEC, 24> {
                FSEL48_W::new(self)
            }
            #[doc = "Bits 27:29 - Function Select 49"]
            #[inline(always)]
            #[must_use]
            pub fn fsel49(&mut self) -> FSEL49_W<GPFSEL4_SPEC, 27> {
                FSEL49_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Function Select 4\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel4::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPFSEL4_SPEC;
        impl crate::RegisterSpec for GPFSEL4_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpfsel4::R`](R) reader structure"]
        impl crate::Readable for GPFSEL4_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpfsel4::W`](W) writer structure"]
        impl crate::Writable for GPFSEL4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPFSEL5 (rw) register accessor: GPIO Function Select 5\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel5::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpfsel5`]
module"]
    pub type GPFSEL5 = crate::Reg<gpfsel5::GPFSEL5_SPEC>;
    #[doc = "GPIO Function Select 5"]
    pub mod gpfsel5 {
        #[doc = "Register `GPFSEL5` reader"]
        pub type R = crate::R<GPFSEL5_SPEC>;
        #[doc = "Register `GPFSEL5` writer"]
        pub type W = crate::W<GPFSEL5_SPEC>;
        #[doc = "Field `FSEL50` reader - Function Select 50"]
        pub type FSEL50_R = crate::FieldReader<FSEL50_A>;
        #[doc = "Function Select 50"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL50_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_DAT0"]
            SD1_DAT0 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL50_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL50_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL50_A {
            type Ux = u8;
        }
        impl FSEL50_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL50_A {
                match self.bits {
                    0 => FSEL50_A::INPUT,
                    1 => FSEL50_A::OUTPUT,
                    4 => FSEL50_A::RESERVED0,
                    5 => FSEL50_A::RESERVED1,
                    6 => FSEL50_A::RESERVED2,
                    7 => FSEL50_A::SD1_DAT0,
                    3 => FSEL50_A::RESERVED4,
                    2 => FSEL50_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL50_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL50_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL50_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL50_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL50_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_DAT0"]
            #[inline(always)]
            pub fn is_sd1_dat0(&self) -> bool {
                *self == FSEL50_A::SD1_DAT0
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL50_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL50_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL50` writer - Function Select 50"]
        pub type FSEL50_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL50_A>;
        impl<'a, REG, const O: u8> FSEL50_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL50_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL50_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL50_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL50_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL50_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_DAT0"]
            #[inline(always)]
            pub fn sd1_dat0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL50_A::SD1_DAT0)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL50_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL50_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL51` reader - Function Select 51"]
        pub type FSEL51_R = crate::FieldReader<FSEL51_A>;
        #[doc = "Function Select 51"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL51_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_DAT1"]
            SD1_DAT1 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL51_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL51_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL51_A {
            type Ux = u8;
        }
        impl FSEL51_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL51_A {
                match self.bits {
                    0 => FSEL51_A::INPUT,
                    1 => FSEL51_A::OUTPUT,
                    4 => FSEL51_A::RESERVED0,
                    5 => FSEL51_A::RESERVED1,
                    6 => FSEL51_A::RESERVED2,
                    7 => FSEL51_A::SD1_DAT1,
                    3 => FSEL51_A::RESERVED4,
                    2 => FSEL51_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL51_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL51_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL51_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL51_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL51_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_DAT1"]
            #[inline(always)]
            pub fn is_sd1_dat1(&self) -> bool {
                *self == FSEL51_A::SD1_DAT1
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL51_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL51_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL51` writer - Function Select 51"]
        pub type FSEL51_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL51_A>;
        impl<'a, REG, const O: u8> FSEL51_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL51_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL51_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL51_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL51_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL51_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_DAT1"]
            #[inline(always)]
            pub fn sd1_dat1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL51_A::SD1_DAT1)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL51_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL51_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL52` reader - Function Select 52"]
        pub type FSEL52_R = crate::FieldReader<FSEL52_A>;
        #[doc = "Function Select 52"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL52_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_DAT2"]
            SD1_DAT2 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL52_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL52_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL52_A {
            type Ux = u8;
        }
        impl FSEL52_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL52_A {
                match self.bits {
                    0 => FSEL52_A::INPUT,
                    1 => FSEL52_A::OUTPUT,
                    4 => FSEL52_A::RESERVED0,
                    5 => FSEL52_A::RESERVED1,
                    6 => FSEL52_A::RESERVED2,
                    7 => FSEL52_A::SD1_DAT2,
                    3 => FSEL52_A::RESERVED4,
                    2 => FSEL52_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL52_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL52_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL52_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL52_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL52_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_DAT2"]
            #[inline(always)]
            pub fn is_sd1_dat2(&self) -> bool {
                *self == FSEL52_A::SD1_DAT2
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL52_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL52_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL52` writer - Function Select 52"]
        pub type FSEL52_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL52_A>;
        impl<'a, REG, const O: u8> FSEL52_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL52_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL52_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL52_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL52_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL52_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_DAT2"]
            #[inline(always)]
            pub fn sd1_dat2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL52_A::SD1_DAT2)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL52_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL52_A::RESERVED5)
            }
        }
        #[doc = "Field `FSEL53` reader - Function Select 53"]
        pub type FSEL53_R = crate::FieldReader<FSEL53_A>;
        #[doc = "Function Select 53"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FSEL53_A {
            #[doc = "0: Pin is an input"]
            INPUT = 0,
            #[doc = "1: Pin is an output"]
            OUTPUT = 1,
            #[doc = "4: Alt function 0 reserved"]
            RESERVED0 = 4,
            #[doc = "5: Alt function 1 reserved"]
            RESERVED1 = 5,
            #[doc = "6: Alt function 2 reserved"]
            RESERVED2 = 6,
            #[doc = "7: Pin is connected to SD1_DAT3"]
            SD1_DAT3 = 7,
            #[doc = "3: Alt function 4 reserved"]
            RESERVED4 = 3,
            #[doc = "2: Alt function 5 reserved"]
            RESERVED5 = 2,
        }
        impl From<FSEL53_A> for u8 {
            #[inline(always)]
            fn from(variant: FSEL53_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FSEL53_A {
            type Ux = u8;
        }
        impl FSEL53_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSEL53_A {
                match self.bits {
                    0 => FSEL53_A::INPUT,
                    1 => FSEL53_A::OUTPUT,
                    4 => FSEL53_A::RESERVED0,
                    5 => FSEL53_A::RESERVED1,
                    6 => FSEL53_A::RESERVED2,
                    7 => FSEL53_A::SD1_DAT3,
                    3 => FSEL53_A::RESERVED4,
                    2 => FSEL53_A::RESERVED5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == FSEL53_A::INPUT
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == FSEL53_A::OUTPUT
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn is_reserved0(&self) -> bool {
                *self == FSEL53_A::RESERVED0
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn is_reserved1(&self) -> bool {
                *self == FSEL53_A::RESERVED1
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn is_reserved2(&self) -> bool {
                *self == FSEL53_A::RESERVED2
            }
            #[doc = "Pin is connected to SD1_DAT3"]
            #[inline(always)]
            pub fn is_sd1_dat3(&self) -> bool {
                *self == FSEL53_A::SD1_DAT3
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn is_reserved4(&self) -> bool {
                *self == FSEL53_A::RESERVED4
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn is_reserved5(&self) -> bool {
                *self == FSEL53_A::RESERVED5
            }
        }
        #[doc = "Field `FSEL53` writer - Function Select 53"]
        pub type FSEL53_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 3, O, FSEL53_A>;
        impl<'a, REG, const O: u8> FSEL53_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Pin is an input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL53_A::INPUT)
            }
            #[doc = "Pin is an output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL53_A::OUTPUT)
            }
            #[doc = "Alt function 0 reserved"]
            #[inline(always)]
            pub fn reserved0(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL53_A::RESERVED0)
            }
            #[doc = "Alt function 1 reserved"]
            #[inline(always)]
            pub fn reserved1(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL53_A::RESERVED1)
            }
            #[doc = "Alt function 2 reserved"]
            #[inline(always)]
            pub fn reserved2(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL53_A::RESERVED2)
            }
            #[doc = "Pin is connected to SD1_DAT3"]
            #[inline(always)]
            pub fn sd1_dat3(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL53_A::SD1_DAT3)
            }
            #[doc = "Alt function 4 reserved"]
            #[inline(always)]
            pub fn reserved4(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL53_A::RESERVED4)
            }
            #[doc = "Alt function 5 reserved"]
            #[inline(always)]
            pub fn reserved5(self) -> &'a mut crate::W<REG> {
                self.variant(FSEL53_A::RESERVED5)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Function Select 50"]
            #[inline(always)]
            pub fn fsel50(&self) -> FSEL50_R {
                FSEL50_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:5 - Function Select 51"]
            #[inline(always)]
            pub fn fsel51(&self) -> FSEL51_R {
                FSEL51_R::new(((self.bits >> 3) & 7) as u8)
            }
            #[doc = "Bits 6:8 - Function Select 52"]
            #[inline(always)]
            pub fn fsel52(&self) -> FSEL52_R {
                FSEL52_R::new(((self.bits >> 6) & 7) as u8)
            }
            #[doc = "Bits 9:11 - Function Select 53"]
            #[inline(always)]
            pub fn fsel53(&self) -> FSEL53_R {
                FSEL53_R::new(((self.bits >> 9) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPFSEL5")
                    .field("fsel50", &format_args!("{}", self.fsel50().bits()))
                    .field("fsel51", &format_args!("{}", self.fsel51().bits()))
                    .field("fsel52", &format_args!("{}", self.fsel52().bits()))
                    .field("fsel53", &format_args!("{}", self.fsel53().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPFSEL5_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Function Select 50"]
            #[inline(always)]
            #[must_use]
            pub fn fsel50(&mut self) -> FSEL50_W<GPFSEL5_SPEC, 0> {
                FSEL50_W::new(self)
            }
            #[doc = "Bits 3:5 - Function Select 51"]
            #[inline(always)]
            #[must_use]
            pub fn fsel51(&mut self) -> FSEL51_W<GPFSEL5_SPEC, 3> {
                FSEL51_W::new(self)
            }
            #[doc = "Bits 6:8 - Function Select 52"]
            #[inline(always)]
            #[must_use]
            pub fn fsel52(&mut self) -> FSEL52_W<GPFSEL5_SPEC, 6> {
                FSEL52_W::new(self)
            }
            #[doc = "Bits 9:11 - Function Select 53"]
            #[inline(always)]
            #[must_use]
            pub fn fsel53(&mut self) -> FSEL53_W<GPFSEL5_SPEC, 9> {
                FSEL53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Function Select 5\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfsel5::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfsel5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPFSEL5_SPEC;
        impl crate::RegisterSpec for GPFSEL5_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpfsel5::R`](R) reader structure"]
        impl crate::Readable for GPFSEL5_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpfsel5::W`](W) writer structure"]
        impl crate::Writable for GPFSEL5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPSET0 (w) register accessor: GPIO Pin Output Set 0\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpset0::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpset0`]
module"]
    pub type GPSET0 = crate::Reg<gpset0::GPSET0_SPEC>;
    #[doc = "GPIO Pin Output Set 0"]
    pub mod gpset0 {
        #[doc = "Register `GPSET0` writer"]
        pub type W = crate::W<GPSET0_SPEC>;
        #[doc = "Field `SET0` writer - Set 0"]
        pub type SET0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET1` writer - Set 1"]
        pub type SET1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET2` writer - Set 2"]
        pub type SET2_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET3` writer - Set 3"]
        pub type SET3_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET4` writer - Set 4"]
        pub type SET4_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET5` writer - Set 5"]
        pub type SET5_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET6` writer - Set 6"]
        pub type SET6_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET7` writer - Set 7"]
        pub type SET7_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET8` writer - Set 8"]
        pub type SET8_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET9` writer - Set 9"]
        pub type SET9_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET10` writer - Set 10"]
        pub type SET10_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET11` writer - Set 11"]
        pub type SET11_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET12` writer - Set 12"]
        pub type SET12_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET13` writer - Set 13"]
        pub type SET13_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET14` writer - Set 14"]
        pub type SET14_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET15` writer - Set 15"]
        pub type SET15_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET16` writer - Set 16"]
        pub type SET16_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET17` writer - Set 17"]
        pub type SET17_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET18` writer - Set 18"]
        pub type SET18_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET19` writer - Set 19"]
        pub type SET19_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET20` writer - Set 20"]
        pub type SET20_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET21` writer - Set 21"]
        pub type SET21_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET22` writer - Set 22"]
        pub type SET22_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET23` writer - Set 23"]
        pub type SET23_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET24` writer - Set 24"]
        pub type SET24_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET25` writer - Set 25"]
        pub type SET25_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET26` writer - Set 26"]
        pub type SET26_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET27` writer - Set 27"]
        pub type SET27_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET28` writer - Set 28"]
        pub type SET28_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET29` writer - Set 29"]
        pub type SET29_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET30` writer - Set 30"]
        pub type SET30_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET31` writer - Set 31"]
        pub type SET31_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        impl core::fmt::Debug for crate::generic::Reg<GPSET0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {
            #[doc = "Bit 0 - Set 0"]
            #[inline(always)]
            #[must_use]
            pub fn set0(&mut self) -> SET0_W<GPSET0_SPEC, 0> {
                SET0_W::new(self)
            }
            #[doc = "Bit 1 - Set 1"]
            #[inline(always)]
            #[must_use]
            pub fn set1(&mut self) -> SET1_W<GPSET0_SPEC, 1> {
                SET1_W::new(self)
            }
            #[doc = "Bit 2 - Set 2"]
            #[inline(always)]
            #[must_use]
            pub fn set2(&mut self) -> SET2_W<GPSET0_SPEC, 2> {
                SET2_W::new(self)
            }
            #[doc = "Bit 3 - Set 3"]
            #[inline(always)]
            #[must_use]
            pub fn set3(&mut self) -> SET3_W<GPSET0_SPEC, 3> {
                SET3_W::new(self)
            }
            #[doc = "Bit 4 - Set 4"]
            #[inline(always)]
            #[must_use]
            pub fn set4(&mut self) -> SET4_W<GPSET0_SPEC, 4> {
                SET4_W::new(self)
            }
            #[doc = "Bit 5 - Set 5"]
            #[inline(always)]
            #[must_use]
            pub fn set5(&mut self) -> SET5_W<GPSET0_SPEC, 5> {
                SET5_W::new(self)
            }
            #[doc = "Bit 6 - Set 6"]
            #[inline(always)]
            #[must_use]
            pub fn set6(&mut self) -> SET6_W<GPSET0_SPEC, 6> {
                SET6_W::new(self)
            }
            #[doc = "Bit 7 - Set 7"]
            #[inline(always)]
            #[must_use]
            pub fn set7(&mut self) -> SET7_W<GPSET0_SPEC, 7> {
                SET7_W::new(self)
            }
            #[doc = "Bit 8 - Set 8"]
            #[inline(always)]
            #[must_use]
            pub fn set8(&mut self) -> SET8_W<GPSET0_SPEC, 8> {
                SET8_W::new(self)
            }
            #[doc = "Bit 9 - Set 9"]
            #[inline(always)]
            #[must_use]
            pub fn set9(&mut self) -> SET9_W<GPSET0_SPEC, 9> {
                SET9_W::new(self)
            }
            #[doc = "Bit 10 - Set 10"]
            #[inline(always)]
            #[must_use]
            pub fn set10(&mut self) -> SET10_W<GPSET0_SPEC, 10> {
                SET10_W::new(self)
            }
            #[doc = "Bit 11 - Set 11"]
            #[inline(always)]
            #[must_use]
            pub fn set11(&mut self) -> SET11_W<GPSET0_SPEC, 11> {
                SET11_W::new(self)
            }
            #[doc = "Bit 12 - Set 12"]
            #[inline(always)]
            #[must_use]
            pub fn set12(&mut self) -> SET12_W<GPSET0_SPEC, 12> {
                SET12_W::new(self)
            }
            #[doc = "Bit 13 - Set 13"]
            #[inline(always)]
            #[must_use]
            pub fn set13(&mut self) -> SET13_W<GPSET0_SPEC, 13> {
                SET13_W::new(self)
            }
            #[doc = "Bit 14 - Set 14"]
            #[inline(always)]
            #[must_use]
            pub fn set14(&mut self) -> SET14_W<GPSET0_SPEC, 14> {
                SET14_W::new(self)
            }
            #[doc = "Bit 15 - Set 15"]
            #[inline(always)]
            #[must_use]
            pub fn set15(&mut self) -> SET15_W<GPSET0_SPEC, 15> {
                SET15_W::new(self)
            }
            #[doc = "Bit 16 - Set 16"]
            #[inline(always)]
            #[must_use]
            pub fn set16(&mut self) -> SET16_W<GPSET0_SPEC, 16> {
                SET16_W::new(self)
            }
            #[doc = "Bit 17 - Set 17"]
            #[inline(always)]
            #[must_use]
            pub fn set17(&mut self) -> SET17_W<GPSET0_SPEC, 17> {
                SET17_W::new(self)
            }
            #[doc = "Bit 18 - Set 18"]
            #[inline(always)]
            #[must_use]
            pub fn set18(&mut self) -> SET18_W<GPSET0_SPEC, 18> {
                SET18_W::new(self)
            }
            #[doc = "Bit 19 - Set 19"]
            #[inline(always)]
            #[must_use]
            pub fn set19(&mut self) -> SET19_W<GPSET0_SPEC, 19> {
                SET19_W::new(self)
            }
            #[doc = "Bit 20 - Set 20"]
            #[inline(always)]
            #[must_use]
            pub fn set20(&mut self) -> SET20_W<GPSET0_SPEC, 20> {
                SET20_W::new(self)
            }
            #[doc = "Bit 21 - Set 21"]
            #[inline(always)]
            #[must_use]
            pub fn set21(&mut self) -> SET21_W<GPSET0_SPEC, 21> {
                SET21_W::new(self)
            }
            #[doc = "Bit 22 - Set 22"]
            #[inline(always)]
            #[must_use]
            pub fn set22(&mut self) -> SET22_W<GPSET0_SPEC, 22> {
                SET22_W::new(self)
            }
            #[doc = "Bit 23 - Set 23"]
            #[inline(always)]
            #[must_use]
            pub fn set23(&mut self) -> SET23_W<GPSET0_SPEC, 23> {
                SET23_W::new(self)
            }
            #[doc = "Bit 24 - Set 24"]
            #[inline(always)]
            #[must_use]
            pub fn set24(&mut self) -> SET24_W<GPSET0_SPEC, 24> {
                SET24_W::new(self)
            }
            #[doc = "Bit 25 - Set 25"]
            #[inline(always)]
            #[must_use]
            pub fn set25(&mut self) -> SET25_W<GPSET0_SPEC, 25> {
                SET25_W::new(self)
            }
            #[doc = "Bit 26 - Set 26"]
            #[inline(always)]
            #[must_use]
            pub fn set26(&mut self) -> SET26_W<GPSET0_SPEC, 26> {
                SET26_W::new(self)
            }
            #[doc = "Bit 27 - Set 27"]
            #[inline(always)]
            #[must_use]
            pub fn set27(&mut self) -> SET27_W<GPSET0_SPEC, 27> {
                SET27_W::new(self)
            }
            #[doc = "Bit 28 - Set 28"]
            #[inline(always)]
            #[must_use]
            pub fn set28(&mut self) -> SET28_W<GPSET0_SPEC, 28> {
                SET28_W::new(self)
            }
            #[doc = "Bit 29 - Set 29"]
            #[inline(always)]
            #[must_use]
            pub fn set29(&mut self) -> SET29_W<GPSET0_SPEC, 29> {
                SET29_W::new(self)
            }
            #[doc = "Bit 30 - Set 30"]
            #[inline(always)]
            #[must_use]
            pub fn set30(&mut self) -> SET30_W<GPSET0_SPEC, 30> {
                SET30_W::new(self)
            }
            #[doc = "Bit 31 - Set 31"]
            #[inline(always)]
            #[must_use]
            pub fn set31(&mut self) -> SET31_W<GPSET0_SPEC, 31> {
                SET31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Output Set 0\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpset0::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPSET0_SPEC;
        impl crate::RegisterSpec for GPSET0_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`gpset0::W`](W) writer structure"]
        impl crate::Writable for GPSET0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xffff_ffff;
        }
    }
    #[doc = "GPSET1 (w) register accessor: GPIO Pin Output Set 1\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpset1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpset1`]
module"]
    pub type GPSET1 = crate::Reg<gpset1::GPSET1_SPEC>;
    #[doc = "GPIO Pin Output Set 1"]
    pub mod gpset1 {
        #[doc = "Register `GPSET1` writer"]
        pub type W = crate::W<GPSET1_SPEC>;
        #[doc = "Field `SET32` writer - Set 32"]
        pub type SET32_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET33` writer - Set 33"]
        pub type SET33_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET34` writer - Set 34"]
        pub type SET34_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET35` writer - Set 35"]
        pub type SET35_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET36` writer - Set 36"]
        pub type SET36_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET37` writer - Set 37"]
        pub type SET37_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET38` writer - Set 38"]
        pub type SET38_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET39` writer - Set 39"]
        pub type SET39_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET40` writer - Set 40"]
        pub type SET40_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET41` writer - Set 41"]
        pub type SET41_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET42` writer - Set 42"]
        pub type SET42_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET43` writer - Set 43"]
        pub type SET43_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET44` writer - Set 44"]
        pub type SET44_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET45` writer - Set 45"]
        pub type SET45_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET46` writer - Set 46"]
        pub type SET46_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET47` writer - Set 47"]
        pub type SET47_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET48` writer - Set 48"]
        pub type SET48_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET49` writer - Set 49"]
        pub type SET49_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET50` writer - Set 50"]
        pub type SET50_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET51` writer - Set 51"]
        pub type SET51_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET52` writer - Set 52"]
        pub type SET52_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SET53` writer - Set 53"]
        pub type SET53_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        impl core::fmt::Debug for crate::generic::Reg<GPSET1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {
            #[doc = "Bit 0 - Set 32"]
            #[inline(always)]
            #[must_use]
            pub fn set32(&mut self) -> SET32_W<GPSET1_SPEC, 0> {
                SET32_W::new(self)
            }
            #[doc = "Bit 1 - Set 33"]
            #[inline(always)]
            #[must_use]
            pub fn set33(&mut self) -> SET33_W<GPSET1_SPEC, 1> {
                SET33_W::new(self)
            }
            #[doc = "Bit 2 - Set 34"]
            #[inline(always)]
            #[must_use]
            pub fn set34(&mut self) -> SET34_W<GPSET1_SPEC, 2> {
                SET34_W::new(self)
            }
            #[doc = "Bit 3 - Set 35"]
            #[inline(always)]
            #[must_use]
            pub fn set35(&mut self) -> SET35_W<GPSET1_SPEC, 3> {
                SET35_W::new(self)
            }
            #[doc = "Bit 4 - Set 36"]
            #[inline(always)]
            #[must_use]
            pub fn set36(&mut self) -> SET36_W<GPSET1_SPEC, 4> {
                SET36_W::new(self)
            }
            #[doc = "Bit 5 - Set 37"]
            #[inline(always)]
            #[must_use]
            pub fn set37(&mut self) -> SET37_W<GPSET1_SPEC, 5> {
                SET37_W::new(self)
            }
            #[doc = "Bit 6 - Set 38"]
            #[inline(always)]
            #[must_use]
            pub fn set38(&mut self) -> SET38_W<GPSET1_SPEC, 6> {
                SET38_W::new(self)
            }
            #[doc = "Bit 7 - Set 39"]
            #[inline(always)]
            #[must_use]
            pub fn set39(&mut self) -> SET39_W<GPSET1_SPEC, 7> {
                SET39_W::new(self)
            }
            #[doc = "Bit 8 - Set 40"]
            #[inline(always)]
            #[must_use]
            pub fn set40(&mut self) -> SET40_W<GPSET1_SPEC, 8> {
                SET40_W::new(self)
            }
            #[doc = "Bit 9 - Set 41"]
            #[inline(always)]
            #[must_use]
            pub fn set41(&mut self) -> SET41_W<GPSET1_SPEC, 9> {
                SET41_W::new(self)
            }
            #[doc = "Bit 10 - Set 42"]
            #[inline(always)]
            #[must_use]
            pub fn set42(&mut self) -> SET42_W<GPSET1_SPEC, 10> {
                SET42_W::new(self)
            }
            #[doc = "Bit 11 - Set 43"]
            #[inline(always)]
            #[must_use]
            pub fn set43(&mut self) -> SET43_W<GPSET1_SPEC, 11> {
                SET43_W::new(self)
            }
            #[doc = "Bit 12 - Set 44"]
            #[inline(always)]
            #[must_use]
            pub fn set44(&mut self) -> SET44_W<GPSET1_SPEC, 12> {
                SET44_W::new(self)
            }
            #[doc = "Bit 13 - Set 45"]
            #[inline(always)]
            #[must_use]
            pub fn set45(&mut self) -> SET45_W<GPSET1_SPEC, 13> {
                SET45_W::new(self)
            }
            #[doc = "Bit 14 - Set 46"]
            #[inline(always)]
            #[must_use]
            pub fn set46(&mut self) -> SET46_W<GPSET1_SPEC, 14> {
                SET46_W::new(self)
            }
            #[doc = "Bit 15 - Set 47"]
            #[inline(always)]
            #[must_use]
            pub fn set47(&mut self) -> SET47_W<GPSET1_SPEC, 15> {
                SET47_W::new(self)
            }
            #[doc = "Bit 16 - Set 48"]
            #[inline(always)]
            #[must_use]
            pub fn set48(&mut self) -> SET48_W<GPSET1_SPEC, 16> {
                SET48_W::new(self)
            }
            #[doc = "Bit 17 - Set 49"]
            #[inline(always)]
            #[must_use]
            pub fn set49(&mut self) -> SET49_W<GPSET1_SPEC, 17> {
                SET49_W::new(self)
            }
            #[doc = "Bit 18 - Set 50"]
            #[inline(always)]
            #[must_use]
            pub fn set50(&mut self) -> SET50_W<GPSET1_SPEC, 18> {
                SET50_W::new(self)
            }
            #[doc = "Bit 19 - Set 51"]
            #[inline(always)]
            #[must_use]
            pub fn set51(&mut self) -> SET51_W<GPSET1_SPEC, 19> {
                SET51_W::new(self)
            }
            #[doc = "Bit 20 - Set 52"]
            #[inline(always)]
            #[must_use]
            pub fn set52(&mut self) -> SET52_W<GPSET1_SPEC, 20> {
                SET52_W::new(self)
            }
            #[doc = "Bit 21 - Set 53"]
            #[inline(always)]
            #[must_use]
            pub fn set53(&mut self) -> SET53_W<GPSET1_SPEC, 21> {
                SET53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Output Set 1\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpset1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPSET1_SPEC;
        impl crate::RegisterSpec for GPSET1_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`gpset1::W`](W) writer structure"]
        impl crate::Writable for GPSET1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x003f_ffff;
        }
    }
    #[doc = "GPCLR0 (w) register accessor: GPIO Pin Output Clear 0\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpclr0::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpclr0`]
module"]
    pub type GPCLR0 = crate::Reg<gpclr0::GPCLR0_SPEC>;
    #[doc = "GPIO Pin Output Clear 0"]
    pub mod gpclr0 {
        #[doc = "Register `GPCLR0` writer"]
        pub type W = crate::W<GPCLR0_SPEC>;
        #[doc = "Field `CLR0` writer - Clear 0"]
        pub type CLR0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR1` writer - Clear 1"]
        pub type CLR1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR2` writer - Clear 2"]
        pub type CLR2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR3` writer - Clear 3"]
        pub type CLR3_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR4` writer - Clear 4"]
        pub type CLR4_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR5` writer - Clear 5"]
        pub type CLR5_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR6` writer - Clear 6"]
        pub type CLR6_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR7` writer - Clear 7"]
        pub type CLR7_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR8` writer - Clear 8"]
        pub type CLR8_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR9` writer - Clear 9"]
        pub type CLR9_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR10` writer - Clear 10"]
        pub type CLR10_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR11` writer - Clear 11"]
        pub type CLR11_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR12` writer - Clear 12"]
        pub type CLR12_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR13` writer - Clear 13"]
        pub type CLR13_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR14` writer - Clear 14"]
        pub type CLR14_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR15` writer - Clear 15"]
        pub type CLR15_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR16` writer - Clear 16"]
        pub type CLR16_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR17` writer - Clear 17"]
        pub type CLR17_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR18` writer - Clear 18"]
        pub type CLR18_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR19` writer - Clear 19"]
        pub type CLR19_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR20` writer - Clear 20"]
        pub type CLR20_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR21` writer - Clear 21"]
        pub type CLR21_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR22` writer - Clear 22"]
        pub type CLR22_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR23` writer - Clear 23"]
        pub type CLR23_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR24` writer - Clear 24"]
        pub type CLR24_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR25` writer - Clear 25"]
        pub type CLR25_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR26` writer - Clear 26"]
        pub type CLR26_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR27` writer - Clear 27"]
        pub type CLR27_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR28` writer - Clear 28"]
        pub type CLR28_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR29` writer - Clear 29"]
        pub type CLR29_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR30` writer - Clear 30"]
        pub type CLR30_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR31` writer - Clear 31"]
        pub type CLR31_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl core::fmt::Debug for crate::generic::Reg<GPCLR0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {
            #[doc = "Bit 0 - Clear 0"]
            #[inline(always)]
            #[must_use]
            pub fn clr0(&mut self) -> CLR0_W<GPCLR0_SPEC, 0> {
                CLR0_W::new(self)
            }
            #[doc = "Bit 1 - Clear 1"]
            #[inline(always)]
            #[must_use]
            pub fn clr1(&mut self) -> CLR1_W<GPCLR0_SPEC, 1> {
                CLR1_W::new(self)
            }
            #[doc = "Bit 2 - Clear 2"]
            #[inline(always)]
            #[must_use]
            pub fn clr2(&mut self) -> CLR2_W<GPCLR0_SPEC, 2> {
                CLR2_W::new(self)
            }
            #[doc = "Bit 3 - Clear 3"]
            #[inline(always)]
            #[must_use]
            pub fn clr3(&mut self) -> CLR3_W<GPCLR0_SPEC, 3> {
                CLR3_W::new(self)
            }
            #[doc = "Bit 4 - Clear 4"]
            #[inline(always)]
            #[must_use]
            pub fn clr4(&mut self) -> CLR4_W<GPCLR0_SPEC, 4> {
                CLR4_W::new(self)
            }
            #[doc = "Bit 5 - Clear 5"]
            #[inline(always)]
            #[must_use]
            pub fn clr5(&mut self) -> CLR5_W<GPCLR0_SPEC, 5> {
                CLR5_W::new(self)
            }
            #[doc = "Bit 6 - Clear 6"]
            #[inline(always)]
            #[must_use]
            pub fn clr6(&mut self) -> CLR6_W<GPCLR0_SPEC, 6> {
                CLR6_W::new(self)
            }
            #[doc = "Bit 7 - Clear 7"]
            #[inline(always)]
            #[must_use]
            pub fn clr7(&mut self) -> CLR7_W<GPCLR0_SPEC, 7> {
                CLR7_W::new(self)
            }
            #[doc = "Bit 8 - Clear 8"]
            #[inline(always)]
            #[must_use]
            pub fn clr8(&mut self) -> CLR8_W<GPCLR0_SPEC, 8> {
                CLR8_W::new(self)
            }
            #[doc = "Bit 9 - Clear 9"]
            #[inline(always)]
            #[must_use]
            pub fn clr9(&mut self) -> CLR9_W<GPCLR0_SPEC, 9> {
                CLR9_W::new(self)
            }
            #[doc = "Bit 10 - Clear 10"]
            #[inline(always)]
            #[must_use]
            pub fn clr10(&mut self) -> CLR10_W<GPCLR0_SPEC, 10> {
                CLR10_W::new(self)
            }
            #[doc = "Bit 11 - Clear 11"]
            #[inline(always)]
            #[must_use]
            pub fn clr11(&mut self) -> CLR11_W<GPCLR0_SPEC, 11> {
                CLR11_W::new(self)
            }
            #[doc = "Bit 12 - Clear 12"]
            #[inline(always)]
            #[must_use]
            pub fn clr12(&mut self) -> CLR12_W<GPCLR0_SPEC, 12> {
                CLR12_W::new(self)
            }
            #[doc = "Bit 13 - Clear 13"]
            #[inline(always)]
            #[must_use]
            pub fn clr13(&mut self) -> CLR13_W<GPCLR0_SPEC, 13> {
                CLR13_W::new(self)
            }
            #[doc = "Bit 14 - Clear 14"]
            #[inline(always)]
            #[must_use]
            pub fn clr14(&mut self) -> CLR14_W<GPCLR0_SPEC, 14> {
                CLR14_W::new(self)
            }
            #[doc = "Bit 15 - Clear 15"]
            #[inline(always)]
            #[must_use]
            pub fn clr15(&mut self) -> CLR15_W<GPCLR0_SPEC, 15> {
                CLR15_W::new(self)
            }
            #[doc = "Bit 16 - Clear 16"]
            #[inline(always)]
            #[must_use]
            pub fn clr16(&mut self) -> CLR16_W<GPCLR0_SPEC, 16> {
                CLR16_W::new(self)
            }
            #[doc = "Bit 17 - Clear 17"]
            #[inline(always)]
            #[must_use]
            pub fn clr17(&mut self) -> CLR17_W<GPCLR0_SPEC, 17> {
                CLR17_W::new(self)
            }
            #[doc = "Bit 18 - Clear 18"]
            #[inline(always)]
            #[must_use]
            pub fn clr18(&mut self) -> CLR18_W<GPCLR0_SPEC, 18> {
                CLR18_W::new(self)
            }
            #[doc = "Bit 19 - Clear 19"]
            #[inline(always)]
            #[must_use]
            pub fn clr19(&mut self) -> CLR19_W<GPCLR0_SPEC, 19> {
                CLR19_W::new(self)
            }
            #[doc = "Bit 20 - Clear 20"]
            #[inline(always)]
            #[must_use]
            pub fn clr20(&mut self) -> CLR20_W<GPCLR0_SPEC, 20> {
                CLR20_W::new(self)
            }
            #[doc = "Bit 21 - Clear 21"]
            #[inline(always)]
            #[must_use]
            pub fn clr21(&mut self) -> CLR21_W<GPCLR0_SPEC, 21> {
                CLR21_W::new(self)
            }
            #[doc = "Bit 22 - Clear 22"]
            #[inline(always)]
            #[must_use]
            pub fn clr22(&mut self) -> CLR22_W<GPCLR0_SPEC, 22> {
                CLR22_W::new(self)
            }
            #[doc = "Bit 23 - Clear 23"]
            #[inline(always)]
            #[must_use]
            pub fn clr23(&mut self) -> CLR23_W<GPCLR0_SPEC, 23> {
                CLR23_W::new(self)
            }
            #[doc = "Bit 24 - Clear 24"]
            #[inline(always)]
            #[must_use]
            pub fn clr24(&mut self) -> CLR24_W<GPCLR0_SPEC, 24> {
                CLR24_W::new(self)
            }
            #[doc = "Bit 25 - Clear 25"]
            #[inline(always)]
            #[must_use]
            pub fn clr25(&mut self) -> CLR25_W<GPCLR0_SPEC, 25> {
                CLR25_W::new(self)
            }
            #[doc = "Bit 26 - Clear 26"]
            #[inline(always)]
            #[must_use]
            pub fn clr26(&mut self) -> CLR26_W<GPCLR0_SPEC, 26> {
                CLR26_W::new(self)
            }
            #[doc = "Bit 27 - Clear 27"]
            #[inline(always)]
            #[must_use]
            pub fn clr27(&mut self) -> CLR27_W<GPCLR0_SPEC, 27> {
                CLR27_W::new(self)
            }
            #[doc = "Bit 28 - Clear 28"]
            #[inline(always)]
            #[must_use]
            pub fn clr28(&mut self) -> CLR28_W<GPCLR0_SPEC, 28> {
                CLR28_W::new(self)
            }
            #[doc = "Bit 29 - Clear 29"]
            #[inline(always)]
            #[must_use]
            pub fn clr29(&mut self) -> CLR29_W<GPCLR0_SPEC, 29> {
                CLR29_W::new(self)
            }
            #[doc = "Bit 30 - Clear 30"]
            #[inline(always)]
            #[must_use]
            pub fn clr30(&mut self) -> CLR30_W<GPCLR0_SPEC, 30> {
                CLR30_W::new(self)
            }
            #[doc = "Bit 31 - Clear 31"]
            #[inline(always)]
            #[must_use]
            pub fn clr31(&mut self) -> CLR31_W<GPCLR0_SPEC, 31> {
                CLR31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Output Clear 0\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpclr0::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPCLR0_SPEC;
        impl crate::RegisterSpec for GPCLR0_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`gpclr0::W`](W) writer structure"]
        impl crate::Writable for GPCLR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xffff_ffff;
        }
    }
    #[doc = "GPCLR1 (w) register accessor: GPIO Pin Output Clear 1\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpclr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpclr1`]
module"]
    pub type GPCLR1 = crate::Reg<gpclr1::GPCLR1_SPEC>;
    #[doc = "GPIO Pin Output Clear 1"]
    pub mod gpclr1 {
        #[doc = "Register `GPCLR1` writer"]
        pub type W = crate::W<GPCLR1_SPEC>;
        #[doc = "Field `CLR32` writer - Clear 32"]
        pub type CLR32_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR33` writer - Clear 33"]
        pub type CLR33_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR34` writer - Clear 34"]
        pub type CLR34_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR35` writer - Clear 35"]
        pub type CLR35_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR36` writer - Clear 36"]
        pub type CLR36_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR37` writer - Clear 37"]
        pub type CLR37_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR38` writer - Clear 38"]
        pub type CLR38_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR39` writer - Clear 39"]
        pub type CLR39_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR40` writer - Clear 40"]
        pub type CLR40_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR41` writer - Clear 41"]
        pub type CLR41_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR42` writer - Clear 42"]
        pub type CLR42_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR43` writer - Clear 43"]
        pub type CLR43_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR44` writer - Clear 44"]
        pub type CLR44_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR45` writer - Clear 45"]
        pub type CLR45_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR46` writer - Clear 46"]
        pub type CLR46_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR47` writer - Clear 47"]
        pub type CLR47_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR48` writer - Clear 48"]
        pub type CLR48_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR49` writer - Clear 49"]
        pub type CLR49_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR50` writer - Clear 50"]
        pub type CLR50_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR51` writer - Clear 51"]
        pub type CLR51_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR52` writer - Clear 52"]
        pub type CLR52_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLR53` writer - Clear 53"]
        pub type CLR53_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl core::fmt::Debug for crate::generic::Reg<GPCLR1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {
            #[doc = "Bit 0 - Clear 32"]
            #[inline(always)]
            #[must_use]
            pub fn clr32(&mut self) -> CLR32_W<GPCLR1_SPEC, 0> {
                CLR32_W::new(self)
            }
            #[doc = "Bit 1 - Clear 33"]
            #[inline(always)]
            #[must_use]
            pub fn clr33(&mut self) -> CLR33_W<GPCLR1_SPEC, 1> {
                CLR33_W::new(self)
            }
            #[doc = "Bit 2 - Clear 34"]
            #[inline(always)]
            #[must_use]
            pub fn clr34(&mut self) -> CLR34_W<GPCLR1_SPEC, 2> {
                CLR34_W::new(self)
            }
            #[doc = "Bit 3 - Clear 35"]
            #[inline(always)]
            #[must_use]
            pub fn clr35(&mut self) -> CLR35_W<GPCLR1_SPEC, 3> {
                CLR35_W::new(self)
            }
            #[doc = "Bit 4 - Clear 36"]
            #[inline(always)]
            #[must_use]
            pub fn clr36(&mut self) -> CLR36_W<GPCLR1_SPEC, 4> {
                CLR36_W::new(self)
            }
            #[doc = "Bit 5 - Clear 37"]
            #[inline(always)]
            #[must_use]
            pub fn clr37(&mut self) -> CLR37_W<GPCLR1_SPEC, 5> {
                CLR37_W::new(self)
            }
            #[doc = "Bit 6 - Clear 38"]
            #[inline(always)]
            #[must_use]
            pub fn clr38(&mut self) -> CLR38_W<GPCLR1_SPEC, 6> {
                CLR38_W::new(self)
            }
            #[doc = "Bit 7 - Clear 39"]
            #[inline(always)]
            #[must_use]
            pub fn clr39(&mut self) -> CLR39_W<GPCLR1_SPEC, 7> {
                CLR39_W::new(self)
            }
            #[doc = "Bit 8 - Clear 40"]
            #[inline(always)]
            #[must_use]
            pub fn clr40(&mut self) -> CLR40_W<GPCLR1_SPEC, 8> {
                CLR40_W::new(self)
            }
            #[doc = "Bit 9 - Clear 41"]
            #[inline(always)]
            #[must_use]
            pub fn clr41(&mut self) -> CLR41_W<GPCLR1_SPEC, 9> {
                CLR41_W::new(self)
            }
            #[doc = "Bit 10 - Clear 42"]
            #[inline(always)]
            #[must_use]
            pub fn clr42(&mut self) -> CLR42_W<GPCLR1_SPEC, 10> {
                CLR42_W::new(self)
            }
            #[doc = "Bit 11 - Clear 43"]
            #[inline(always)]
            #[must_use]
            pub fn clr43(&mut self) -> CLR43_W<GPCLR1_SPEC, 11> {
                CLR43_W::new(self)
            }
            #[doc = "Bit 12 - Clear 44"]
            #[inline(always)]
            #[must_use]
            pub fn clr44(&mut self) -> CLR44_W<GPCLR1_SPEC, 12> {
                CLR44_W::new(self)
            }
            #[doc = "Bit 13 - Clear 45"]
            #[inline(always)]
            #[must_use]
            pub fn clr45(&mut self) -> CLR45_W<GPCLR1_SPEC, 13> {
                CLR45_W::new(self)
            }
            #[doc = "Bit 14 - Clear 46"]
            #[inline(always)]
            #[must_use]
            pub fn clr46(&mut self) -> CLR46_W<GPCLR1_SPEC, 14> {
                CLR46_W::new(self)
            }
            #[doc = "Bit 15 - Clear 47"]
            #[inline(always)]
            #[must_use]
            pub fn clr47(&mut self) -> CLR47_W<GPCLR1_SPEC, 15> {
                CLR47_W::new(self)
            }
            #[doc = "Bit 16 - Clear 48"]
            #[inline(always)]
            #[must_use]
            pub fn clr48(&mut self) -> CLR48_W<GPCLR1_SPEC, 16> {
                CLR48_W::new(self)
            }
            #[doc = "Bit 17 - Clear 49"]
            #[inline(always)]
            #[must_use]
            pub fn clr49(&mut self) -> CLR49_W<GPCLR1_SPEC, 17> {
                CLR49_W::new(self)
            }
            #[doc = "Bit 18 - Clear 50"]
            #[inline(always)]
            #[must_use]
            pub fn clr50(&mut self) -> CLR50_W<GPCLR1_SPEC, 18> {
                CLR50_W::new(self)
            }
            #[doc = "Bit 19 - Clear 51"]
            #[inline(always)]
            #[must_use]
            pub fn clr51(&mut self) -> CLR51_W<GPCLR1_SPEC, 19> {
                CLR51_W::new(self)
            }
            #[doc = "Bit 20 - Clear 52"]
            #[inline(always)]
            #[must_use]
            pub fn clr52(&mut self) -> CLR52_W<GPCLR1_SPEC, 20> {
                CLR52_W::new(self)
            }
            #[doc = "Bit 21 - Clear 53"]
            #[inline(always)]
            #[must_use]
            pub fn clr53(&mut self) -> CLR53_W<GPCLR1_SPEC, 21> {
                CLR53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Output Clear 1\n\nYou can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpclr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPCLR1_SPEC;
        impl crate::RegisterSpec for GPCLR1_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`gpclr1::W`](W) writer structure"]
        impl crate::Writable for GPCLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x003f_ffff;
        }
    }
    #[doc = "GPLEV0 (r) register accessor: GPIO Pin Level 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gplev0::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gplev0`]
module"]
    pub type GPLEV0 = crate::Reg<gplev0::GPLEV0_SPEC>;
    #[doc = "GPIO Pin Level 0"]
    pub mod gplev0 {
        #[doc = "Register `GPLEV0` reader"]
        pub type R = crate::R<GPLEV0_SPEC>;
        #[doc = "Field `LEV0` reader - Level 0"]
        pub type LEV0_R = crate::BitReader;
        #[doc = "Field `LEV1` reader - Level 1"]
        pub type LEV1_R = crate::BitReader;
        #[doc = "Field `LEV2` reader - Level 2"]
        pub type LEV2_R = crate::BitReader;
        #[doc = "Field `LEV3` reader - Level 3"]
        pub type LEV3_R = crate::BitReader;
        #[doc = "Field `LEV4` reader - Level 4"]
        pub type LEV4_R = crate::BitReader;
        #[doc = "Field `LEV5` reader - Level 5"]
        pub type LEV5_R = crate::BitReader;
        #[doc = "Field `LEV6` reader - Level 6"]
        pub type LEV6_R = crate::BitReader;
        #[doc = "Field `LEV7` reader - Level 7"]
        pub type LEV7_R = crate::BitReader;
        #[doc = "Field `LEV8` reader - Level 8"]
        pub type LEV8_R = crate::BitReader;
        #[doc = "Field `LEV9` reader - Level 9"]
        pub type LEV9_R = crate::BitReader;
        #[doc = "Field `LEV10` reader - Level 10"]
        pub type LEV10_R = crate::BitReader;
        #[doc = "Field `LEV11` reader - Level 11"]
        pub type LEV11_R = crate::BitReader;
        #[doc = "Field `LEV12` reader - Level 12"]
        pub type LEV12_R = crate::BitReader;
        #[doc = "Field `LEV13` reader - Level 13"]
        pub type LEV13_R = crate::BitReader;
        #[doc = "Field `LEV14` reader - Level 14"]
        pub type LEV14_R = crate::BitReader;
        #[doc = "Field `LEV15` reader - Level 15"]
        pub type LEV15_R = crate::BitReader;
        #[doc = "Field `LEV16` reader - Level 16"]
        pub type LEV16_R = crate::BitReader;
        #[doc = "Field `LEV17` reader - Level 17"]
        pub type LEV17_R = crate::BitReader;
        #[doc = "Field `LEV18` reader - Level 18"]
        pub type LEV18_R = crate::BitReader;
        #[doc = "Field `LEV19` reader - Level 19"]
        pub type LEV19_R = crate::BitReader;
        #[doc = "Field `LEV20` reader - Level 20"]
        pub type LEV20_R = crate::BitReader;
        #[doc = "Field `LEV21` reader - Level 21"]
        pub type LEV21_R = crate::BitReader;
        #[doc = "Field `LEV22` reader - Level 22"]
        pub type LEV22_R = crate::BitReader;
        #[doc = "Field `LEV23` reader - Level 23"]
        pub type LEV23_R = crate::BitReader;
        #[doc = "Field `LEV24` reader - Level 24"]
        pub type LEV24_R = crate::BitReader;
        #[doc = "Field `LEV25` reader - Level 25"]
        pub type LEV25_R = crate::BitReader;
        #[doc = "Field `LEV26` reader - Level 26"]
        pub type LEV26_R = crate::BitReader;
        #[doc = "Field `LEV27` reader - Level 27"]
        pub type LEV27_R = crate::BitReader;
        #[doc = "Field `LEV28` reader - Level 28"]
        pub type LEV28_R = crate::BitReader;
        #[doc = "Field `LEV29` reader - Level 29"]
        pub type LEV29_R = crate::BitReader;
        #[doc = "Field `LEV30` reader - Level 30"]
        pub type LEV30_R = crate::BitReader;
        #[doc = "Field `LEV31` reader - Level 31"]
        pub type LEV31_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Level 0"]
            #[inline(always)]
            pub fn lev0(&self) -> LEV0_R {
                LEV0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Level 1"]
            #[inline(always)]
            pub fn lev1(&self) -> LEV1_R {
                LEV1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Level 2"]
            #[inline(always)]
            pub fn lev2(&self) -> LEV2_R {
                LEV2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Level 3"]
            #[inline(always)]
            pub fn lev3(&self) -> LEV3_R {
                LEV3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Level 4"]
            #[inline(always)]
            pub fn lev4(&self) -> LEV4_R {
                LEV4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Level 5"]
            #[inline(always)]
            pub fn lev5(&self) -> LEV5_R {
                LEV5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Level 6"]
            #[inline(always)]
            pub fn lev6(&self) -> LEV6_R {
                LEV6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Level 7"]
            #[inline(always)]
            pub fn lev7(&self) -> LEV7_R {
                LEV7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Level 8"]
            #[inline(always)]
            pub fn lev8(&self) -> LEV8_R {
                LEV8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Level 9"]
            #[inline(always)]
            pub fn lev9(&self) -> LEV9_R {
                LEV9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Level 10"]
            #[inline(always)]
            pub fn lev10(&self) -> LEV10_R {
                LEV10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Level 11"]
            #[inline(always)]
            pub fn lev11(&self) -> LEV11_R {
                LEV11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Level 12"]
            #[inline(always)]
            pub fn lev12(&self) -> LEV12_R {
                LEV12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Level 13"]
            #[inline(always)]
            pub fn lev13(&self) -> LEV13_R {
                LEV13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Level 14"]
            #[inline(always)]
            pub fn lev14(&self) -> LEV14_R {
                LEV14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Level 15"]
            #[inline(always)]
            pub fn lev15(&self) -> LEV15_R {
                LEV15_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Level 16"]
            #[inline(always)]
            pub fn lev16(&self) -> LEV16_R {
                LEV16_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Level 17"]
            #[inline(always)]
            pub fn lev17(&self) -> LEV17_R {
                LEV17_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Level 18"]
            #[inline(always)]
            pub fn lev18(&self) -> LEV18_R {
                LEV18_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Level 19"]
            #[inline(always)]
            pub fn lev19(&self) -> LEV19_R {
                LEV19_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Level 20"]
            #[inline(always)]
            pub fn lev20(&self) -> LEV20_R {
                LEV20_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Level 21"]
            #[inline(always)]
            pub fn lev21(&self) -> LEV21_R {
                LEV21_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Level 22"]
            #[inline(always)]
            pub fn lev22(&self) -> LEV22_R {
                LEV22_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Level 23"]
            #[inline(always)]
            pub fn lev23(&self) -> LEV23_R {
                LEV23_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Level 24"]
            #[inline(always)]
            pub fn lev24(&self) -> LEV24_R {
                LEV24_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Level 25"]
            #[inline(always)]
            pub fn lev25(&self) -> LEV25_R {
                LEV25_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Level 26"]
            #[inline(always)]
            pub fn lev26(&self) -> LEV26_R {
                LEV26_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Level 27"]
            #[inline(always)]
            pub fn lev27(&self) -> LEV27_R {
                LEV27_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - Level 28"]
            #[inline(always)]
            pub fn lev28(&self) -> LEV28_R {
                LEV28_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Level 29"]
            #[inline(always)]
            pub fn lev29(&self) -> LEV29_R {
                LEV29_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Level 30"]
            #[inline(always)]
            pub fn lev30(&self) -> LEV30_R {
                LEV30_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Level 31"]
            #[inline(always)]
            pub fn lev31(&self) -> LEV31_R {
                LEV31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPLEV0")
                    .field("lev0", &format_args!("{}", self.lev0().bit()))
                    .field("lev1", &format_args!("{}", self.lev1().bit()))
                    .field("lev2", &format_args!("{}", self.lev2().bit()))
                    .field("lev3", &format_args!("{}", self.lev3().bit()))
                    .field("lev4", &format_args!("{}", self.lev4().bit()))
                    .field("lev5", &format_args!("{}", self.lev5().bit()))
                    .field("lev6", &format_args!("{}", self.lev6().bit()))
                    .field("lev7", &format_args!("{}", self.lev7().bit()))
                    .field("lev8", &format_args!("{}", self.lev8().bit()))
                    .field("lev9", &format_args!("{}", self.lev9().bit()))
                    .field("lev10", &format_args!("{}", self.lev10().bit()))
                    .field("lev11", &format_args!("{}", self.lev11().bit()))
                    .field("lev12", &format_args!("{}", self.lev12().bit()))
                    .field("lev13", &format_args!("{}", self.lev13().bit()))
                    .field("lev14", &format_args!("{}", self.lev14().bit()))
                    .field("lev15", &format_args!("{}", self.lev15().bit()))
                    .field("lev16", &format_args!("{}", self.lev16().bit()))
                    .field("lev17", &format_args!("{}", self.lev17().bit()))
                    .field("lev18", &format_args!("{}", self.lev18().bit()))
                    .field("lev19", &format_args!("{}", self.lev19().bit()))
                    .field("lev20", &format_args!("{}", self.lev20().bit()))
                    .field("lev21", &format_args!("{}", self.lev21().bit()))
                    .field("lev22", &format_args!("{}", self.lev22().bit()))
                    .field("lev23", &format_args!("{}", self.lev23().bit()))
                    .field("lev24", &format_args!("{}", self.lev24().bit()))
                    .field("lev25", &format_args!("{}", self.lev25().bit()))
                    .field("lev26", &format_args!("{}", self.lev26().bit()))
                    .field("lev27", &format_args!("{}", self.lev27().bit()))
                    .field("lev28", &format_args!("{}", self.lev28().bit()))
                    .field("lev29", &format_args!("{}", self.lev29().bit()))
                    .field("lev30", &format_args!("{}", self.lev30().bit()))
                    .field("lev31", &format_args!("{}", self.lev31().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPLEV0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "GPIO Pin Level 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gplev0::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPLEV0_SPEC;
        impl crate::RegisterSpec for GPLEV0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gplev0::R`](R) reader structure"]
        impl crate::Readable for GPLEV0_SPEC {}
    }
    #[doc = "GPLEV1 (r) register accessor: GPIO Pin Level 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gplev1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gplev1`]
module"]
    pub type GPLEV1 = crate::Reg<gplev1::GPLEV1_SPEC>;
    #[doc = "GPIO Pin Level 1"]
    pub mod gplev1 {
        #[doc = "Register `GPLEV1` reader"]
        pub type R = crate::R<GPLEV1_SPEC>;
        #[doc = "Field `LEV32` reader - Level 32"]
        pub type LEV32_R = crate::BitReader;
        #[doc = "Field `LEV33` reader - Level 33"]
        pub type LEV33_R = crate::BitReader;
        #[doc = "Field `LEV34` reader - Level 34"]
        pub type LEV34_R = crate::BitReader;
        #[doc = "Field `LEV35` reader - Level 35"]
        pub type LEV35_R = crate::BitReader;
        #[doc = "Field `LEV36` reader - Level 36"]
        pub type LEV36_R = crate::BitReader;
        #[doc = "Field `LEV37` reader - Level 37"]
        pub type LEV37_R = crate::BitReader;
        #[doc = "Field `LEV38` reader - Level 38"]
        pub type LEV38_R = crate::BitReader;
        #[doc = "Field `LEV39` reader - Level 39"]
        pub type LEV39_R = crate::BitReader;
        #[doc = "Field `LEV40` reader - Level 40"]
        pub type LEV40_R = crate::BitReader;
        #[doc = "Field `LEV41` reader - Level 41"]
        pub type LEV41_R = crate::BitReader;
        #[doc = "Field `LEV42` reader - Level 42"]
        pub type LEV42_R = crate::BitReader;
        #[doc = "Field `LEV43` reader - Level 43"]
        pub type LEV43_R = crate::BitReader;
        #[doc = "Field `LEV44` reader - Level 44"]
        pub type LEV44_R = crate::BitReader;
        #[doc = "Field `LEV45` reader - Level 45"]
        pub type LEV45_R = crate::BitReader;
        #[doc = "Field `LEV46` reader - Level 46"]
        pub type LEV46_R = crate::BitReader;
        #[doc = "Field `LEV47` reader - Level 47"]
        pub type LEV47_R = crate::BitReader;
        #[doc = "Field `LEV48` reader - Level 48"]
        pub type LEV48_R = crate::BitReader;
        #[doc = "Field `LEV49` reader - Level 49"]
        pub type LEV49_R = crate::BitReader;
        #[doc = "Field `LEV50` reader - Level 50"]
        pub type LEV50_R = crate::BitReader;
        #[doc = "Field `LEV51` reader - Level 51"]
        pub type LEV51_R = crate::BitReader;
        #[doc = "Field `LEV52` reader - Level 52"]
        pub type LEV52_R = crate::BitReader;
        #[doc = "Field `LEV53` reader - Level 53"]
        pub type LEV53_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Level 32"]
            #[inline(always)]
            pub fn lev32(&self) -> LEV32_R {
                LEV32_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Level 33"]
            #[inline(always)]
            pub fn lev33(&self) -> LEV33_R {
                LEV33_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Level 34"]
            #[inline(always)]
            pub fn lev34(&self) -> LEV34_R {
                LEV34_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Level 35"]
            #[inline(always)]
            pub fn lev35(&self) -> LEV35_R {
                LEV35_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Level 36"]
            #[inline(always)]
            pub fn lev36(&self) -> LEV36_R {
                LEV36_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Level 37"]
            #[inline(always)]
            pub fn lev37(&self) -> LEV37_R {
                LEV37_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Level 38"]
            #[inline(always)]
            pub fn lev38(&self) -> LEV38_R {
                LEV38_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Level 39"]
            #[inline(always)]
            pub fn lev39(&self) -> LEV39_R {
                LEV39_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Level 40"]
            #[inline(always)]
            pub fn lev40(&self) -> LEV40_R {
                LEV40_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Level 41"]
            #[inline(always)]
            pub fn lev41(&self) -> LEV41_R {
                LEV41_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Level 42"]
            #[inline(always)]
            pub fn lev42(&self) -> LEV42_R {
                LEV42_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Level 43"]
            #[inline(always)]
            pub fn lev43(&self) -> LEV43_R {
                LEV43_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Level 44"]
            #[inline(always)]
            pub fn lev44(&self) -> LEV44_R {
                LEV44_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Level 45"]
            #[inline(always)]
            pub fn lev45(&self) -> LEV45_R {
                LEV45_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Level 46"]
            #[inline(always)]
            pub fn lev46(&self) -> LEV46_R {
                LEV46_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Level 47"]
            #[inline(always)]
            pub fn lev47(&self) -> LEV47_R {
                LEV47_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Level 48"]
            #[inline(always)]
            pub fn lev48(&self) -> LEV48_R {
                LEV48_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Level 49"]
            #[inline(always)]
            pub fn lev49(&self) -> LEV49_R {
                LEV49_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Level 50"]
            #[inline(always)]
            pub fn lev50(&self) -> LEV50_R {
                LEV50_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Level 51"]
            #[inline(always)]
            pub fn lev51(&self) -> LEV51_R {
                LEV51_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Level 52"]
            #[inline(always)]
            pub fn lev52(&self) -> LEV52_R {
                LEV52_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Level 53"]
            #[inline(always)]
            pub fn lev53(&self) -> LEV53_R {
                LEV53_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPLEV1")
                    .field("lev32", &format_args!("{}", self.lev32().bit()))
                    .field("lev33", &format_args!("{}", self.lev33().bit()))
                    .field("lev34", &format_args!("{}", self.lev34().bit()))
                    .field("lev35", &format_args!("{}", self.lev35().bit()))
                    .field("lev36", &format_args!("{}", self.lev36().bit()))
                    .field("lev37", &format_args!("{}", self.lev37().bit()))
                    .field("lev38", &format_args!("{}", self.lev38().bit()))
                    .field("lev39", &format_args!("{}", self.lev39().bit()))
                    .field("lev40", &format_args!("{}", self.lev40().bit()))
                    .field("lev41", &format_args!("{}", self.lev41().bit()))
                    .field("lev42", &format_args!("{}", self.lev42().bit()))
                    .field("lev43", &format_args!("{}", self.lev43().bit()))
                    .field("lev44", &format_args!("{}", self.lev44().bit()))
                    .field("lev45", &format_args!("{}", self.lev45().bit()))
                    .field("lev46", &format_args!("{}", self.lev46().bit()))
                    .field("lev47", &format_args!("{}", self.lev47().bit()))
                    .field("lev48", &format_args!("{}", self.lev48().bit()))
                    .field("lev49", &format_args!("{}", self.lev49().bit()))
                    .field("lev50", &format_args!("{}", self.lev50().bit()))
                    .field("lev51", &format_args!("{}", self.lev51().bit()))
                    .field("lev52", &format_args!("{}", self.lev52().bit()))
                    .field("lev53", &format_args!("{}", self.lev53().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPLEV1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "GPIO Pin Level 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gplev1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPLEV1_SPEC;
        impl crate::RegisterSpec for GPLEV1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gplev1::R`](R) reader structure"]
        impl crate::Readable for GPLEV1_SPEC {}
    }
    #[doc = "GPEDS0 (rw) register accessor: GPIO Pin Event Detect Status 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpeds0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpeds0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpeds0`]
module"]
    pub type GPEDS0 = crate::Reg<gpeds0::GPEDS0_SPEC>;
    #[doc = "GPIO Pin Event Detect Status 0"]
    pub mod gpeds0 {
        #[doc = "Register `GPEDS0` reader"]
        pub type R = crate::R<GPEDS0_SPEC>;
        #[doc = "Register `GPEDS0` writer"]
        pub type W = crate::W<GPEDS0_SPEC>;
        #[doc = "Field `EDS0` reader - Event detected 0"]
        pub type EDS0_R = crate::BitReader;
        #[doc = "Field `EDS0` writer - Event detected 0"]
        pub type EDS0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS1` reader - Event detected 1"]
        pub type EDS1_R = crate::BitReader;
        #[doc = "Field `EDS1` writer - Event detected 1"]
        pub type EDS1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS2` reader - Event detected 2"]
        pub type EDS2_R = crate::BitReader;
        #[doc = "Field `EDS2` writer - Event detected 2"]
        pub type EDS2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS3` reader - Event detected 3"]
        pub type EDS3_R = crate::BitReader;
        #[doc = "Field `EDS3` writer - Event detected 3"]
        pub type EDS3_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS4` reader - Event detected 4"]
        pub type EDS4_R = crate::BitReader;
        #[doc = "Field `EDS4` writer - Event detected 4"]
        pub type EDS4_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS5` reader - Event detected 5"]
        pub type EDS5_R = crate::BitReader;
        #[doc = "Field `EDS5` writer - Event detected 5"]
        pub type EDS5_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS6` reader - Event detected 6"]
        pub type EDS6_R = crate::BitReader;
        #[doc = "Field `EDS6` writer - Event detected 6"]
        pub type EDS6_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS7` reader - Event detected 7"]
        pub type EDS7_R = crate::BitReader;
        #[doc = "Field `EDS7` writer - Event detected 7"]
        pub type EDS7_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS8` reader - Event detected 8"]
        pub type EDS8_R = crate::BitReader;
        #[doc = "Field `EDS8` writer - Event detected 8"]
        pub type EDS8_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS9` reader - Event detected 9"]
        pub type EDS9_R = crate::BitReader;
        #[doc = "Field `EDS9` writer - Event detected 9"]
        pub type EDS9_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS10` reader - Event detected 10"]
        pub type EDS10_R = crate::BitReader;
        #[doc = "Field `EDS10` writer - Event detected 10"]
        pub type EDS10_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS11` reader - Event detected 11"]
        pub type EDS11_R = crate::BitReader;
        #[doc = "Field `EDS11` writer - Event detected 11"]
        pub type EDS11_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS12` reader - Event detected 12"]
        pub type EDS12_R = crate::BitReader;
        #[doc = "Field `EDS12` writer - Event detected 12"]
        pub type EDS12_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS13` reader - Event detected 13"]
        pub type EDS13_R = crate::BitReader;
        #[doc = "Field `EDS13` writer - Event detected 13"]
        pub type EDS13_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS14` reader - Event detected 14"]
        pub type EDS14_R = crate::BitReader;
        #[doc = "Field `EDS14` writer - Event detected 14"]
        pub type EDS14_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS15` reader - Event detected 15"]
        pub type EDS15_R = crate::BitReader;
        #[doc = "Field `EDS15` writer - Event detected 15"]
        pub type EDS15_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS16` reader - Event detected 16"]
        pub type EDS16_R = crate::BitReader;
        #[doc = "Field `EDS16` writer - Event detected 16"]
        pub type EDS16_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS17` reader - Event detected 17"]
        pub type EDS17_R = crate::BitReader;
        #[doc = "Field `EDS17` writer - Event detected 17"]
        pub type EDS17_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS18` reader - Event detected 18"]
        pub type EDS18_R = crate::BitReader;
        #[doc = "Field `EDS18` writer - Event detected 18"]
        pub type EDS18_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS19` reader - Event detected 19"]
        pub type EDS19_R = crate::BitReader;
        #[doc = "Field `EDS19` writer - Event detected 19"]
        pub type EDS19_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS20` reader - Event detected 20"]
        pub type EDS20_R = crate::BitReader;
        #[doc = "Field `EDS20` writer - Event detected 20"]
        pub type EDS20_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS21` reader - Event detected 21"]
        pub type EDS21_R = crate::BitReader;
        #[doc = "Field `EDS21` writer - Event detected 21"]
        pub type EDS21_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS22` reader - Event detected 22"]
        pub type EDS22_R = crate::BitReader;
        #[doc = "Field `EDS22` writer - Event detected 22"]
        pub type EDS22_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS23` reader - Event detected 23"]
        pub type EDS23_R = crate::BitReader;
        #[doc = "Field `EDS23` writer - Event detected 23"]
        pub type EDS23_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS24` reader - Event detected 24"]
        pub type EDS24_R = crate::BitReader;
        #[doc = "Field `EDS24` writer - Event detected 24"]
        pub type EDS24_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS25` reader - Event detected 25"]
        pub type EDS25_R = crate::BitReader;
        #[doc = "Field `EDS25` writer - Event detected 25"]
        pub type EDS25_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS26` reader - Event detected 26"]
        pub type EDS26_R = crate::BitReader;
        #[doc = "Field `EDS26` writer - Event detected 26"]
        pub type EDS26_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS27` reader - Event detected 27"]
        pub type EDS27_R = crate::BitReader;
        #[doc = "Field `EDS27` writer - Event detected 27"]
        pub type EDS27_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS28` reader - Event detected 28"]
        pub type EDS28_R = crate::BitReader;
        #[doc = "Field `EDS28` writer - Event detected 28"]
        pub type EDS28_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS29` reader - Event detected 29"]
        pub type EDS29_R = crate::BitReader;
        #[doc = "Field `EDS29` writer - Event detected 29"]
        pub type EDS29_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS30` reader - Event detected 30"]
        pub type EDS30_R = crate::BitReader;
        #[doc = "Field `EDS30` writer - Event detected 30"]
        pub type EDS30_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS31` reader - Event detected 31"]
        pub type EDS31_R = crate::BitReader;
        #[doc = "Field `EDS31` writer - Event detected 31"]
        pub type EDS31_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Event detected 0"]
            #[inline(always)]
            pub fn eds0(&self) -> EDS0_R {
                EDS0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Event detected 1"]
            #[inline(always)]
            pub fn eds1(&self) -> EDS1_R {
                EDS1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Event detected 2"]
            #[inline(always)]
            pub fn eds2(&self) -> EDS2_R {
                EDS2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Event detected 3"]
            #[inline(always)]
            pub fn eds3(&self) -> EDS3_R {
                EDS3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Event detected 4"]
            #[inline(always)]
            pub fn eds4(&self) -> EDS4_R {
                EDS4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Event detected 5"]
            #[inline(always)]
            pub fn eds5(&self) -> EDS5_R {
                EDS5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Event detected 6"]
            #[inline(always)]
            pub fn eds6(&self) -> EDS6_R {
                EDS6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Event detected 7"]
            #[inline(always)]
            pub fn eds7(&self) -> EDS7_R {
                EDS7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Event detected 8"]
            #[inline(always)]
            pub fn eds8(&self) -> EDS8_R {
                EDS8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Event detected 9"]
            #[inline(always)]
            pub fn eds9(&self) -> EDS9_R {
                EDS9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Event detected 10"]
            #[inline(always)]
            pub fn eds10(&self) -> EDS10_R {
                EDS10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Event detected 11"]
            #[inline(always)]
            pub fn eds11(&self) -> EDS11_R {
                EDS11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Event detected 12"]
            #[inline(always)]
            pub fn eds12(&self) -> EDS12_R {
                EDS12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Event detected 13"]
            #[inline(always)]
            pub fn eds13(&self) -> EDS13_R {
                EDS13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Event detected 14"]
            #[inline(always)]
            pub fn eds14(&self) -> EDS14_R {
                EDS14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Event detected 15"]
            #[inline(always)]
            pub fn eds15(&self) -> EDS15_R {
                EDS15_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Event detected 16"]
            #[inline(always)]
            pub fn eds16(&self) -> EDS16_R {
                EDS16_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Event detected 17"]
            #[inline(always)]
            pub fn eds17(&self) -> EDS17_R {
                EDS17_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Event detected 18"]
            #[inline(always)]
            pub fn eds18(&self) -> EDS18_R {
                EDS18_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Event detected 19"]
            #[inline(always)]
            pub fn eds19(&self) -> EDS19_R {
                EDS19_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Event detected 20"]
            #[inline(always)]
            pub fn eds20(&self) -> EDS20_R {
                EDS20_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Event detected 21"]
            #[inline(always)]
            pub fn eds21(&self) -> EDS21_R {
                EDS21_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Event detected 22"]
            #[inline(always)]
            pub fn eds22(&self) -> EDS22_R {
                EDS22_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Event detected 23"]
            #[inline(always)]
            pub fn eds23(&self) -> EDS23_R {
                EDS23_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Event detected 24"]
            #[inline(always)]
            pub fn eds24(&self) -> EDS24_R {
                EDS24_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Event detected 25"]
            #[inline(always)]
            pub fn eds25(&self) -> EDS25_R {
                EDS25_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Event detected 26"]
            #[inline(always)]
            pub fn eds26(&self) -> EDS26_R {
                EDS26_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Event detected 27"]
            #[inline(always)]
            pub fn eds27(&self) -> EDS27_R {
                EDS27_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - Event detected 28"]
            #[inline(always)]
            pub fn eds28(&self) -> EDS28_R {
                EDS28_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Event detected 29"]
            #[inline(always)]
            pub fn eds29(&self) -> EDS29_R {
                EDS29_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Event detected 30"]
            #[inline(always)]
            pub fn eds30(&self) -> EDS30_R {
                EDS30_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Event detected 31"]
            #[inline(always)]
            pub fn eds31(&self) -> EDS31_R {
                EDS31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPEDS0")
                    .field("eds0", &format_args!("{}", self.eds0().bit()))
                    .field("eds1", &format_args!("{}", self.eds1().bit()))
                    .field("eds2", &format_args!("{}", self.eds2().bit()))
                    .field("eds3", &format_args!("{}", self.eds3().bit()))
                    .field("eds4", &format_args!("{}", self.eds4().bit()))
                    .field("eds5", &format_args!("{}", self.eds5().bit()))
                    .field("eds6", &format_args!("{}", self.eds6().bit()))
                    .field("eds7", &format_args!("{}", self.eds7().bit()))
                    .field("eds8", &format_args!("{}", self.eds8().bit()))
                    .field("eds9", &format_args!("{}", self.eds9().bit()))
                    .field("eds10", &format_args!("{}", self.eds10().bit()))
                    .field("eds11", &format_args!("{}", self.eds11().bit()))
                    .field("eds12", &format_args!("{}", self.eds12().bit()))
                    .field("eds13", &format_args!("{}", self.eds13().bit()))
                    .field("eds14", &format_args!("{}", self.eds14().bit()))
                    .field("eds15", &format_args!("{}", self.eds15().bit()))
                    .field("eds16", &format_args!("{}", self.eds16().bit()))
                    .field("eds17", &format_args!("{}", self.eds17().bit()))
                    .field("eds18", &format_args!("{}", self.eds18().bit()))
                    .field("eds19", &format_args!("{}", self.eds19().bit()))
                    .field("eds20", &format_args!("{}", self.eds20().bit()))
                    .field("eds21", &format_args!("{}", self.eds21().bit()))
                    .field("eds22", &format_args!("{}", self.eds22().bit()))
                    .field("eds23", &format_args!("{}", self.eds23().bit()))
                    .field("eds24", &format_args!("{}", self.eds24().bit()))
                    .field("eds25", &format_args!("{}", self.eds25().bit()))
                    .field("eds26", &format_args!("{}", self.eds26().bit()))
                    .field("eds27", &format_args!("{}", self.eds27().bit()))
                    .field("eds28", &format_args!("{}", self.eds28().bit()))
                    .field("eds29", &format_args!("{}", self.eds29().bit()))
                    .field("eds30", &format_args!("{}", self.eds30().bit()))
                    .field("eds31", &format_args!("{}", self.eds31().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPEDS0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Event detected 0"]
            #[inline(always)]
            #[must_use]
            pub fn eds0(&mut self) -> EDS0_W<GPEDS0_SPEC, 0> {
                EDS0_W::new(self)
            }
            #[doc = "Bit 1 - Event detected 1"]
            #[inline(always)]
            #[must_use]
            pub fn eds1(&mut self) -> EDS1_W<GPEDS0_SPEC, 1> {
                EDS1_W::new(self)
            }
            #[doc = "Bit 2 - Event detected 2"]
            #[inline(always)]
            #[must_use]
            pub fn eds2(&mut self) -> EDS2_W<GPEDS0_SPEC, 2> {
                EDS2_W::new(self)
            }
            #[doc = "Bit 3 - Event detected 3"]
            #[inline(always)]
            #[must_use]
            pub fn eds3(&mut self) -> EDS3_W<GPEDS0_SPEC, 3> {
                EDS3_W::new(self)
            }
            #[doc = "Bit 4 - Event detected 4"]
            #[inline(always)]
            #[must_use]
            pub fn eds4(&mut self) -> EDS4_W<GPEDS0_SPEC, 4> {
                EDS4_W::new(self)
            }
            #[doc = "Bit 5 - Event detected 5"]
            #[inline(always)]
            #[must_use]
            pub fn eds5(&mut self) -> EDS5_W<GPEDS0_SPEC, 5> {
                EDS5_W::new(self)
            }
            #[doc = "Bit 6 - Event detected 6"]
            #[inline(always)]
            #[must_use]
            pub fn eds6(&mut self) -> EDS6_W<GPEDS0_SPEC, 6> {
                EDS6_W::new(self)
            }
            #[doc = "Bit 7 - Event detected 7"]
            #[inline(always)]
            #[must_use]
            pub fn eds7(&mut self) -> EDS7_W<GPEDS0_SPEC, 7> {
                EDS7_W::new(self)
            }
            #[doc = "Bit 8 - Event detected 8"]
            #[inline(always)]
            #[must_use]
            pub fn eds8(&mut self) -> EDS8_W<GPEDS0_SPEC, 8> {
                EDS8_W::new(self)
            }
            #[doc = "Bit 9 - Event detected 9"]
            #[inline(always)]
            #[must_use]
            pub fn eds9(&mut self) -> EDS9_W<GPEDS0_SPEC, 9> {
                EDS9_W::new(self)
            }
            #[doc = "Bit 10 - Event detected 10"]
            #[inline(always)]
            #[must_use]
            pub fn eds10(&mut self) -> EDS10_W<GPEDS0_SPEC, 10> {
                EDS10_W::new(self)
            }
            #[doc = "Bit 11 - Event detected 11"]
            #[inline(always)]
            #[must_use]
            pub fn eds11(&mut self) -> EDS11_W<GPEDS0_SPEC, 11> {
                EDS11_W::new(self)
            }
            #[doc = "Bit 12 - Event detected 12"]
            #[inline(always)]
            #[must_use]
            pub fn eds12(&mut self) -> EDS12_W<GPEDS0_SPEC, 12> {
                EDS12_W::new(self)
            }
            #[doc = "Bit 13 - Event detected 13"]
            #[inline(always)]
            #[must_use]
            pub fn eds13(&mut self) -> EDS13_W<GPEDS0_SPEC, 13> {
                EDS13_W::new(self)
            }
            #[doc = "Bit 14 - Event detected 14"]
            #[inline(always)]
            #[must_use]
            pub fn eds14(&mut self) -> EDS14_W<GPEDS0_SPEC, 14> {
                EDS14_W::new(self)
            }
            #[doc = "Bit 15 - Event detected 15"]
            #[inline(always)]
            #[must_use]
            pub fn eds15(&mut self) -> EDS15_W<GPEDS0_SPEC, 15> {
                EDS15_W::new(self)
            }
            #[doc = "Bit 16 - Event detected 16"]
            #[inline(always)]
            #[must_use]
            pub fn eds16(&mut self) -> EDS16_W<GPEDS0_SPEC, 16> {
                EDS16_W::new(self)
            }
            #[doc = "Bit 17 - Event detected 17"]
            #[inline(always)]
            #[must_use]
            pub fn eds17(&mut self) -> EDS17_W<GPEDS0_SPEC, 17> {
                EDS17_W::new(self)
            }
            #[doc = "Bit 18 - Event detected 18"]
            #[inline(always)]
            #[must_use]
            pub fn eds18(&mut self) -> EDS18_W<GPEDS0_SPEC, 18> {
                EDS18_W::new(self)
            }
            #[doc = "Bit 19 - Event detected 19"]
            #[inline(always)]
            #[must_use]
            pub fn eds19(&mut self) -> EDS19_W<GPEDS0_SPEC, 19> {
                EDS19_W::new(self)
            }
            #[doc = "Bit 20 - Event detected 20"]
            #[inline(always)]
            #[must_use]
            pub fn eds20(&mut self) -> EDS20_W<GPEDS0_SPEC, 20> {
                EDS20_W::new(self)
            }
            #[doc = "Bit 21 - Event detected 21"]
            #[inline(always)]
            #[must_use]
            pub fn eds21(&mut self) -> EDS21_W<GPEDS0_SPEC, 21> {
                EDS21_W::new(self)
            }
            #[doc = "Bit 22 - Event detected 22"]
            #[inline(always)]
            #[must_use]
            pub fn eds22(&mut self) -> EDS22_W<GPEDS0_SPEC, 22> {
                EDS22_W::new(self)
            }
            #[doc = "Bit 23 - Event detected 23"]
            #[inline(always)]
            #[must_use]
            pub fn eds23(&mut self) -> EDS23_W<GPEDS0_SPEC, 23> {
                EDS23_W::new(self)
            }
            #[doc = "Bit 24 - Event detected 24"]
            #[inline(always)]
            #[must_use]
            pub fn eds24(&mut self) -> EDS24_W<GPEDS0_SPEC, 24> {
                EDS24_W::new(self)
            }
            #[doc = "Bit 25 - Event detected 25"]
            #[inline(always)]
            #[must_use]
            pub fn eds25(&mut self) -> EDS25_W<GPEDS0_SPEC, 25> {
                EDS25_W::new(self)
            }
            #[doc = "Bit 26 - Event detected 26"]
            #[inline(always)]
            #[must_use]
            pub fn eds26(&mut self) -> EDS26_W<GPEDS0_SPEC, 26> {
                EDS26_W::new(self)
            }
            #[doc = "Bit 27 - Event detected 27"]
            #[inline(always)]
            #[must_use]
            pub fn eds27(&mut self) -> EDS27_W<GPEDS0_SPEC, 27> {
                EDS27_W::new(self)
            }
            #[doc = "Bit 28 - Event detected 28"]
            #[inline(always)]
            #[must_use]
            pub fn eds28(&mut self) -> EDS28_W<GPEDS0_SPEC, 28> {
                EDS28_W::new(self)
            }
            #[doc = "Bit 29 - Event detected 29"]
            #[inline(always)]
            #[must_use]
            pub fn eds29(&mut self) -> EDS29_W<GPEDS0_SPEC, 29> {
                EDS29_W::new(self)
            }
            #[doc = "Bit 30 - Event detected 30"]
            #[inline(always)]
            #[must_use]
            pub fn eds30(&mut self) -> EDS30_W<GPEDS0_SPEC, 30> {
                EDS30_W::new(self)
            }
            #[doc = "Bit 31 - Event detected 31"]
            #[inline(always)]
            #[must_use]
            pub fn eds31(&mut self) -> EDS31_W<GPEDS0_SPEC, 31> {
                EDS31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Event Detect Status 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpeds0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpeds0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPEDS0_SPEC;
        impl crate::RegisterSpec for GPEDS0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpeds0::R`](R) reader structure"]
        impl crate::Readable for GPEDS0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpeds0::W`](W) writer structure"]
        impl crate::Writable for GPEDS0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xffff_ffff;
        }
    }
    #[doc = "GPEDS1 (rw) register accessor: GPIO Pin Event Detect Status 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpeds1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpeds1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpeds1`]
module"]
    pub type GPEDS1 = crate::Reg<gpeds1::GPEDS1_SPEC>;
    #[doc = "GPIO Pin Event Detect Status 1"]
    pub mod gpeds1 {
        #[doc = "Register `GPEDS1` reader"]
        pub type R = crate::R<GPEDS1_SPEC>;
        #[doc = "Register `GPEDS1` writer"]
        pub type W = crate::W<GPEDS1_SPEC>;
        #[doc = "Field `EDS32` reader - Event detected 32"]
        pub type EDS32_R = crate::BitReader;
        #[doc = "Field `EDS32` writer - Event detected 32"]
        pub type EDS32_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS33` reader - Event detected 33"]
        pub type EDS33_R = crate::BitReader;
        #[doc = "Field `EDS33` writer - Event detected 33"]
        pub type EDS33_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS34` reader - Event detected 34"]
        pub type EDS34_R = crate::BitReader;
        #[doc = "Field `EDS34` writer - Event detected 34"]
        pub type EDS34_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS35` reader - Event detected 35"]
        pub type EDS35_R = crate::BitReader;
        #[doc = "Field `EDS35` writer - Event detected 35"]
        pub type EDS35_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS36` reader - Event detected 36"]
        pub type EDS36_R = crate::BitReader;
        #[doc = "Field `EDS36` writer - Event detected 36"]
        pub type EDS36_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS37` reader - Event detected 37"]
        pub type EDS37_R = crate::BitReader;
        #[doc = "Field `EDS37` writer - Event detected 37"]
        pub type EDS37_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS38` reader - Event detected 38"]
        pub type EDS38_R = crate::BitReader;
        #[doc = "Field `EDS38` writer - Event detected 38"]
        pub type EDS38_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS39` reader - Event detected 39"]
        pub type EDS39_R = crate::BitReader;
        #[doc = "Field `EDS39` writer - Event detected 39"]
        pub type EDS39_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS40` reader - Event detected 40"]
        pub type EDS40_R = crate::BitReader;
        #[doc = "Field `EDS40` writer - Event detected 40"]
        pub type EDS40_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS41` reader - Event detected 41"]
        pub type EDS41_R = crate::BitReader;
        #[doc = "Field `EDS41` writer - Event detected 41"]
        pub type EDS41_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS42` reader - Event detected 42"]
        pub type EDS42_R = crate::BitReader;
        #[doc = "Field `EDS42` writer - Event detected 42"]
        pub type EDS42_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS43` reader - Event detected 43"]
        pub type EDS43_R = crate::BitReader;
        #[doc = "Field `EDS43` writer - Event detected 43"]
        pub type EDS43_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS44` reader - Event detected 44"]
        pub type EDS44_R = crate::BitReader;
        #[doc = "Field `EDS44` writer - Event detected 44"]
        pub type EDS44_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS45` reader - Event detected 45"]
        pub type EDS45_R = crate::BitReader;
        #[doc = "Field `EDS45` writer - Event detected 45"]
        pub type EDS45_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS46` reader - Event detected 46"]
        pub type EDS46_R = crate::BitReader;
        #[doc = "Field `EDS46` writer - Event detected 46"]
        pub type EDS46_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS47` reader - Event detected 47"]
        pub type EDS47_R = crate::BitReader;
        #[doc = "Field `EDS47` writer - Event detected 47"]
        pub type EDS47_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS48` reader - Event detected 48"]
        pub type EDS48_R = crate::BitReader;
        #[doc = "Field `EDS48` writer - Event detected 48"]
        pub type EDS48_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS49` reader - Event detected 49"]
        pub type EDS49_R = crate::BitReader;
        #[doc = "Field `EDS49` writer - Event detected 49"]
        pub type EDS49_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS50` reader - Event detected 50"]
        pub type EDS50_R = crate::BitReader;
        #[doc = "Field `EDS50` writer - Event detected 50"]
        pub type EDS50_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS51` reader - Event detected 51"]
        pub type EDS51_R = crate::BitReader;
        #[doc = "Field `EDS51` writer - Event detected 51"]
        pub type EDS51_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS52` reader - Event detected 52"]
        pub type EDS52_R = crate::BitReader;
        #[doc = "Field `EDS52` writer - Event detected 52"]
        pub type EDS52_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EDS53` reader - Event detected 53"]
        pub type EDS53_R = crate::BitReader;
        #[doc = "Field `EDS53` writer - Event detected 53"]
        pub type EDS53_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Event detected 32"]
            #[inline(always)]
            pub fn eds32(&self) -> EDS32_R {
                EDS32_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Event detected 33"]
            #[inline(always)]
            pub fn eds33(&self) -> EDS33_R {
                EDS33_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Event detected 34"]
            #[inline(always)]
            pub fn eds34(&self) -> EDS34_R {
                EDS34_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Event detected 35"]
            #[inline(always)]
            pub fn eds35(&self) -> EDS35_R {
                EDS35_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Event detected 36"]
            #[inline(always)]
            pub fn eds36(&self) -> EDS36_R {
                EDS36_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Event detected 37"]
            #[inline(always)]
            pub fn eds37(&self) -> EDS37_R {
                EDS37_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Event detected 38"]
            #[inline(always)]
            pub fn eds38(&self) -> EDS38_R {
                EDS38_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Event detected 39"]
            #[inline(always)]
            pub fn eds39(&self) -> EDS39_R {
                EDS39_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Event detected 40"]
            #[inline(always)]
            pub fn eds40(&self) -> EDS40_R {
                EDS40_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Event detected 41"]
            #[inline(always)]
            pub fn eds41(&self) -> EDS41_R {
                EDS41_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Event detected 42"]
            #[inline(always)]
            pub fn eds42(&self) -> EDS42_R {
                EDS42_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Event detected 43"]
            #[inline(always)]
            pub fn eds43(&self) -> EDS43_R {
                EDS43_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Event detected 44"]
            #[inline(always)]
            pub fn eds44(&self) -> EDS44_R {
                EDS44_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Event detected 45"]
            #[inline(always)]
            pub fn eds45(&self) -> EDS45_R {
                EDS45_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Event detected 46"]
            #[inline(always)]
            pub fn eds46(&self) -> EDS46_R {
                EDS46_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Event detected 47"]
            #[inline(always)]
            pub fn eds47(&self) -> EDS47_R {
                EDS47_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Event detected 48"]
            #[inline(always)]
            pub fn eds48(&self) -> EDS48_R {
                EDS48_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Event detected 49"]
            #[inline(always)]
            pub fn eds49(&self) -> EDS49_R {
                EDS49_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Event detected 50"]
            #[inline(always)]
            pub fn eds50(&self) -> EDS50_R {
                EDS50_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Event detected 51"]
            #[inline(always)]
            pub fn eds51(&self) -> EDS51_R {
                EDS51_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Event detected 52"]
            #[inline(always)]
            pub fn eds52(&self) -> EDS52_R {
                EDS52_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Event detected 53"]
            #[inline(always)]
            pub fn eds53(&self) -> EDS53_R {
                EDS53_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPEDS1")
                    .field("eds32", &format_args!("{}", self.eds32().bit()))
                    .field("eds33", &format_args!("{}", self.eds33().bit()))
                    .field("eds34", &format_args!("{}", self.eds34().bit()))
                    .field("eds35", &format_args!("{}", self.eds35().bit()))
                    .field("eds36", &format_args!("{}", self.eds36().bit()))
                    .field("eds37", &format_args!("{}", self.eds37().bit()))
                    .field("eds38", &format_args!("{}", self.eds38().bit()))
                    .field("eds39", &format_args!("{}", self.eds39().bit()))
                    .field("eds40", &format_args!("{}", self.eds40().bit()))
                    .field("eds41", &format_args!("{}", self.eds41().bit()))
                    .field("eds42", &format_args!("{}", self.eds42().bit()))
                    .field("eds43", &format_args!("{}", self.eds43().bit()))
                    .field("eds44", &format_args!("{}", self.eds44().bit()))
                    .field("eds45", &format_args!("{}", self.eds45().bit()))
                    .field("eds46", &format_args!("{}", self.eds46().bit()))
                    .field("eds47", &format_args!("{}", self.eds47().bit()))
                    .field("eds48", &format_args!("{}", self.eds48().bit()))
                    .field("eds49", &format_args!("{}", self.eds49().bit()))
                    .field("eds50", &format_args!("{}", self.eds50().bit()))
                    .field("eds51", &format_args!("{}", self.eds51().bit()))
                    .field("eds52", &format_args!("{}", self.eds52().bit()))
                    .field("eds53", &format_args!("{}", self.eds53().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPEDS1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Event detected 32"]
            #[inline(always)]
            #[must_use]
            pub fn eds32(&mut self) -> EDS32_W<GPEDS1_SPEC, 0> {
                EDS32_W::new(self)
            }
            #[doc = "Bit 1 - Event detected 33"]
            #[inline(always)]
            #[must_use]
            pub fn eds33(&mut self) -> EDS33_W<GPEDS1_SPEC, 1> {
                EDS33_W::new(self)
            }
            #[doc = "Bit 2 - Event detected 34"]
            #[inline(always)]
            #[must_use]
            pub fn eds34(&mut self) -> EDS34_W<GPEDS1_SPEC, 2> {
                EDS34_W::new(self)
            }
            #[doc = "Bit 3 - Event detected 35"]
            #[inline(always)]
            #[must_use]
            pub fn eds35(&mut self) -> EDS35_W<GPEDS1_SPEC, 3> {
                EDS35_W::new(self)
            }
            #[doc = "Bit 4 - Event detected 36"]
            #[inline(always)]
            #[must_use]
            pub fn eds36(&mut self) -> EDS36_W<GPEDS1_SPEC, 4> {
                EDS36_W::new(self)
            }
            #[doc = "Bit 5 - Event detected 37"]
            #[inline(always)]
            #[must_use]
            pub fn eds37(&mut self) -> EDS37_W<GPEDS1_SPEC, 5> {
                EDS37_W::new(self)
            }
            #[doc = "Bit 6 - Event detected 38"]
            #[inline(always)]
            #[must_use]
            pub fn eds38(&mut self) -> EDS38_W<GPEDS1_SPEC, 6> {
                EDS38_W::new(self)
            }
            #[doc = "Bit 7 - Event detected 39"]
            #[inline(always)]
            #[must_use]
            pub fn eds39(&mut self) -> EDS39_W<GPEDS1_SPEC, 7> {
                EDS39_W::new(self)
            }
            #[doc = "Bit 8 - Event detected 40"]
            #[inline(always)]
            #[must_use]
            pub fn eds40(&mut self) -> EDS40_W<GPEDS1_SPEC, 8> {
                EDS40_W::new(self)
            }
            #[doc = "Bit 9 - Event detected 41"]
            #[inline(always)]
            #[must_use]
            pub fn eds41(&mut self) -> EDS41_W<GPEDS1_SPEC, 9> {
                EDS41_W::new(self)
            }
            #[doc = "Bit 10 - Event detected 42"]
            #[inline(always)]
            #[must_use]
            pub fn eds42(&mut self) -> EDS42_W<GPEDS1_SPEC, 10> {
                EDS42_W::new(self)
            }
            #[doc = "Bit 11 - Event detected 43"]
            #[inline(always)]
            #[must_use]
            pub fn eds43(&mut self) -> EDS43_W<GPEDS1_SPEC, 11> {
                EDS43_W::new(self)
            }
            #[doc = "Bit 12 - Event detected 44"]
            #[inline(always)]
            #[must_use]
            pub fn eds44(&mut self) -> EDS44_W<GPEDS1_SPEC, 12> {
                EDS44_W::new(self)
            }
            #[doc = "Bit 13 - Event detected 45"]
            #[inline(always)]
            #[must_use]
            pub fn eds45(&mut self) -> EDS45_W<GPEDS1_SPEC, 13> {
                EDS45_W::new(self)
            }
            #[doc = "Bit 14 - Event detected 46"]
            #[inline(always)]
            #[must_use]
            pub fn eds46(&mut self) -> EDS46_W<GPEDS1_SPEC, 14> {
                EDS46_W::new(self)
            }
            #[doc = "Bit 15 - Event detected 47"]
            #[inline(always)]
            #[must_use]
            pub fn eds47(&mut self) -> EDS47_W<GPEDS1_SPEC, 15> {
                EDS47_W::new(self)
            }
            #[doc = "Bit 16 - Event detected 48"]
            #[inline(always)]
            #[must_use]
            pub fn eds48(&mut self) -> EDS48_W<GPEDS1_SPEC, 16> {
                EDS48_W::new(self)
            }
            #[doc = "Bit 17 - Event detected 49"]
            #[inline(always)]
            #[must_use]
            pub fn eds49(&mut self) -> EDS49_W<GPEDS1_SPEC, 17> {
                EDS49_W::new(self)
            }
            #[doc = "Bit 18 - Event detected 50"]
            #[inline(always)]
            #[must_use]
            pub fn eds50(&mut self) -> EDS50_W<GPEDS1_SPEC, 18> {
                EDS50_W::new(self)
            }
            #[doc = "Bit 19 - Event detected 51"]
            #[inline(always)]
            #[must_use]
            pub fn eds51(&mut self) -> EDS51_W<GPEDS1_SPEC, 19> {
                EDS51_W::new(self)
            }
            #[doc = "Bit 20 - Event detected 52"]
            #[inline(always)]
            #[must_use]
            pub fn eds52(&mut self) -> EDS52_W<GPEDS1_SPEC, 20> {
                EDS52_W::new(self)
            }
            #[doc = "Bit 21 - Event detected 53"]
            #[inline(always)]
            #[must_use]
            pub fn eds53(&mut self) -> EDS53_W<GPEDS1_SPEC, 21> {
                EDS53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Event Detect Status 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpeds1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpeds1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPEDS1_SPEC;
        impl crate::RegisterSpec for GPEDS1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpeds1::R`](R) reader structure"]
        impl crate::Readable for GPEDS1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpeds1::W`](W) writer structure"]
        impl crate::Writable for GPEDS1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x003f_ffff;
        }
    }
    #[doc = "GPREN0 (rw) register accessor: GPIO Pin Rising Edge Detect Enable 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpren0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpren0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpren0`]
module"]
    pub type GPREN0 = crate::Reg<gpren0::GPREN0_SPEC>;
    #[doc = "GPIO Pin Rising Edge Detect Enable 0"]
    pub mod gpren0 {
        #[doc = "Register `GPREN0` reader"]
        pub type R = crate::R<GPREN0_SPEC>;
        #[doc = "Register `GPREN0` writer"]
        pub type W = crate::W<GPREN0_SPEC>;
        #[doc = "Field `REN0` reader - Rising edge enabled 0"]
        pub type REN0_R = crate::BitReader;
        #[doc = "Field `REN0` writer - Rising edge enabled 0"]
        pub type REN0_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN1` reader - Rising edge enabled 1"]
        pub type REN1_R = crate::BitReader;
        #[doc = "Field `REN1` writer - Rising edge enabled 1"]
        pub type REN1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN2` reader - Rising edge enabled 2"]
        pub type REN2_R = crate::BitReader;
        #[doc = "Field `REN2` writer - Rising edge enabled 2"]
        pub type REN2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN3` reader - Rising edge enabled 3"]
        pub type REN3_R = crate::BitReader;
        #[doc = "Field `REN3` writer - Rising edge enabled 3"]
        pub type REN3_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN4` reader - Rising edge enabled 4"]
        pub type REN4_R = crate::BitReader;
        #[doc = "Field `REN4` writer - Rising edge enabled 4"]
        pub type REN4_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN5` reader - Rising edge enabled 5"]
        pub type REN5_R = crate::BitReader;
        #[doc = "Field `REN5` writer - Rising edge enabled 5"]
        pub type REN5_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN6` reader - Rising edge enabled 6"]
        pub type REN6_R = crate::BitReader;
        #[doc = "Field `REN6` writer - Rising edge enabled 6"]
        pub type REN6_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN7` reader - Rising edge enabled 7"]
        pub type REN7_R = crate::BitReader;
        #[doc = "Field `REN7` writer - Rising edge enabled 7"]
        pub type REN7_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN8` reader - Rising edge enabled 8"]
        pub type REN8_R = crate::BitReader;
        #[doc = "Field `REN8` writer - Rising edge enabled 8"]
        pub type REN8_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN9` reader - Rising edge enabled 9"]
        pub type REN9_R = crate::BitReader;
        #[doc = "Field `REN9` writer - Rising edge enabled 9"]
        pub type REN9_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN10` reader - Rising edge enabled 10"]
        pub type REN10_R = crate::BitReader;
        #[doc = "Field `REN10` writer - Rising edge enabled 10"]
        pub type REN10_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN11` reader - Rising edge enabled 11"]
        pub type REN11_R = crate::BitReader;
        #[doc = "Field `REN11` writer - Rising edge enabled 11"]
        pub type REN11_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN12` reader - Rising edge enabled 12"]
        pub type REN12_R = crate::BitReader;
        #[doc = "Field `REN12` writer - Rising edge enabled 12"]
        pub type REN12_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN13` reader - Rising edge enabled 13"]
        pub type REN13_R = crate::BitReader;
        #[doc = "Field `REN13` writer - Rising edge enabled 13"]
        pub type REN13_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN14` reader - Rising edge enabled 14"]
        pub type REN14_R = crate::BitReader;
        #[doc = "Field `REN14` writer - Rising edge enabled 14"]
        pub type REN14_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN15` reader - Rising edge enabled 15"]
        pub type REN15_R = crate::BitReader;
        #[doc = "Field `REN15` writer - Rising edge enabled 15"]
        pub type REN15_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN16` reader - Rising edge enabled 16"]
        pub type REN16_R = crate::BitReader;
        #[doc = "Field `REN16` writer - Rising edge enabled 16"]
        pub type REN16_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN17` reader - Rising edge enabled 17"]
        pub type REN17_R = crate::BitReader;
        #[doc = "Field `REN17` writer - Rising edge enabled 17"]
        pub type REN17_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN18` reader - Rising edge enabled 18"]
        pub type REN18_R = crate::BitReader;
        #[doc = "Field `REN18` writer - Rising edge enabled 18"]
        pub type REN18_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN19` reader - Rising edge enabled 19"]
        pub type REN19_R = crate::BitReader;
        #[doc = "Field `REN19` writer - Rising edge enabled 19"]
        pub type REN19_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN20` reader - Rising edge enabled 20"]
        pub type REN20_R = crate::BitReader;
        #[doc = "Field `REN20` writer - Rising edge enabled 20"]
        pub type REN20_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN21` reader - Rising edge enabled 21"]
        pub type REN21_R = crate::BitReader;
        #[doc = "Field `REN21` writer - Rising edge enabled 21"]
        pub type REN21_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN22` reader - Rising edge enabled 22"]
        pub type REN22_R = crate::BitReader;
        #[doc = "Field `REN22` writer - Rising edge enabled 22"]
        pub type REN22_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN23` reader - Rising edge enabled 23"]
        pub type REN23_R = crate::BitReader;
        #[doc = "Field `REN23` writer - Rising edge enabled 23"]
        pub type REN23_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN24` reader - Rising edge enabled 24"]
        pub type REN24_R = crate::BitReader;
        #[doc = "Field `REN24` writer - Rising edge enabled 24"]
        pub type REN24_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN25` reader - Rising edge enabled 25"]
        pub type REN25_R = crate::BitReader;
        #[doc = "Field `REN25` writer - Rising edge enabled 25"]
        pub type REN25_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN26` reader - Rising edge enabled 26"]
        pub type REN26_R = crate::BitReader;
        #[doc = "Field `REN26` writer - Rising edge enabled 26"]
        pub type REN26_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN27` reader - Rising edge enabled 27"]
        pub type REN27_R = crate::BitReader;
        #[doc = "Field `REN27` writer - Rising edge enabled 27"]
        pub type REN27_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN28` reader - Rising edge enabled 28"]
        pub type REN28_R = crate::BitReader;
        #[doc = "Field `REN28` writer - Rising edge enabled 28"]
        pub type REN28_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN29` reader - Rising edge enabled 29"]
        pub type REN29_R = crate::BitReader;
        #[doc = "Field `REN29` writer - Rising edge enabled 29"]
        pub type REN29_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN30` reader - Rising edge enabled 30"]
        pub type REN30_R = crate::BitReader;
        #[doc = "Field `REN30` writer - Rising edge enabled 30"]
        pub type REN30_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN31` reader - Rising edge enabled 31"]
        pub type REN31_R = crate::BitReader;
        #[doc = "Field `REN31` writer - Rising edge enabled 31"]
        pub type REN31_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Rising edge enabled 0"]
            #[inline(always)]
            pub fn ren0(&self) -> REN0_R {
                REN0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Rising edge enabled 1"]
            #[inline(always)]
            pub fn ren1(&self) -> REN1_R {
                REN1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Rising edge enabled 2"]
            #[inline(always)]
            pub fn ren2(&self) -> REN2_R {
                REN2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Rising edge enabled 3"]
            #[inline(always)]
            pub fn ren3(&self) -> REN3_R {
                REN3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Rising edge enabled 4"]
            #[inline(always)]
            pub fn ren4(&self) -> REN4_R {
                REN4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Rising edge enabled 5"]
            #[inline(always)]
            pub fn ren5(&self) -> REN5_R {
                REN5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Rising edge enabled 6"]
            #[inline(always)]
            pub fn ren6(&self) -> REN6_R {
                REN6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Rising edge enabled 7"]
            #[inline(always)]
            pub fn ren7(&self) -> REN7_R {
                REN7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Rising edge enabled 8"]
            #[inline(always)]
            pub fn ren8(&self) -> REN8_R {
                REN8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Rising edge enabled 9"]
            #[inline(always)]
            pub fn ren9(&self) -> REN9_R {
                REN9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Rising edge enabled 10"]
            #[inline(always)]
            pub fn ren10(&self) -> REN10_R {
                REN10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Rising edge enabled 11"]
            #[inline(always)]
            pub fn ren11(&self) -> REN11_R {
                REN11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Rising edge enabled 12"]
            #[inline(always)]
            pub fn ren12(&self) -> REN12_R {
                REN12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Rising edge enabled 13"]
            #[inline(always)]
            pub fn ren13(&self) -> REN13_R {
                REN13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Rising edge enabled 14"]
            #[inline(always)]
            pub fn ren14(&self) -> REN14_R {
                REN14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Rising edge enabled 15"]
            #[inline(always)]
            pub fn ren15(&self) -> REN15_R {
                REN15_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Rising edge enabled 16"]
            #[inline(always)]
            pub fn ren16(&self) -> REN16_R {
                REN16_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Rising edge enabled 17"]
            #[inline(always)]
            pub fn ren17(&self) -> REN17_R {
                REN17_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Rising edge enabled 18"]
            #[inline(always)]
            pub fn ren18(&self) -> REN18_R {
                REN18_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Rising edge enabled 19"]
            #[inline(always)]
            pub fn ren19(&self) -> REN19_R {
                REN19_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Rising edge enabled 20"]
            #[inline(always)]
            pub fn ren20(&self) -> REN20_R {
                REN20_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Rising edge enabled 21"]
            #[inline(always)]
            pub fn ren21(&self) -> REN21_R {
                REN21_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Rising edge enabled 22"]
            #[inline(always)]
            pub fn ren22(&self) -> REN22_R {
                REN22_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Rising edge enabled 23"]
            #[inline(always)]
            pub fn ren23(&self) -> REN23_R {
                REN23_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Rising edge enabled 24"]
            #[inline(always)]
            pub fn ren24(&self) -> REN24_R {
                REN24_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Rising edge enabled 25"]
            #[inline(always)]
            pub fn ren25(&self) -> REN25_R {
                REN25_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Rising edge enabled 26"]
            #[inline(always)]
            pub fn ren26(&self) -> REN26_R {
                REN26_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Rising edge enabled 27"]
            #[inline(always)]
            pub fn ren27(&self) -> REN27_R {
                REN27_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - Rising edge enabled 28"]
            #[inline(always)]
            pub fn ren28(&self) -> REN28_R {
                REN28_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Rising edge enabled 29"]
            #[inline(always)]
            pub fn ren29(&self) -> REN29_R {
                REN29_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Rising edge enabled 30"]
            #[inline(always)]
            pub fn ren30(&self) -> REN30_R {
                REN30_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Rising edge enabled 31"]
            #[inline(always)]
            pub fn ren31(&self) -> REN31_R {
                REN31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPREN0")
                    .field("ren0", &format_args!("{}", self.ren0().bit()))
                    .field("ren1", &format_args!("{}", self.ren1().bit()))
                    .field("ren2", &format_args!("{}", self.ren2().bit()))
                    .field("ren3", &format_args!("{}", self.ren3().bit()))
                    .field("ren4", &format_args!("{}", self.ren4().bit()))
                    .field("ren5", &format_args!("{}", self.ren5().bit()))
                    .field("ren6", &format_args!("{}", self.ren6().bit()))
                    .field("ren7", &format_args!("{}", self.ren7().bit()))
                    .field("ren8", &format_args!("{}", self.ren8().bit()))
                    .field("ren9", &format_args!("{}", self.ren9().bit()))
                    .field("ren10", &format_args!("{}", self.ren10().bit()))
                    .field("ren11", &format_args!("{}", self.ren11().bit()))
                    .field("ren12", &format_args!("{}", self.ren12().bit()))
                    .field("ren13", &format_args!("{}", self.ren13().bit()))
                    .field("ren14", &format_args!("{}", self.ren14().bit()))
                    .field("ren15", &format_args!("{}", self.ren15().bit()))
                    .field("ren16", &format_args!("{}", self.ren16().bit()))
                    .field("ren17", &format_args!("{}", self.ren17().bit()))
                    .field("ren18", &format_args!("{}", self.ren18().bit()))
                    .field("ren19", &format_args!("{}", self.ren19().bit()))
                    .field("ren20", &format_args!("{}", self.ren20().bit()))
                    .field("ren21", &format_args!("{}", self.ren21().bit()))
                    .field("ren22", &format_args!("{}", self.ren22().bit()))
                    .field("ren23", &format_args!("{}", self.ren23().bit()))
                    .field("ren24", &format_args!("{}", self.ren24().bit()))
                    .field("ren25", &format_args!("{}", self.ren25().bit()))
                    .field("ren26", &format_args!("{}", self.ren26().bit()))
                    .field("ren27", &format_args!("{}", self.ren27().bit()))
                    .field("ren28", &format_args!("{}", self.ren28().bit()))
                    .field("ren29", &format_args!("{}", self.ren29().bit()))
                    .field("ren30", &format_args!("{}", self.ren30().bit()))
                    .field("ren31", &format_args!("{}", self.ren31().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPREN0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Rising edge enabled 0"]
            #[inline(always)]
            #[must_use]
            pub fn ren0(&mut self) -> REN0_W<GPREN0_SPEC, 0> {
                REN0_W::new(self)
            }
            #[doc = "Bit 1 - Rising edge enabled 1"]
            #[inline(always)]
            #[must_use]
            pub fn ren1(&mut self) -> REN1_W<GPREN0_SPEC, 1> {
                REN1_W::new(self)
            }
            #[doc = "Bit 2 - Rising edge enabled 2"]
            #[inline(always)]
            #[must_use]
            pub fn ren2(&mut self) -> REN2_W<GPREN0_SPEC, 2> {
                REN2_W::new(self)
            }
            #[doc = "Bit 3 - Rising edge enabled 3"]
            #[inline(always)]
            #[must_use]
            pub fn ren3(&mut self) -> REN3_W<GPREN0_SPEC, 3> {
                REN3_W::new(self)
            }
            #[doc = "Bit 4 - Rising edge enabled 4"]
            #[inline(always)]
            #[must_use]
            pub fn ren4(&mut self) -> REN4_W<GPREN0_SPEC, 4> {
                REN4_W::new(self)
            }
            #[doc = "Bit 5 - Rising edge enabled 5"]
            #[inline(always)]
            #[must_use]
            pub fn ren5(&mut self) -> REN5_W<GPREN0_SPEC, 5> {
                REN5_W::new(self)
            }
            #[doc = "Bit 6 - Rising edge enabled 6"]
            #[inline(always)]
            #[must_use]
            pub fn ren6(&mut self) -> REN6_W<GPREN0_SPEC, 6> {
                REN6_W::new(self)
            }
            #[doc = "Bit 7 - Rising edge enabled 7"]
            #[inline(always)]
            #[must_use]
            pub fn ren7(&mut self) -> REN7_W<GPREN0_SPEC, 7> {
                REN7_W::new(self)
            }
            #[doc = "Bit 8 - Rising edge enabled 8"]
            #[inline(always)]
            #[must_use]
            pub fn ren8(&mut self) -> REN8_W<GPREN0_SPEC, 8> {
                REN8_W::new(self)
            }
            #[doc = "Bit 9 - Rising edge enabled 9"]
            #[inline(always)]
            #[must_use]
            pub fn ren9(&mut self) -> REN9_W<GPREN0_SPEC, 9> {
                REN9_W::new(self)
            }
            #[doc = "Bit 10 - Rising edge enabled 10"]
            #[inline(always)]
            #[must_use]
            pub fn ren10(&mut self) -> REN10_W<GPREN0_SPEC, 10> {
                REN10_W::new(self)
            }
            #[doc = "Bit 11 - Rising edge enabled 11"]
            #[inline(always)]
            #[must_use]
            pub fn ren11(&mut self) -> REN11_W<GPREN0_SPEC, 11> {
                REN11_W::new(self)
            }
            #[doc = "Bit 12 - Rising edge enabled 12"]
            #[inline(always)]
            #[must_use]
            pub fn ren12(&mut self) -> REN12_W<GPREN0_SPEC, 12> {
                REN12_W::new(self)
            }
            #[doc = "Bit 13 - Rising edge enabled 13"]
            #[inline(always)]
            #[must_use]
            pub fn ren13(&mut self) -> REN13_W<GPREN0_SPEC, 13> {
                REN13_W::new(self)
            }
            #[doc = "Bit 14 - Rising edge enabled 14"]
            #[inline(always)]
            #[must_use]
            pub fn ren14(&mut self) -> REN14_W<GPREN0_SPEC, 14> {
                REN14_W::new(self)
            }
            #[doc = "Bit 15 - Rising edge enabled 15"]
            #[inline(always)]
            #[must_use]
            pub fn ren15(&mut self) -> REN15_W<GPREN0_SPEC, 15> {
                REN15_W::new(self)
            }
            #[doc = "Bit 16 - Rising edge enabled 16"]
            #[inline(always)]
            #[must_use]
            pub fn ren16(&mut self) -> REN16_W<GPREN0_SPEC, 16> {
                REN16_W::new(self)
            }
            #[doc = "Bit 17 - Rising edge enabled 17"]
            #[inline(always)]
            #[must_use]
            pub fn ren17(&mut self) -> REN17_W<GPREN0_SPEC, 17> {
                REN17_W::new(self)
            }
            #[doc = "Bit 18 - Rising edge enabled 18"]
            #[inline(always)]
            #[must_use]
            pub fn ren18(&mut self) -> REN18_W<GPREN0_SPEC, 18> {
                REN18_W::new(self)
            }
            #[doc = "Bit 19 - Rising edge enabled 19"]
            #[inline(always)]
            #[must_use]
            pub fn ren19(&mut self) -> REN19_W<GPREN0_SPEC, 19> {
                REN19_W::new(self)
            }
            #[doc = "Bit 20 - Rising edge enabled 20"]
            #[inline(always)]
            #[must_use]
            pub fn ren20(&mut self) -> REN20_W<GPREN0_SPEC, 20> {
                REN20_W::new(self)
            }
            #[doc = "Bit 21 - Rising edge enabled 21"]
            #[inline(always)]
            #[must_use]
            pub fn ren21(&mut self) -> REN21_W<GPREN0_SPEC, 21> {
                REN21_W::new(self)
            }
            #[doc = "Bit 22 - Rising edge enabled 22"]
            #[inline(always)]
            #[must_use]
            pub fn ren22(&mut self) -> REN22_W<GPREN0_SPEC, 22> {
                REN22_W::new(self)
            }
            #[doc = "Bit 23 - Rising edge enabled 23"]
            #[inline(always)]
            #[must_use]
            pub fn ren23(&mut self) -> REN23_W<GPREN0_SPEC, 23> {
                REN23_W::new(self)
            }
            #[doc = "Bit 24 - Rising edge enabled 24"]
            #[inline(always)]
            #[must_use]
            pub fn ren24(&mut self) -> REN24_W<GPREN0_SPEC, 24> {
                REN24_W::new(self)
            }
            #[doc = "Bit 25 - Rising edge enabled 25"]
            #[inline(always)]
            #[must_use]
            pub fn ren25(&mut self) -> REN25_W<GPREN0_SPEC, 25> {
                REN25_W::new(self)
            }
            #[doc = "Bit 26 - Rising edge enabled 26"]
            #[inline(always)]
            #[must_use]
            pub fn ren26(&mut self) -> REN26_W<GPREN0_SPEC, 26> {
                REN26_W::new(self)
            }
            #[doc = "Bit 27 - Rising edge enabled 27"]
            #[inline(always)]
            #[must_use]
            pub fn ren27(&mut self) -> REN27_W<GPREN0_SPEC, 27> {
                REN27_W::new(self)
            }
            #[doc = "Bit 28 - Rising edge enabled 28"]
            #[inline(always)]
            #[must_use]
            pub fn ren28(&mut self) -> REN28_W<GPREN0_SPEC, 28> {
                REN28_W::new(self)
            }
            #[doc = "Bit 29 - Rising edge enabled 29"]
            #[inline(always)]
            #[must_use]
            pub fn ren29(&mut self) -> REN29_W<GPREN0_SPEC, 29> {
                REN29_W::new(self)
            }
            #[doc = "Bit 30 - Rising edge enabled 30"]
            #[inline(always)]
            #[must_use]
            pub fn ren30(&mut self) -> REN30_W<GPREN0_SPEC, 30> {
                REN30_W::new(self)
            }
            #[doc = "Bit 31 - Rising edge enabled 31"]
            #[inline(always)]
            #[must_use]
            pub fn ren31(&mut self) -> REN31_W<GPREN0_SPEC, 31> {
                REN31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Rising Edge Detect Enable 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpren0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpren0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPREN0_SPEC;
        impl crate::RegisterSpec for GPREN0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpren0::R`](R) reader structure"]
        impl crate::Readable for GPREN0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpren0::W`](W) writer structure"]
        impl crate::Writable for GPREN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPREN1 (rw) register accessor: GPIO Pin Rising Edge Detect Enable 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpren1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpren1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpren1`]
module"]
    pub type GPREN1 = crate::Reg<gpren1::GPREN1_SPEC>;
    #[doc = "GPIO Pin Rising Edge Detect Enable 1"]
    pub mod gpren1 {
        #[doc = "Register `GPREN1` reader"]
        pub type R = crate::R<GPREN1_SPEC>;
        #[doc = "Register `GPREN1` writer"]
        pub type W = crate::W<GPREN1_SPEC>;
        #[doc = "Field `REN32` reader - Rising edge enabled 32"]
        pub type REN32_R = crate::BitReader;
        #[doc = "Field `REN32` writer - Rising edge enabled 32"]
        pub type REN32_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN33` reader - Rising edge enabled 33"]
        pub type REN33_R = crate::BitReader;
        #[doc = "Field `REN33` writer - Rising edge enabled 33"]
        pub type REN33_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN34` reader - Rising edge enabled 34"]
        pub type REN34_R = crate::BitReader;
        #[doc = "Field `REN34` writer - Rising edge enabled 34"]
        pub type REN34_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN35` reader - Rising edge enabled 35"]
        pub type REN35_R = crate::BitReader;
        #[doc = "Field `REN35` writer - Rising edge enabled 35"]
        pub type REN35_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN36` reader - Rising edge enabled 36"]
        pub type REN36_R = crate::BitReader;
        #[doc = "Field `REN36` writer - Rising edge enabled 36"]
        pub type REN36_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN37` reader - Rising edge enabled 37"]
        pub type REN37_R = crate::BitReader;
        #[doc = "Field `REN37` writer - Rising edge enabled 37"]
        pub type REN37_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN38` reader - Rising edge enabled 38"]
        pub type REN38_R = crate::BitReader;
        #[doc = "Field `REN38` writer - Rising edge enabled 38"]
        pub type REN38_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN39` reader - Rising edge enabled 39"]
        pub type REN39_R = crate::BitReader;
        #[doc = "Field `REN39` writer - Rising edge enabled 39"]
        pub type REN39_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN40` reader - Rising edge enabled 40"]
        pub type REN40_R = crate::BitReader;
        #[doc = "Field `REN40` writer - Rising edge enabled 40"]
        pub type REN40_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN41` reader - Rising edge enabled 41"]
        pub type REN41_R = crate::BitReader;
        #[doc = "Field `REN41` writer - Rising edge enabled 41"]
        pub type REN41_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN42` reader - Rising edge enabled 42"]
        pub type REN42_R = crate::BitReader;
        #[doc = "Field `REN42` writer - Rising edge enabled 42"]
        pub type REN42_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN43` reader - Rising edge enabled 43"]
        pub type REN43_R = crate::BitReader;
        #[doc = "Field `REN43` writer - Rising edge enabled 43"]
        pub type REN43_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN44` reader - Rising edge enabled 44"]
        pub type REN44_R = crate::BitReader;
        #[doc = "Field `REN44` writer - Rising edge enabled 44"]
        pub type REN44_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN45` reader - Rising edge enabled 45"]
        pub type REN45_R = crate::BitReader;
        #[doc = "Field `REN45` writer - Rising edge enabled 45"]
        pub type REN45_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN46` reader - Rising edge enabled 46"]
        pub type REN46_R = crate::BitReader;
        #[doc = "Field `REN46` writer - Rising edge enabled 46"]
        pub type REN46_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN47` reader - Rising edge enabled 47"]
        pub type REN47_R = crate::BitReader;
        #[doc = "Field `REN47` writer - Rising edge enabled 47"]
        pub type REN47_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN48` reader - Rising edge enabled 48"]
        pub type REN48_R = crate::BitReader;
        #[doc = "Field `REN48` writer - Rising edge enabled 48"]
        pub type REN48_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN49` reader - Rising edge enabled 49"]
        pub type REN49_R = crate::BitReader;
        #[doc = "Field `REN49` writer - Rising edge enabled 49"]
        pub type REN49_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN50` reader - Rising edge enabled 50"]
        pub type REN50_R = crate::BitReader;
        #[doc = "Field `REN50` writer - Rising edge enabled 50"]
        pub type REN50_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN51` reader - Rising edge enabled 51"]
        pub type REN51_R = crate::BitReader;
        #[doc = "Field `REN51` writer - Rising edge enabled 51"]
        pub type REN51_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN52` reader - Rising edge enabled 52"]
        pub type REN52_R = crate::BitReader;
        #[doc = "Field `REN52` writer - Rising edge enabled 52"]
        pub type REN52_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN53` reader - Rising edge enabled 53"]
        pub type REN53_R = crate::BitReader;
        #[doc = "Field `REN53` writer - Rising edge enabled 53"]
        pub type REN53_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Rising edge enabled 32"]
            #[inline(always)]
            pub fn ren32(&self) -> REN32_R {
                REN32_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Rising edge enabled 33"]
            #[inline(always)]
            pub fn ren33(&self) -> REN33_R {
                REN33_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Rising edge enabled 34"]
            #[inline(always)]
            pub fn ren34(&self) -> REN34_R {
                REN34_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Rising edge enabled 35"]
            #[inline(always)]
            pub fn ren35(&self) -> REN35_R {
                REN35_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Rising edge enabled 36"]
            #[inline(always)]
            pub fn ren36(&self) -> REN36_R {
                REN36_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Rising edge enabled 37"]
            #[inline(always)]
            pub fn ren37(&self) -> REN37_R {
                REN37_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Rising edge enabled 38"]
            #[inline(always)]
            pub fn ren38(&self) -> REN38_R {
                REN38_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Rising edge enabled 39"]
            #[inline(always)]
            pub fn ren39(&self) -> REN39_R {
                REN39_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Rising edge enabled 40"]
            #[inline(always)]
            pub fn ren40(&self) -> REN40_R {
                REN40_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Rising edge enabled 41"]
            #[inline(always)]
            pub fn ren41(&self) -> REN41_R {
                REN41_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Rising edge enabled 42"]
            #[inline(always)]
            pub fn ren42(&self) -> REN42_R {
                REN42_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Rising edge enabled 43"]
            #[inline(always)]
            pub fn ren43(&self) -> REN43_R {
                REN43_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Rising edge enabled 44"]
            #[inline(always)]
            pub fn ren44(&self) -> REN44_R {
                REN44_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Rising edge enabled 45"]
            #[inline(always)]
            pub fn ren45(&self) -> REN45_R {
                REN45_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Rising edge enabled 46"]
            #[inline(always)]
            pub fn ren46(&self) -> REN46_R {
                REN46_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Rising edge enabled 47"]
            #[inline(always)]
            pub fn ren47(&self) -> REN47_R {
                REN47_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Rising edge enabled 48"]
            #[inline(always)]
            pub fn ren48(&self) -> REN48_R {
                REN48_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Rising edge enabled 49"]
            #[inline(always)]
            pub fn ren49(&self) -> REN49_R {
                REN49_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Rising edge enabled 50"]
            #[inline(always)]
            pub fn ren50(&self) -> REN50_R {
                REN50_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Rising edge enabled 51"]
            #[inline(always)]
            pub fn ren51(&self) -> REN51_R {
                REN51_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Rising edge enabled 52"]
            #[inline(always)]
            pub fn ren52(&self) -> REN52_R {
                REN52_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Rising edge enabled 53"]
            #[inline(always)]
            pub fn ren53(&self) -> REN53_R {
                REN53_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPREN1")
                    .field("ren32", &format_args!("{}", self.ren32().bit()))
                    .field("ren33", &format_args!("{}", self.ren33().bit()))
                    .field("ren34", &format_args!("{}", self.ren34().bit()))
                    .field("ren35", &format_args!("{}", self.ren35().bit()))
                    .field("ren36", &format_args!("{}", self.ren36().bit()))
                    .field("ren37", &format_args!("{}", self.ren37().bit()))
                    .field("ren38", &format_args!("{}", self.ren38().bit()))
                    .field("ren39", &format_args!("{}", self.ren39().bit()))
                    .field("ren40", &format_args!("{}", self.ren40().bit()))
                    .field("ren41", &format_args!("{}", self.ren41().bit()))
                    .field("ren42", &format_args!("{}", self.ren42().bit()))
                    .field("ren43", &format_args!("{}", self.ren43().bit()))
                    .field("ren44", &format_args!("{}", self.ren44().bit()))
                    .field("ren45", &format_args!("{}", self.ren45().bit()))
                    .field("ren46", &format_args!("{}", self.ren46().bit()))
                    .field("ren47", &format_args!("{}", self.ren47().bit()))
                    .field("ren48", &format_args!("{}", self.ren48().bit()))
                    .field("ren49", &format_args!("{}", self.ren49().bit()))
                    .field("ren50", &format_args!("{}", self.ren50().bit()))
                    .field("ren51", &format_args!("{}", self.ren51().bit()))
                    .field("ren52", &format_args!("{}", self.ren52().bit()))
                    .field("ren53", &format_args!("{}", self.ren53().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPREN1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Rising edge enabled 32"]
            #[inline(always)]
            #[must_use]
            pub fn ren32(&mut self) -> REN32_W<GPREN1_SPEC, 0> {
                REN32_W::new(self)
            }
            #[doc = "Bit 1 - Rising edge enabled 33"]
            #[inline(always)]
            #[must_use]
            pub fn ren33(&mut self) -> REN33_W<GPREN1_SPEC, 1> {
                REN33_W::new(self)
            }
            #[doc = "Bit 2 - Rising edge enabled 34"]
            #[inline(always)]
            #[must_use]
            pub fn ren34(&mut self) -> REN34_W<GPREN1_SPEC, 2> {
                REN34_W::new(self)
            }
            #[doc = "Bit 3 - Rising edge enabled 35"]
            #[inline(always)]
            #[must_use]
            pub fn ren35(&mut self) -> REN35_W<GPREN1_SPEC, 3> {
                REN35_W::new(self)
            }
            #[doc = "Bit 4 - Rising edge enabled 36"]
            #[inline(always)]
            #[must_use]
            pub fn ren36(&mut self) -> REN36_W<GPREN1_SPEC, 4> {
                REN36_W::new(self)
            }
            #[doc = "Bit 5 - Rising edge enabled 37"]
            #[inline(always)]
            #[must_use]
            pub fn ren37(&mut self) -> REN37_W<GPREN1_SPEC, 5> {
                REN37_W::new(self)
            }
            #[doc = "Bit 6 - Rising edge enabled 38"]
            #[inline(always)]
            #[must_use]
            pub fn ren38(&mut self) -> REN38_W<GPREN1_SPEC, 6> {
                REN38_W::new(self)
            }
            #[doc = "Bit 7 - Rising edge enabled 39"]
            #[inline(always)]
            #[must_use]
            pub fn ren39(&mut self) -> REN39_W<GPREN1_SPEC, 7> {
                REN39_W::new(self)
            }
            #[doc = "Bit 8 - Rising edge enabled 40"]
            #[inline(always)]
            #[must_use]
            pub fn ren40(&mut self) -> REN40_W<GPREN1_SPEC, 8> {
                REN40_W::new(self)
            }
            #[doc = "Bit 9 - Rising edge enabled 41"]
            #[inline(always)]
            #[must_use]
            pub fn ren41(&mut self) -> REN41_W<GPREN1_SPEC, 9> {
                REN41_W::new(self)
            }
            #[doc = "Bit 10 - Rising edge enabled 42"]
            #[inline(always)]
            #[must_use]
            pub fn ren42(&mut self) -> REN42_W<GPREN1_SPEC, 10> {
                REN42_W::new(self)
            }
            #[doc = "Bit 11 - Rising edge enabled 43"]
            #[inline(always)]
            #[must_use]
            pub fn ren43(&mut self) -> REN43_W<GPREN1_SPEC, 11> {
                REN43_W::new(self)
            }
            #[doc = "Bit 12 - Rising edge enabled 44"]
            #[inline(always)]
            #[must_use]
            pub fn ren44(&mut self) -> REN44_W<GPREN1_SPEC, 12> {
                REN44_W::new(self)
            }
            #[doc = "Bit 13 - Rising edge enabled 45"]
            #[inline(always)]
            #[must_use]
            pub fn ren45(&mut self) -> REN45_W<GPREN1_SPEC, 13> {
                REN45_W::new(self)
            }
            #[doc = "Bit 14 - Rising edge enabled 46"]
            #[inline(always)]
            #[must_use]
            pub fn ren46(&mut self) -> REN46_W<GPREN1_SPEC, 14> {
                REN46_W::new(self)
            }
            #[doc = "Bit 15 - Rising edge enabled 47"]
            #[inline(always)]
            #[must_use]
            pub fn ren47(&mut self) -> REN47_W<GPREN1_SPEC, 15> {
                REN47_W::new(self)
            }
            #[doc = "Bit 16 - Rising edge enabled 48"]
            #[inline(always)]
            #[must_use]
            pub fn ren48(&mut self) -> REN48_W<GPREN1_SPEC, 16> {
                REN48_W::new(self)
            }
            #[doc = "Bit 17 - Rising edge enabled 49"]
            #[inline(always)]
            #[must_use]
            pub fn ren49(&mut self) -> REN49_W<GPREN1_SPEC, 17> {
                REN49_W::new(self)
            }
            #[doc = "Bit 18 - Rising edge enabled 50"]
            #[inline(always)]
            #[must_use]
            pub fn ren50(&mut self) -> REN50_W<GPREN1_SPEC, 18> {
                REN50_W::new(self)
            }
            #[doc = "Bit 19 - Rising edge enabled 51"]
            #[inline(always)]
            #[must_use]
            pub fn ren51(&mut self) -> REN51_W<GPREN1_SPEC, 19> {
                REN51_W::new(self)
            }
            #[doc = "Bit 20 - Rising edge enabled 52"]
            #[inline(always)]
            #[must_use]
            pub fn ren52(&mut self) -> REN52_W<GPREN1_SPEC, 20> {
                REN52_W::new(self)
            }
            #[doc = "Bit 21 - Rising edge enabled 53"]
            #[inline(always)]
            #[must_use]
            pub fn ren53(&mut self) -> REN53_W<GPREN1_SPEC, 21> {
                REN53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Rising Edge Detect Enable 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpren1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpren1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPREN1_SPEC;
        impl crate::RegisterSpec for GPREN1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpren1::R`](R) reader structure"]
        impl crate::Readable for GPREN1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpren1::W`](W) writer structure"]
        impl crate::Writable for GPREN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPFEN0 (rw) register accessor: GPIO Pin Falling Edge Detect Enable 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfen0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfen0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpfen0`]
module"]
    pub type GPFEN0 = crate::Reg<gpfen0::GPFEN0_SPEC>;
    #[doc = "GPIO Pin Falling Edge Detect Enable 0"]
    pub mod gpfen0 {
        #[doc = "Register `GPFEN0` reader"]
        pub type R = crate::R<GPFEN0_SPEC>;
        #[doc = "Register `GPFEN0` writer"]
        pub type W = crate::W<GPFEN0_SPEC>;
        #[doc = "Field `FEN0` reader - Falling edge enabled 0"]
        pub type FEN0_R = crate::BitReader;
        #[doc = "Field `FEN0` writer - Falling edge enabled 0"]
        pub type FEN0_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN1` reader - Falling edge enabled 1"]
        pub type FEN1_R = crate::BitReader;
        #[doc = "Field `FEN1` writer - Falling edge enabled 1"]
        pub type FEN1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN2` reader - Falling edge enabled 2"]
        pub type FEN2_R = crate::BitReader;
        #[doc = "Field `FEN2` writer - Falling edge enabled 2"]
        pub type FEN2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN3` reader - Falling edge enabled 3"]
        pub type FEN3_R = crate::BitReader;
        #[doc = "Field `FEN3` writer - Falling edge enabled 3"]
        pub type FEN3_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN4` reader - Falling edge enabled 4"]
        pub type FEN4_R = crate::BitReader;
        #[doc = "Field `FEN4` writer - Falling edge enabled 4"]
        pub type FEN4_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN5` reader - Falling edge enabled 5"]
        pub type FEN5_R = crate::BitReader;
        #[doc = "Field `FEN5` writer - Falling edge enabled 5"]
        pub type FEN5_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN6` reader - Falling edge enabled 6"]
        pub type FEN6_R = crate::BitReader;
        #[doc = "Field `FEN6` writer - Falling edge enabled 6"]
        pub type FEN6_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN7` reader - Falling edge enabled 7"]
        pub type FEN7_R = crate::BitReader;
        #[doc = "Field `FEN7` writer - Falling edge enabled 7"]
        pub type FEN7_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN8` reader - Falling edge enabled 8"]
        pub type FEN8_R = crate::BitReader;
        #[doc = "Field `FEN8` writer - Falling edge enabled 8"]
        pub type FEN8_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN9` reader - Falling edge enabled 9"]
        pub type FEN9_R = crate::BitReader;
        #[doc = "Field `FEN9` writer - Falling edge enabled 9"]
        pub type FEN9_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN10` reader - Falling edge enabled 10"]
        pub type FEN10_R = crate::BitReader;
        #[doc = "Field `FEN10` writer - Falling edge enabled 10"]
        pub type FEN10_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN11` reader - Falling edge enabled 11"]
        pub type FEN11_R = crate::BitReader;
        #[doc = "Field `FEN11` writer - Falling edge enabled 11"]
        pub type FEN11_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN12` reader - Falling edge enabled 12"]
        pub type FEN12_R = crate::BitReader;
        #[doc = "Field `FEN12` writer - Falling edge enabled 12"]
        pub type FEN12_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN13` reader - Falling edge enabled 13"]
        pub type FEN13_R = crate::BitReader;
        #[doc = "Field `FEN13` writer - Falling edge enabled 13"]
        pub type FEN13_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN14` reader - Falling edge enabled 14"]
        pub type FEN14_R = crate::BitReader;
        #[doc = "Field `FEN14` writer - Falling edge enabled 14"]
        pub type FEN14_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN15` reader - Falling edge enabled 15"]
        pub type FEN15_R = crate::BitReader;
        #[doc = "Field `FEN15` writer - Falling edge enabled 15"]
        pub type FEN15_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN16` reader - Falling edge enabled 16"]
        pub type FEN16_R = crate::BitReader;
        #[doc = "Field `FEN16` writer - Falling edge enabled 16"]
        pub type FEN16_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN17` reader - Falling edge enabled 17"]
        pub type FEN17_R = crate::BitReader;
        #[doc = "Field `FEN17` writer - Falling edge enabled 17"]
        pub type FEN17_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN18` reader - Falling edge enabled 18"]
        pub type FEN18_R = crate::BitReader;
        #[doc = "Field `FEN18` writer - Falling edge enabled 18"]
        pub type FEN18_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN19` reader - Falling edge enabled 19"]
        pub type FEN19_R = crate::BitReader;
        #[doc = "Field `FEN19` writer - Falling edge enabled 19"]
        pub type FEN19_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN20` reader - Falling edge enabled 20"]
        pub type FEN20_R = crate::BitReader;
        #[doc = "Field `FEN20` writer - Falling edge enabled 20"]
        pub type FEN20_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN21` reader - Falling edge enabled 21"]
        pub type FEN21_R = crate::BitReader;
        #[doc = "Field `FEN21` writer - Falling edge enabled 21"]
        pub type FEN21_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN22` reader - Falling edge enabled 22"]
        pub type FEN22_R = crate::BitReader;
        #[doc = "Field `FEN22` writer - Falling edge enabled 22"]
        pub type FEN22_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN23` reader - Falling edge enabled 23"]
        pub type FEN23_R = crate::BitReader;
        #[doc = "Field `FEN23` writer - Falling edge enabled 23"]
        pub type FEN23_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN24` reader - Falling edge enabled 24"]
        pub type FEN24_R = crate::BitReader;
        #[doc = "Field `FEN24` writer - Falling edge enabled 24"]
        pub type FEN24_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN25` reader - Falling edge enabled 25"]
        pub type FEN25_R = crate::BitReader;
        #[doc = "Field `FEN25` writer - Falling edge enabled 25"]
        pub type FEN25_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN26` reader - Falling edge enabled 26"]
        pub type FEN26_R = crate::BitReader;
        #[doc = "Field `FEN26` writer - Falling edge enabled 26"]
        pub type FEN26_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN27` reader - Falling edge enabled 27"]
        pub type FEN27_R = crate::BitReader;
        #[doc = "Field `FEN27` writer - Falling edge enabled 27"]
        pub type FEN27_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN28` reader - Falling edge enabled 28"]
        pub type FEN28_R = crate::BitReader;
        #[doc = "Field `FEN28` writer - Falling edge enabled 28"]
        pub type FEN28_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN29` reader - Falling edge enabled 29"]
        pub type FEN29_R = crate::BitReader;
        #[doc = "Field `FEN29` writer - Falling edge enabled 29"]
        pub type FEN29_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN30` reader - Falling edge enabled 30"]
        pub type FEN30_R = crate::BitReader;
        #[doc = "Field `FEN30` writer - Falling edge enabled 30"]
        pub type FEN30_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN31` reader - Falling edge enabled 31"]
        pub type FEN31_R = crate::BitReader;
        #[doc = "Field `FEN31` writer - Falling edge enabled 31"]
        pub type FEN31_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Falling edge enabled 0"]
            #[inline(always)]
            pub fn fen0(&self) -> FEN0_R {
                FEN0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Falling edge enabled 1"]
            #[inline(always)]
            pub fn fen1(&self) -> FEN1_R {
                FEN1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Falling edge enabled 2"]
            #[inline(always)]
            pub fn fen2(&self) -> FEN2_R {
                FEN2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Falling edge enabled 3"]
            #[inline(always)]
            pub fn fen3(&self) -> FEN3_R {
                FEN3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Falling edge enabled 4"]
            #[inline(always)]
            pub fn fen4(&self) -> FEN4_R {
                FEN4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Falling edge enabled 5"]
            #[inline(always)]
            pub fn fen5(&self) -> FEN5_R {
                FEN5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Falling edge enabled 6"]
            #[inline(always)]
            pub fn fen6(&self) -> FEN6_R {
                FEN6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Falling edge enabled 7"]
            #[inline(always)]
            pub fn fen7(&self) -> FEN7_R {
                FEN7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Falling edge enabled 8"]
            #[inline(always)]
            pub fn fen8(&self) -> FEN8_R {
                FEN8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Falling edge enabled 9"]
            #[inline(always)]
            pub fn fen9(&self) -> FEN9_R {
                FEN9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Falling edge enabled 10"]
            #[inline(always)]
            pub fn fen10(&self) -> FEN10_R {
                FEN10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Falling edge enabled 11"]
            #[inline(always)]
            pub fn fen11(&self) -> FEN11_R {
                FEN11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Falling edge enabled 12"]
            #[inline(always)]
            pub fn fen12(&self) -> FEN12_R {
                FEN12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Falling edge enabled 13"]
            #[inline(always)]
            pub fn fen13(&self) -> FEN13_R {
                FEN13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Falling edge enabled 14"]
            #[inline(always)]
            pub fn fen14(&self) -> FEN14_R {
                FEN14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Falling edge enabled 15"]
            #[inline(always)]
            pub fn fen15(&self) -> FEN15_R {
                FEN15_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Falling edge enabled 16"]
            #[inline(always)]
            pub fn fen16(&self) -> FEN16_R {
                FEN16_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Falling edge enabled 17"]
            #[inline(always)]
            pub fn fen17(&self) -> FEN17_R {
                FEN17_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Falling edge enabled 18"]
            #[inline(always)]
            pub fn fen18(&self) -> FEN18_R {
                FEN18_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Falling edge enabled 19"]
            #[inline(always)]
            pub fn fen19(&self) -> FEN19_R {
                FEN19_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Falling edge enabled 20"]
            #[inline(always)]
            pub fn fen20(&self) -> FEN20_R {
                FEN20_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Falling edge enabled 21"]
            #[inline(always)]
            pub fn fen21(&self) -> FEN21_R {
                FEN21_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Falling edge enabled 22"]
            #[inline(always)]
            pub fn fen22(&self) -> FEN22_R {
                FEN22_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Falling edge enabled 23"]
            #[inline(always)]
            pub fn fen23(&self) -> FEN23_R {
                FEN23_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Falling edge enabled 24"]
            #[inline(always)]
            pub fn fen24(&self) -> FEN24_R {
                FEN24_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Falling edge enabled 25"]
            #[inline(always)]
            pub fn fen25(&self) -> FEN25_R {
                FEN25_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Falling edge enabled 26"]
            #[inline(always)]
            pub fn fen26(&self) -> FEN26_R {
                FEN26_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Falling edge enabled 27"]
            #[inline(always)]
            pub fn fen27(&self) -> FEN27_R {
                FEN27_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - Falling edge enabled 28"]
            #[inline(always)]
            pub fn fen28(&self) -> FEN28_R {
                FEN28_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Falling edge enabled 29"]
            #[inline(always)]
            pub fn fen29(&self) -> FEN29_R {
                FEN29_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Falling edge enabled 30"]
            #[inline(always)]
            pub fn fen30(&self) -> FEN30_R {
                FEN30_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Falling edge enabled 31"]
            #[inline(always)]
            pub fn fen31(&self) -> FEN31_R {
                FEN31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPFEN0")
                    .field("fen0", &format_args!("{}", self.fen0().bit()))
                    .field("fen1", &format_args!("{}", self.fen1().bit()))
                    .field("fen2", &format_args!("{}", self.fen2().bit()))
                    .field("fen3", &format_args!("{}", self.fen3().bit()))
                    .field("fen4", &format_args!("{}", self.fen4().bit()))
                    .field("fen5", &format_args!("{}", self.fen5().bit()))
                    .field("fen6", &format_args!("{}", self.fen6().bit()))
                    .field("fen7", &format_args!("{}", self.fen7().bit()))
                    .field("fen8", &format_args!("{}", self.fen8().bit()))
                    .field("fen9", &format_args!("{}", self.fen9().bit()))
                    .field("fen10", &format_args!("{}", self.fen10().bit()))
                    .field("fen11", &format_args!("{}", self.fen11().bit()))
                    .field("fen12", &format_args!("{}", self.fen12().bit()))
                    .field("fen13", &format_args!("{}", self.fen13().bit()))
                    .field("fen14", &format_args!("{}", self.fen14().bit()))
                    .field("fen15", &format_args!("{}", self.fen15().bit()))
                    .field("fen16", &format_args!("{}", self.fen16().bit()))
                    .field("fen17", &format_args!("{}", self.fen17().bit()))
                    .field("fen18", &format_args!("{}", self.fen18().bit()))
                    .field("fen19", &format_args!("{}", self.fen19().bit()))
                    .field("fen20", &format_args!("{}", self.fen20().bit()))
                    .field("fen21", &format_args!("{}", self.fen21().bit()))
                    .field("fen22", &format_args!("{}", self.fen22().bit()))
                    .field("fen23", &format_args!("{}", self.fen23().bit()))
                    .field("fen24", &format_args!("{}", self.fen24().bit()))
                    .field("fen25", &format_args!("{}", self.fen25().bit()))
                    .field("fen26", &format_args!("{}", self.fen26().bit()))
                    .field("fen27", &format_args!("{}", self.fen27().bit()))
                    .field("fen28", &format_args!("{}", self.fen28().bit()))
                    .field("fen29", &format_args!("{}", self.fen29().bit()))
                    .field("fen30", &format_args!("{}", self.fen30().bit()))
                    .field("fen31", &format_args!("{}", self.fen31().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPFEN0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Falling edge enabled 0"]
            #[inline(always)]
            #[must_use]
            pub fn fen0(&mut self) -> FEN0_W<GPFEN0_SPEC, 0> {
                FEN0_W::new(self)
            }
            #[doc = "Bit 1 - Falling edge enabled 1"]
            #[inline(always)]
            #[must_use]
            pub fn fen1(&mut self) -> FEN1_W<GPFEN0_SPEC, 1> {
                FEN1_W::new(self)
            }
            #[doc = "Bit 2 - Falling edge enabled 2"]
            #[inline(always)]
            #[must_use]
            pub fn fen2(&mut self) -> FEN2_W<GPFEN0_SPEC, 2> {
                FEN2_W::new(self)
            }
            #[doc = "Bit 3 - Falling edge enabled 3"]
            #[inline(always)]
            #[must_use]
            pub fn fen3(&mut self) -> FEN3_W<GPFEN0_SPEC, 3> {
                FEN3_W::new(self)
            }
            #[doc = "Bit 4 - Falling edge enabled 4"]
            #[inline(always)]
            #[must_use]
            pub fn fen4(&mut self) -> FEN4_W<GPFEN0_SPEC, 4> {
                FEN4_W::new(self)
            }
            #[doc = "Bit 5 - Falling edge enabled 5"]
            #[inline(always)]
            #[must_use]
            pub fn fen5(&mut self) -> FEN5_W<GPFEN0_SPEC, 5> {
                FEN5_W::new(self)
            }
            #[doc = "Bit 6 - Falling edge enabled 6"]
            #[inline(always)]
            #[must_use]
            pub fn fen6(&mut self) -> FEN6_W<GPFEN0_SPEC, 6> {
                FEN6_W::new(self)
            }
            #[doc = "Bit 7 - Falling edge enabled 7"]
            #[inline(always)]
            #[must_use]
            pub fn fen7(&mut self) -> FEN7_W<GPFEN0_SPEC, 7> {
                FEN7_W::new(self)
            }
            #[doc = "Bit 8 - Falling edge enabled 8"]
            #[inline(always)]
            #[must_use]
            pub fn fen8(&mut self) -> FEN8_W<GPFEN0_SPEC, 8> {
                FEN8_W::new(self)
            }
            #[doc = "Bit 9 - Falling edge enabled 9"]
            #[inline(always)]
            #[must_use]
            pub fn fen9(&mut self) -> FEN9_W<GPFEN0_SPEC, 9> {
                FEN9_W::new(self)
            }
            #[doc = "Bit 10 - Falling edge enabled 10"]
            #[inline(always)]
            #[must_use]
            pub fn fen10(&mut self) -> FEN10_W<GPFEN0_SPEC, 10> {
                FEN10_W::new(self)
            }
            #[doc = "Bit 11 - Falling edge enabled 11"]
            #[inline(always)]
            #[must_use]
            pub fn fen11(&mut self) -> FEN11_W<GPFEN0_SPEC, 11> {
                FEN11_W::new(self)
            }
            #[doc = "Bit 12 - Falling edge enabled 12"]
            #[inline(always)]
            #[must_use]
            pub fn fen12(&mut self) -> FEN12_W<GPFEN0_SPEC, 12> {
                FEN12_W::new(self)
            }
            #[doc = "Bit 13 - Falling edge enabled 13"]
            #[inline(always)]
            #[must_use]
            pub fn fen13(&mut self) -> FEN13_W<GPFEN0_SPEC, 13> {
                FEN13_W::new(self)
            }
            #[doc = "Bit 14 - Falling edge enabled 14"]
            #[inline(always)]
            #[must_use]
            pub fn fen14(&mut self) -> FEN14_W<GPFEN0_SPEC, 14> {
                FEN14_W::new(self)
            }
            #[doc = "Bit 15 - Falling edge enabled 15"]
            #[inline(always)]
            #[must_use]
            pub fn fen15(&mut self) -> FEN15_W<GPFEN0_SPEC, 15> {
                FEN15_W::new(self)
            }
            #[doc = "Bit 16 - Falling edge enabled 16"]
            #[inline(always)]
            #[must_use]
            pub fn fen16(&mut self) -> FEN16_W<GPFEN0_SPEC, 16> {
                FEN16_W::new(self)
            }
            #[doc = "Bit 17 - Falling edge enabled 17"]
            #[inline(always)]
            #[must_use]
            pub fn fen17(&mut self) -> FEN17_W<GPFEN0_SPEC, 17> {
                FEN17_W::new(self)
            }
            #[doc = "Bit 18 - Falling edge enabled 18"]
            #[inline(always)]
            #[must_use]
            pub fn fen18(&mut self) -> FEN18_W<GPFEN0_SPEC, 18> {
                FEN18_W::new(self)
            }
            #[doc = "Bit 19 - Falling edge enabled 19"]
            #[inline(always)]
            #[must_use]
            pub fn fen19(&mut self) -> FEN19_W<GPFEN0_SPEC, 19> {
                FEN19_W::new(self)
            }
            #[doc = "Bit 20 - Falling edge enabled 20"]
            #[inline(always)]
            #[must_use]
            pub fn fen20(&mut self) -> FEN20_W<GPFEN0_SPEC, 20> {
                FEN20_W::new(self)
            }
            #[doc = "Bit 21 - Falling edge enabled 21"]
            #[inline(always)]
            #[must_use]
            pub fn fen21(&mut self) -> FEN21_W<GPFEN0_SPEC, 21> {
                FEN21_W::new(self)
            }
            #[doc = "Bit 22 - Falling edge enabled 22"]
            #[inline(always)]
            #[must_use]
            pub fn fen22(&mut self) -> FEN22_W<GPFEN0_SPEC, 22> {
                FEN22_W::new(self)
            }
            #[doc = "Bit 23 - Falling edge enabled 23"]
            #[inline(always)]
            #[must_use]
            pub fn fen23(&mut self) -> FEN23_W<GPFEN0_SPEC, 23> {
                FEN23_W::new(self)
            }
            #[doc = "Bit 24 - Falling edge enabled 24"]
            #[inline(always)]
            #[must_use]
            pub fn fen24(&mut self) -> FEN24_W<GPFEN0_SPEC, 24> {
                FEN24_W::new(self)
            }
            #[doc = "Bit 25 - Falling edge enabled 25"]
            #[inline(always)]
            #[must_use]
            pub fn fen25(&mut self) -> FEN25_W<GPFEN0_SPEC, 25> {
                FEN25_W::new(self)
            }
            #[doc = "Bit 26 - Falling edge enabled 26"]
            #[inline(always)]
            #[must_use]
            pub fn fen26(&mut self) -> FEN26_W<GPFEN0_SPEC, 26> {
                FEN26_W::new(self)
            }
            #[doc = "Bit 27 - Falling edge enabled 27"]
            #[inline(always)]
            #[must_use]
            pub fn fen27(&mut self) -> FEN27_W<GPFEN0_SPEC, 27> {
                FEN27_W::new(self)
            }
            #[doc = "Bit 28 - Falling edge enabled 28"]
            #[inline(always)]
            #[must_use]
            pub fn fen28(&mut self) -> FEN28_W<GPFEN0_SPEC, 28> {
                FEN28_W::new(self)
            }
            #[doc = "Bit 29 - Falling edge enabled 29"]
            #[inline(always)]
            #[must_use]
            pub fn fen29(&mut self) -> FEN29_W<GPFEN0_SPEC, 29> {
                FEN29_W::new(self)
            }
            #[doc = "Bit 30 - Falling edge enabled 30"]
            #[inline(always)]
            #[must_use]
            pub fn fen30(&mut self) -> FEN30_W<GPFEN0_SPEC, 30> {
                FEN30_W::new(self)
            }
            #[doc = "Bit 31 - Falling edge enabled 31"]
            #[inline(always)]
            #[must_use]
            pub fn fen31(&mut self) -> FEN31_W<GPFEN0_SPEC, 31> {
                FEN31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Falling Edge Detect Enable 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfen0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfen0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPFEN0_SPEC;
        impl crate::RegisterSpec for GPFEN0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpfen0::R`](R) reader structure"]
        impl crate::Readable for GPFEN0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpfen0::W`](W) writer structure"]
        impl crate::Writable for GPFEN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPFEN1 (rw) register accessor: GPIO Pin Falling Edge Detect Enable 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfen1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfen1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpfen1`]
module"]
    pub type GPFEN1 = crate::Reg<gpfen1::GPFEN1_SPEC>;
    #[doc = "GPIO Pin Falling Edge Detect Enable 1"]
    pub mod gpfen1 {
        #[doc = "Register `GPFEN1` reader"]
        pub type R = crate::R<GPFEN1_SPEC>;
        #[doc = "Register `GPFEN1` writer"]
        pub type W = crate::W<GPFEN1_SPEC>;
        #[doc = "Field `FEN32` reader - Falling edge enabled 32"]
        pub type FEN32_R = crate::BitReader;
        #[doc = "Field `FEN32` writer - Falling edge enabled 32"]
        pub type FEN32_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN33` reader - Falling edge enabled 33"]
        pub type FEN33_R = crate::BitReader;
        #[doc = "Field `FEN33` writer - Falling edge enabled 33"]
        pub type FEN33_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN34` reader - Falling edge enabled 34"]
        pub type FEN34_R = crate::BitReader;
        #[doc = "Field `FEN34` writer - Falling edge enabled 34"]
        pub type FEN34_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN35` reader - Falling edge enabled 35"]
        pub type FEN35_R = crate::BitReader;
        #[doc = "Field `FEN35` writer - Falling edge enabled 35"]
        pub type FEN35_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN36` reader - Falling edge enabled 36"]
        pub type FEN36_R = crate::BitReader;
        #[doc = "Field `FEN36` writer - Falling edge enabled 36"]
        pub type FEN36_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN37` reader - Falling edge enabled 37"]
        pub type FEN37_R = crate::BitReader;
        #[doc = "Field `FEN37` writer - Falling edge enabled 37"]
        pub type FEN37_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN38` reader - Falling edge enabled 38"]
        pub type FEN38_R = crate::BitReader;
        #[doc = "Field `FEN38` writer - Falling edge enabled 38"]
        pub type FEN38_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN39` reader - Falling edge enabled 39"]
        pub type FEN39_R = crate::BitReader;
        #[doc = "Field `FEN39` writer - Falling edge enabled 39"]
        pub type FEN39_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN40` reader - Falling edge enabled 40"]
        pub type FEN40_R = crate::BitReader;
        #[doc = "Field `FEN40` writer - Falling edge enabled 40"]
        pub type FEN40_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN41` reader - Falling edge enabled 41"]
        pub type FEN41_R = crate::BitReader;
        #[doc = "Field `FEN41` writer - Falling edge enabled 41"]
        pub type FEN41_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN42` reader - Falling edge enabled 42"]
        pub type FEN42_R = crate::BitReader;
        #[doc = "Field `FEN42` writer - Falling edge enabled 42"]
        pub type FEN42_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN43` reader - Falling edge enabled 43"]
        pub type FEN43_R = crate::BitReader;
        #[doc = "Field `FEN43` writer - Falling edge enabled 43"]
        pub type FEN43_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN44` reader - Falling edge enabled 44"]
        pub type FEN44_R = crate::BitReader;
        #[doc = "Field `FEN44` writer - Falling edge enabled 44"]
        pub type FEN44_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN45` reader - Falling edge enabled 45"]
        pub type FEN45_R = crate::BitReader;
        #[doc = "Field `FEN45` writer - Falling edge enabled 45"]
        pub type FEN45_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN46` reader - Falling edge enabled 46"]
        pub type FEN46_R = crate::BitReader;
        #[doc = "Field `FEN46` writer - Falling edge enabled 46"]
        pub type FEN46_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN47` reader - Falling edge enabled 47"]
        pub type FEN47_R = crate::BitReader;
        #[doc = "Field `FEN47` writer - Falling edge enabled 47"]
        pub type FEN47_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN48` reader - Falling edge enabled 48"]
        pub type FEN48_R = crate::BitReader;
        #[doc = "Field `FEN48` writer - Falling edge enabled 48"]
        pub type FEN48_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN49` reader - Falling edge enabled 49"]
        pub type FEN49_R = crate::BitReader;
        #[doc = "Field `FEN49` writer - Falling edge enabled 49"]
        pub type FEN49_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN50` reader - Falling edge enabled 50"]
        pub type FEN50_R = crate::BitReader;
        #[doc = "Field `FEN50` writer - Falling edge enabled 50"]
        pub type FEN50_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN51` reader - Falling edge enabled 51"]
        pub type FEN51_R = crate::BitReader;
        #[doc = "Field `FEN51` writer - Falling edge enabled 51"]
        pub type FEN51_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN52` reader - Falling edge enabled 52"]
        pub type FEN52_R = crate::BitReader;
        #[doc = "Field `FEN52` writer - Falling edge enabled 52"]
        pub type FEN52_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN53` reader - Falling edge enabled 53"]
        pub type FEN53_R = crate::BitReader;
        #[doc = "Field `FEN53` writer - Falling edge enabled 53"]
        pub type FEN53_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Falling edge enabled 32"]
            #[inline(always)]
            pub fn fen32(&self) -> FEN32_R {
                FEN32_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Falling edge enabled 33"]
            #[inline(always)]
            pub fn fen33(&self) -> FEN33_R {
                FEN33_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Falling edge enabled 34"]
            #[inline(always)]
            pub fn fen34(&self) -> FEN34_R {
                FEN34_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Falling edge enabled 35"]
            #[inline(always)]
            pub fn fen35(&self) -> FEN35_R {
                FEN35_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Falling edge enabled 36"]
            #[inline(always)]
            pub fn fen36(&self) -> FEN36_R {
                FEN36_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Falling edge enabled 37"]
            #[inline(always)]
            pub fn fen37(&self) -> FEN37_R {
                FEN37_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Falling edge enabled 38"]
            #[inline(always)]
            pub fn fen38(&self) -> FEN38_R {
                FEN38_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Falling edge enabled 39"]
            #[inline(always)]
            pub fn fen39(&self) -> FEN39_R {
                FEN39_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Falling edge enabled 40"]
            #[inline(always)]
            pub fn fen40(&self) -> FEN40_R {
                FEN40_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Falling edge enabled 41"]
            #[inline(always)]
            pub fn fen41(&self) -> FEN41_R {
                FEN41_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Falling edge enabled 42"]
            #[inline(always)]
            pub fn fen42(&self) -> FEN42_R {
                FEN42_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Falling edge enabled 43"]
            #[inline(always)]
            pub fn fen43(&self) -> FEN43_R {
                FEN43_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Falling edge enabled 44"]
            #[inline(always)]
            pub fn fen44(&self) -> FEN44_R {
                FEN44_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Falling edge enabled 45"]
            #[inline(always)]
            pub fn fen45(&self) -> FEN45_R {
                FEN45_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Falling edge enabled 46"]
            #[inline(always)]
            pub fn fen46(&self) -> FEN46_R {
                FEN46_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Falling edge enabled 47"]
            #[inline(always)]
            pub fn fen47(&self) -> FEN47_R {
                FEN47_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Falling edge enabled 48"]
            #[inline(always)]
            pub fn fen48(&self) -> FEN48_R {
                FEN48_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Falling edge enabled 49"]
            #[inline(always)]
            pub fn fen49(&self) -> FEN49_R {
                FEN49_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Falling edge enabled 50"]
            #[inline(always)]
            pub fn fen50(&self) -> FEN50_R {
                FEN50_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Falling edge enabled 51"]
            #[inline(always)]
            pub fn fen51(&self) -> FEN51_R {
                FEN51_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Falling edge enabled 52"]
            #[inline(always)]
            pub fn fen52(&self) -> FEN52_R {
                FEN52_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Falling edge enabled 53"]
            #[inline(always)]
            pub fn fen53(&self) -> FEN53_R {
                FEN53_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPFEN1")
                    .field("fen32", &format_args!("{}", self.fen32().bit()))
                    .field("fen33", &format_args!("{}", self.fen33().bit()))
                    .field("fen34", &format_args!("{}", self.fen34().bit()))
                    .field("fen35", &format_args!("{}", self.fen35().bit()))
                    .field("fen36", &format_args!("{}", self.fen36().bit()))
                    .field("fen37", &format_args!("{}", self.fen37().bit()))
                    .field("fen38", &format_args!("{}", self.fen38().bit()))
                    .field("fen39", &format_args!("{}", self.fen39().bit()))
                    .field("fen40", &format_args!("{}", self.fen40().bit()))
                    .field("fen41", &format_args!("{}", self.fen41().bit()))
                    .field("fen42", &format_args!("{}", self.fen42().bit()))
                    .field("fen43", &format_args!("{}", self.fen43().bit()))
                    .field("fen44", &format_args!("{}", self.fen44().bit()))
                    .field("fen45", &format_args!("{}", self.fen45().bit()))
                    .field("fen46", &format_args!("{}", self.fen46().bit()))
                    .field("fen47", &format_args!("{}", self.fen47().bit()))
                    .field("fen48", &format_args!("{}", self.fen48().bit()))
                    .field("fen49", &format_args!("{}", self.fen49().bit()))
                    .field("fen50", &format_args!("{}", self.fen50().bit()))
                    .field("fen51", &format_args!("{}", self.fen51().bit()))
                    .field("fen52", &format_args!("{}", self.fen52().bit()))
                    .field("fen53", &format_args!("{}", self.fen53().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPFEN1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Falling edge enabled 32"]
            #[inline(always)]
            #[must_use]
            pub fn fen32(&mut self) -> FEN32_W<GPFEN1_SPEC, 0> {
                FEN32_W::new(self)
            }
            #[doc = "Bit 1 - Falling edge enabled 33"]
            #[inline(always)]
            #[must_use]
            pub fn fen33(&mut self) -> FEN33_W<GPFEN1_SPEC, 1> {
                FEN33_W::new(self)
            }
            #[doc = "Bit 2 - Falling edge enabled 34"]
            #[inline(always)]
            #[must_use]
            pub fn fen34(&mut self) -> FEN34_W<GPFEN1_SPEC, 2> {
                FEN34_W::new(self)
            }
            #[doc = "Bit 3 - Falling edge enabled 35"]
            #[inline(always)]
            #[must_use]
            pub fn fen35(&mut self) -> FEN35_W<GPFEN1_SPEC, 3> {
                FEN35_W::new(self)
            }
            #[doc = "Bit 4 - Falling edge enabled 36"]
            #[inline(always)]
            #[must_use]
            pub fn fen36(&mut self) -> FEN36_W<GPFEN1_SPEC, 4> {
                FEN36_W::new(self)
            }
            #[doc = "Bit 5 - Falling edge enabled 37"]
            #[inline(always)]
            #[must_use]
            pub fn fen37(&mut self) -> FEN37_W<GPFEN1_SPEC, 5> {
                FEN37_W::new(self)
            }
            #[doc = "Bit 6 - Falling edge enabled 38"]
            #[inline(always)]
            #[must_use]
            pub fn fen38(&mut self) -> FEN38_W<GPFEN1_SPEC, 6> {
                FEN38_W::new(self)
            }
            #[doc = "Bit 7 - Falling edge enabled 39"]
            #[inline(always)]
            #[must_use]
            pub fn fen39(&mut self) -> FEN39_W<GPFEN1_SPEC, 7> {
                FEN39_W::new(self)
            }
            #[doc = "Bit 8 - Falling edge enabled 40"]
            #[inline(always)]
            #[must_use]
            pub fn fen40(&mut self) -> FEN40_W<GPFEN1_SPEC, 8> {
                FEN40_W::new(self)
            }
            #[doc = "Bit 9 - Falling edge enabled 41"]
            #[inline(always)]
            #[must_use]
            pub fn fen41(&mut self) -> FEN41_W<GPFEN1_SPEC, 9> {
                FEN41_W::new(self)
            }
            #[doc = "Bit 10 - Falling edge enabled 42"]
            #[inline(always)]
            #[must_use]
            pub fn fen42(&mut self) -> FEN42_W<GPFEN1_SPEC, 10> {
                FEN42_W::new(self)
            }
            #[doc = "Bit 11 - Falling edge enabled 43"]
            #[inline(always)]
            #[must_use]
            pub fn fen43(&mut self) -> FEN43_W<GPFEN1_SPEC, 11> {
                FEN43_W::new(self)
            }
            #[doc = "Bit 12 - Falling edge enabled 44"]
            #[inline(always)]
            #[must_use]
            pub fn fen44(&mut self) -> FEN44_W<GPFEN1_SPEC, 12> {
                FEN44_W::new(self)
            }
            #[doc = "Bit 13 - Falling edge enabled 45"]
            #[inline(always)]
            #[must_use]
            pub fn fen45(&mut self) -> FEN45_W<GPFEN1_SPEC, 13> {
                FEN45_W::new(self)
            }
            #[doc = "Bit 14 - Falling edge enabled 46"]
            #[inline(always)]
            #[must_use]
            pub fn fen46(&mut self) -> FEN46_W<GPFEN1_SPEC, 14> {
                FEN46_W::new(self)
            }
            #[doc = "Bit 15 - Falling edge enabled 47"]
            #[inline(always)]
            #[must_use]
            pub fn fen47(&mut self) -> FEN47_W<GPFEN1_SPEC, 15> {
                FEN47_W::new(self)
            }
            #[doc = "Bit 16 - Falling edge enabled 48"]
            #[inline(always)]
            #[must_use]
            pub fn fen48(&mut self) -> FEN48_W<GPFEN1_SPEC, 16> {
                FEN48_W::new(self)
            }
            #[doc = "Bit 17 - Falling edge enabled 49"]
            #[inline(always)]
            #[must_use]
            pub fn fen49(&mut self) -> FEN49_W<GPFEN1_SPEC, 17> {
                FEN49_W::new(self)
            }
            #[doc = "Bit 18 - Falling edge enabled 50"]
            #[inline(always)]
            #[must_use]
            pub fn fen50(&mut self) -> FEN50_W<GPFEN1_SPEC, 18> {
                FEN50_W::new(self)
            }
            #[doc = "Bit 19 - Falling edge enabled 51"]
            #[inline(always)]
            #[must_use]
            pub fn fen51(&mut self) -> FEN51_W<GPFEN1_SPEC, 19> {
                FEN51_W::new(self)
            }
            #[doc = "Bit 20 - Falling edge enabled 52"]
            #[inline(always)]
            #[must_use]
            pub fn fen52(&mut self) -> FEN52_W<GPFEN1_SPEC, 20> {
                FEN52_W::new(self)
            }
            #[doc = "Bit 21 - Falling edge enabled 53"]
            #[inline(always)]
            #[must_use]
            pub fn fen53(&mut self) -> FEN53_W<GPFEN1_SPEC, 21> {
                FEN53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Falling Edge Detect Enable 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpfen1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpfen1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPFEN1_SPEC;
        impl crate::RegisterSpec for GPFEN1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpfen1::R`](R) reader structure"]
        impl crate::Readable for GPFEN1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpfen1::W`](W) writer structure"]
        impl crate::Writable for GPFEN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPHEN0 (rw) register accessor: GPIO Pin High Detect Enable 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gphen0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gphen0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gphen0`]
module"]
    pub type GPHEN0 = crate::Reg<gphen0::GPHEN0_SPEC>;
    #[doc = "GPIO Pin High Detect Enable 0"]
    pub mod gphen0 {
        #[doc = "Register `GPHEN0` reader"]
        pub type R = crate::R<GPHEN0_SPEC>;
        #[doc = "Register `GPHEN0` writer"]
        pub type W = crate::W<GPHEN0_SPEC>;
        #[doc = "Field `HEN0` reader - High detect enabled 0"]
        pub type HEN0_R = crate::BitReader;
        #[doc = "Field `HEN0` writer - High detect enabled 0"]
        pub type HEN0_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN1` reader - High detect enabled 1"]
        pub type HEN1_R = crate::BitReader;
        #[doc = "Field `HEN1` writer - High detect enabled 1"]
        pub type HEN1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN2` reader - High detect enabled 2"]
        pub type HEN2_R = crate::BitReader;
        #[doc = "Field `HEN2` writer - High detect enabled 2"]
        pub type HEN2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN3` reader - High detect enabled 3"]
        pub type HEN3_R = crate::BitReader;
        #[doc = "Field `HEN3` writer - High detect enabled 3"]
        pub type HEN3_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN4` reader - High detect enabled 4"]
        pub type HEN4_R = crate::BitReader;
        #[doc = "Field `HEN4` writer - High detect enabled 4"]
        pub type HEN4_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN5` reader - High detect enabled 5"]
        pub type HEN5_R = crate::BitReader;
        #[doc = "Field `HEN5` writer - High detect enabled 5"]
        pub type HEN5_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN6` reader - High detect enabled 6"]
        pub type HEN6_R = crate::BitReader;
        #[doc = "Field `HEN6` writer - High detect enabled 6"]
        pub type HEN6_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN7` reader - High detect enabled 7"]
        pub type HEN7_R = crate::BitReader;
        #[doc = "Field `HEN7` writer - High detect enabled 7"]
        pub type HEN7_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN8` reader - High detect enabled 8"]
        pub type HEN8_R = crate::BitReader;
        #[doc = "Field `HEN8` writer - High detect enabled 8"]
        pub type HEN8_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN9` reader - High detect enabled 9"]
        pub type HEN9_R = crate::BitReader;
        #[doc = "Field `HEN9` writer - High detect enabled 9"]
        pub type HEN9_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN10` reader - High detect enabled 10"]
        pub type HEN10_R = crate::BitReader;
        #[doc = "Field `HEN10` writer - High detect enabled 10"]
        pub type HEN10_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN11` reader - High detect enabled 11"]
        pub type HEN11_R = crate::BitReader;
        #[doc = "Field `HEN11` writer - High detect enabled 11"]
        pub type HEN11_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN12` reader - High detect enabled 12"]
        pub type HEN12_R = crate::BitReader;
        #[doc = "Field `HEN12` writer - High detect enabled 12"]
        pub type HEN12_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN13` reader - High detect enabled 13"]
        pub type HEN13_R = crate::BitReader;
        #[doc = "Field `HEN13` writer - High detect enabled 13"]
        pub type HEN13_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN14` reader - High detect enabled 14"]
        pub type HEN14_R = crate::BitReader;
        #[doc = "Field `HEN14` writer - High detect enabled 14"]
        pub type HEN14_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN15` reader - High detect enabled 15"]
        pub type HEN15_R = crate::BitReader;
        #[doc = "Field `HEN15` writer - High detect enabled 15"]
        pub type HEN15_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN16` reader - High detect enabled 16"]
        pub type HEN16_R = crate::BitReader;
        #[doc = "Field `HEN16` writer - High detect enabled 16"]
        pub type HEN16_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN17` reader - High detect enabled 17"]
        pub type HEN17_R = crate::BitReader;
        #[doc = "Field `HEN17` writer - High detect enabled 17"]
        pub type HEN17_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN18` reader - High detect enabled 18"]
        pub type HEN18_R = crate::BitReader;
        #[doc = "Field `HEN18` writer - High detect enabled 18"]
        pub type HEN18_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN19` reader - High detect enabled 19"]
        pub type HEN19_R = crate::BitReader;
        #[doc = "Field `HEN19` writer - High detect enabled 19"]
        pub type HEN19_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN20` reader - High detect enabled 20"]
        pub type HEN20_R = crate::BitReader;
        #[doc = "Field `HEN20` writer - High detect enabled 20"]
        pub type HEN20_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN21` reader - High detect enabled 21"]
        pub type HEN21_R = crate::BitReader;
        #[doc = "Field `HEN21` writer - High detect enabled 21"]
        pub type HEN21_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN22` reader - High detect enabled 22"]
        pub type HEN22_R = crate::BitReader;
        #[doc = "Field `HEN22` writer - High detect enabled 22"]
        pub type HEN22_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN23` reader - High detect enabled 23"]
        pub type HEN23_R = crate::BitReader;
        #[doc = "Field `HEN23` writer - High detect enabled 23"]
        pub type HEN23_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN24` reader - High detect enabled 24"]
        pub type HEN24_R = crate::BitReader;
        #[doc = "Field `HEN24` writer - High detect enabled 24"]
        pub type HEN24_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN25` reader - High detect enabled 25"]
        pub type HEN25_R = crate::BitReader;
        #[doc = "Field `HEN25` writer - High detect enabled 25"]
        pub type HEN25_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN26` reader - High detect enabled 26"]
        pub type HEN26_R = crate::BitReader;
        #[doc = "Field `HEN26` writer - High detect enabled 26"]
        pub type HEN26_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN27` reader - High detect enabled 27"]
        pub type HEN27_R = crate::BitReader;
        #[doc = "Field `HEN27` writer - High detect enabled 27"]
        pub type HEN27_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN28` reader - High detect enabled 28"]
        pub type HEN28_R = crate::BitReader;
        #[doc = "Field `HEN28` writer - High detect enabled 28"]
        pub type HEN28_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN29` reader - High detect enabled 29"]
        pub type HEN29_R = crate::BitReader;
        #[doc = "Field `HEN29` writer - High detect enabled 29"]
        pub type HEN29_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN30` reader - High detect enabled 30"]
        pub type HEN30_R = crate::BitReader;
        #[doc = "Field `HEN30` writer - High detect enabled 30"]
        pub type HEN30_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN31` reader - High detect enabled 31"]
        pub type HEN31_R = crate::BitReader;
        #[doc = "Field `HEN31` writer - High detect enabled 31"]
        pub type HEN31_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - High detect enabled 0"]
            #[inline(always)]
            pub fn hen0(&self) -> HEN0_R {
                HEN0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - High detect enabled 1"]
            #[inline(always)]
            pub fn hen1(&self) -> HEN1_R {
                HEN1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - High detect enabled 2"]
            #[inline(always)]
            pub fn hen2(&self) -> HEN2_R {
                HEN2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - High detect enabled 3"]
            #[inline(always)]
            pub fn hen3(&self) -> HEN3_R {
                HEN3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - High detect enabled 4"]
            #[inline(always)]
            pub fn hen4(&self) -> HEN4_R {
                HEN4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - High detect enabled 5"]
            #[inline(always)]
            pub fn hen5(&self) -> HEN5_R {
                HEN5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - High detect enabled 6"]
            #[inline(always)]
            pub fn hen6(&self) -> HEN6_R {
                HEN6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - High detect enabled 7"]
            #[inline(always)]
            pub fn hen7(&self) -> HEN7_R {
                HEN7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - High detect enabled 8"]
            #[inline(always)]
            pub fn hen8(&self) -> HEN8_R {
                HEN8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - High detect enabled 9"]
            #[inline(always)]
            pub fn hen9(&self) -> HEN9_R {
                HEN9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - High detect enabled 10"]
            #[inline(always)]
            pub fn hen10(&self) -> HEN10_R {
                HEN10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - High detect enabled 11"]
            #[inline(always)]
            pub fn hen11(&self) -> HEN11_R {
                HEN11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - High detect enabled 12"]
            #[inline(always)]
            pub fn hen12(&self) -> HEN12_R {
                HEN12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - High detect enabled 13"]
            #[inline(always)]
            pub fn hen13(&self) -> HEN13_R {
                HEN13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - High detect enabled 14"]
            #[inline(always)]
            pub fn hen14(&self) -> HEN14_R {
                HEN14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - High detect enabled 15"]
            #[inline(always)]
            pub fn hen15(&self) -> HEN15_R {
                HEN15_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - High detect enabled 16"]
            #[inline(always)]
            pub fn hen16(&self) -> HEN16_R {
                HEN16_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - High detect enabled 17"]
            #[inline(always)]
            pub fn hen17(&self) -> HEN17_R {
                HEN17_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - High detect enabled 18"]
            #[inline(always)]
            pub fn hen18(&self) -> HEN18_R {
                HEN18_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - High detect enabled 19"]
            #[inline(always)]
            pub fn hen19(&self) -> HEN19_R {
                HEN19_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - High detect enabled 20"]
            #[inline(always)]
            pub fn hen20(&self) -> HEN20_R {
                HEN20_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - High detect enabled 21"]
            #[inline(always)]
            pub fn hen21(&self) -> HEN21_R {
                HEN21_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - High detect enabled 22"]
            #[inline(always)]
            pub fn hen22(&self) -> HEN22_R {
                HEN22_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - High detect enabled 23"]
            #[inline(always)]
            pub fn hen23(&self) -> HEN23_R {
                HEN23_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - High detect enabled 24"]
            #[inline(always)]
            pub fn hen24(&self) -> HEN24_R {
                HEN24_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - High detect enabled 25"]
            #[inline(always)]
            pub fn hen25(&self) -> HEN25_R {
                HEN25_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - High detect enabled 26"]
            #[inline(always)]
            pub fn hen26(&self) -> HEN26_R {
                HEN26_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - High detect enabled 27"]
            #[inline(always)]
            pub fn hen27(&self) -> HEN27_R {
                HEN27_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - High detect enabled 28"]
            #[inline(always)]
            pub fn hen28(&self) -> HEN28_R {
                HEN28_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - High detect enabled 29"]
            #[inline(always)]
            pub fn hen29(&self) -> HEN29_R {
                HEN29_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - High detect enabled 30"]
            #[inline(always)]
            pub fn hen30(&self) -> HEN30_R {
                HEN30_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - High detect enabled 31"]
            #[inline(always)]
            pub fn hen31(&self) -> HEN31_R {
                HEN31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPHEN0")
                    .field("hen0", &format_args!("{}", self.hen0().bit()))
                    .field("hen1", &format_args!("{}", self.hen1().bit()))
                    .field("hen2", &format_args!("{}", self.hen2().bit()))
                    .field("hen3", &format_args!("{}", self.hen3().bit()))
                    .field("hen4", &format_args!("{}", self.hen4().bit()))
                    .field("hen5", &format_args!("{}", self.hen5().bit()))
                    .field("hen6", &format_args!("{}", self.hen6().bit()))
                    .field("hen7", &format_args!("{}", self.hen7().bit()))
                    .field("hen8", &format_args!("{}", self.hen8().bit()))
                    .field("hen9", &format_args!("{}", self.hen9().bit()))
                    .field("hen10", &format_args!("{}", self.hen10().bit()))
                    .field("hen11", &format_args!("{}", self.hen11().bit()))
                    .field("hen12", &format_args!("{}", self.hen12().bit()))
                    .field("hen13", &format_args!("{}", self.hen13().bit()))
                    .field("hen14", &format_args!("{}", self.hen14().bit()))
                    .field("hen15", &format_args!("{}", self.hen15().bit()))
                    .field("hen16", &format_args!("{}", self.hen16().bit()))
                    .field("hen17", &format_args!("{}", self.hen17().bit()))
                    .field("hen18", &format_args!("{}", self.hen18().bit()))
                    .field("hen19", &format_args!("{}", self.hen19().bit()))
                    .field("hen20", &format_args!("{}", self.hen20().bit()))
                    .field("hen21", &format_args!("{}", self.hen21().bit()))
                    .field("hen22", &format_args!("{}", self.hen22().bit()))
                    .field("hen23", &format_args!("{}", self.hen23().bit()))
                    .field("hen24", &format_args!("{}", self.hen24().bit()))
                    .field("hen25", &format_args!("{}", self.hen25().bit()))
                    .field("hen26", &format_args!("{}", self.hen26().bit()))
                    .field("hen27", &format_args!("{}", self.hen27().bit()))
                    .field("hen28", &format_args!("{}", self.hen28().bit()))
                    .field("hen29", &format_args!("{}", self.hen29().bit()))
                    .field("hen30", &format_args!("{}", self.hen30().bit()))
                    .field("hen31", &format_args!("{}", self.hen31().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPHEN0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - High detect enabled 0"]
            #[inline(always)]
            #[must_use]
            pub fn hen0(&mut self) -> HEN0_W<GPHEN0_SPEC, 0> {
                HEN0_W::new(self)
            }
            #[doc = "Bit 1 - High detect enabled 1"]
            #[inline(always)]
            #[must_use]
            pub fn hen1(&mut self) -> HEN1_W<GPHEN0_SPEC, 1> {
                HEN1_W::new(self)
            }
            #[doc = "Bit 2 - High detect enabled 2"]
            #[inline(always)]
            #[must_use]
            pub fn hen2(&mut self) -> HEN2_W<GPHEN0_SPEC, 2> {
                HEN2_W::new(self)
            }
            #[doc = "Bit 3 - High detect enabled 3"]
            #[inline(always)]
            #[must_use]
            pub fn hen3(&mut self) -> HEN3_W<GPHEN0_SPEC, 3> {
                HEN3_W::new(self)
            }
            #[doc = "Bit 4 - High detect enabled 4"]
            #[inline(always)]
            #[must_use]
            pub fn hen4(&mut self) -> HEN4_W<GPHEN0_SPEC, 4> {
                HEN4_W::new(self)
            }
            #[doc = "Bit 5 - High detect enabled 5"]
            #[inline(always)]
            #[must_use]
            pub fn hen5(&mut self) -> HEN5_W<GPHEN0_SPEC, 5> {
                HEN5_W::new(self)
            }
            #[doc = "Bit 6 - High detect enabled 6"]
            #[inline(always)]
            #[must_use]
            pub fn hen6(&mut self) -> HEN6_W<GPHEN0_SPEC, 6> {
                HEN6_W::new(self)
            }
            #[doc = "Bit 7 - High detect enabled 7"]
            #[inline(always)]
            #[must_use]
            pub fn hen7(&mut self) -> HEN7_W<GPHEN0_SPEC, 7> {
                HEN7_W::new(self)
            }
            #[doc = "Bit 8 - High detect enabled 8"]
            #[inline(always)]
            #[must_use]
            pub fn hen8(&mut self) -> HEN8_W<GPHEN0_SPEC, 8> {
                HEN8_W::new(self)
            }
            #[doc = "Bit 9 - High detect enabled 9"]
            #[inline(always)]
            #[must_use]
            pub fn hen9(&mut self) -> HEN9_W<GPHEN0_SPEC, 9> {
                HEN9_W::new(self)
            }
            #[doc = "Bit 10 - High detect enabled 10"]
            #[inline(always)]
            #[must_use]
            pub fn hen10(&mut self) -> HEN10_W<GPHEN0_SPEC, 10> {
                HEN10_W::new(self)
            }
            #[doc = "Bit 11 - High detect enabled 11"]
            #[inline(always)]
            #[must_use]
            pub fn hen11(&mut self) -> HEN11_W<GPHEN0_SPEC, 11> {
                HEN11_W::new(self)
            }
            #[doc = "Bit 12 - High detect enabled 12"]
            #[inline(always)]
            #[must_use]
            pub fn hen12(&mut self) -> HEN12_W<GPHEN0_SPEC, 12> {
                HEN12_W::new(self)
            }
            #[doc = "Bit 13 - High detect enabled 13"]
            #[inline(always)]
            #[must_use]
            pub fn hen13(&mut self) -> HEN13_W<GPHEN0_SPEC, 13> {
                HEN13_W::new(self)
            }
            #[doc = "Bit 14 - High detect enabled 14"]
            #[inline(always)]
            #[must_use]
            pub fn hen14(&mut self) -> HEN14_W<GPHEN0_SPEC, 14> {
                HEN14_W::new(self)
            }
            #[doc = "Bit 15 - High detect enabled 15"]
            #[inline(always)]
            #[must_use]
            pub fn hen15(&mut self) -> HEN15_W<GPHEN0_SPEC, 15> {
                HEN15_W::new(self)
            }
            #[doc = "Bit 16 - High detect enabled 16"]
            #[inline(always)]
            #[must_use]
            pub fn hen16(&mut self) -> HEN16_W<GPHEN0_SPEC, 16> {
                HEN16_W::new(self)
            }
            #[doc = "Bit 17 - High detect enabled 17"]
            #[inline(always)]
            #[must_use]
            pub fn hen17(&mut self) -> HEN17_W<GPHEN0_SPEC, 17> {
                HEN17_W::new(self)
            }
            #[doc = "Bit 18 - High detect enabled 18"]
            #[inline(always)]
            #[must_use]
            pub fn hen18(&mut self) -> HEN18_W<GPHEN0_SPEC, 18> {
                HEN18_W::new(self)
            }
            #[doc = "Bit 19 - High detect enabled 19"]
            #[inline(always)]
            #[must_use]
            pub fn hen19(&mut self) -> HEN19_W<GPHEN0_SPEC, 19> {
                HEN19_W::new(self)
            }
            #[doc = "Bit 20 - High detect enabled 20"]
            #[inline(always)]
            #[must_use]
            pub fn hen20(&mut self) -> HEN20_W<GPHEN0_SPEC, 20> {
                HEN20_W::new(self)
            }
            #[doc = "Bit 21 - High detect enabled 21"]
            #[inline(always)]
            #[must_use]
            pub fn hen21(&mut self) -> HEN21_W<GPHEN0_SPEC, 21> {
                HEN21_W::new(self)
            }
            #[doc = "Bit 22 - High detect enabled 22"]
            #[inline(always)]
            #[must_use]
            pub fn hen22(&mut self) -> HEN22_W<GPHEN0_SPEC, 22> {
                HEN22_W::new(self)
            }
            #[doc = "Bit 23 - High detect enabled 23"]
            #[inline(always)]
            #[must_use]
            pub fn hen23(&mut self) -> HEN23_W<GPHEN0_SPEC, 23> {
                HEN23_W::new(self)
            }
            #[doc = "Bit 24 - High detect enabled 24"]
            #[inline(always)]
            #[must_use]
            pub fn hen24(&mut self) -> HEN24_W<GPHEN0_SPEC, 24> {
                HEN24_W::new(self)
            }
            #[doc = "Bit 25 - High detect enabled 25"]
            #[inline(always)]
            #[must_use]
            pub fn hen25(&mut self) -> HEN25_W<GPHEN0_SPEC, 25> {
                HEN25_W::new(self)
            }
            #[doc = "Bit 26 - High detect enabled 26"]
            #[inline(always)]
            #[must_use]
            pub fn hen26(&mut self) -> HEN26_W<GPHEN0_SPEC, 26> {
                HEN26_W::new(self)
            }
            #[doc = "Bit 27 - High detect enabled 27"]
            #[inline(always)]
            #[must_use]
            pub fn hen27(&mut self) -> HEN27_W<GPHEN0_SPEC, 27> {
                HEN27_W::new(self)
            }
            #[doc = "Bit 28 - High detect enabled 28"]
            #[inline(always)]
            #[must_use]
            pub fn hen28(&mut self) -> HEN28_W<GPHEN0_SPEC, 28> {
                HEN28_W::new(self)
            }
            #[doc = "Bit 29 - High detect enabled 29"]
            #[inline(always)]
            #[must_use]
            pub fn hen29(&mut self) -> HEN29_W<GPHEN0_SPEC, 29> {
                HEN29_W::new(self)
            }
            #[doc = "Bit 30 - High detect enabled 30"]
            #[inline(always)]
            #[must_use]
            pub fn hen30(&mut self) -> HEN30_W<GPHEN0_SPEC, 30> {
                HEN30_W::new(self)
            }
            #[doc = "Bit 31 - High detect enabled 31"]
            #[inline(always)]
            #[must_use]
            pub fn hen31(&mut self) -> HEN31_W<GPHEN0_SPEC, 31> {
                HEN31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin High Detect Enable 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gphen0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gphen0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPHEN0_SPEC;
        impl crate::RegisterSpec for GPHEN0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gphen0::R`](R) reader structure"]
        impl crate::Readable for GPHEN0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gphen0::W`](W) writer structure"]
        impl crate::Writable for GPHEN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPHEN1 (rw) register accessor: GPIO Pin High Detect Enable 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gphen1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gphen1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gphen1`]
module"]
    pub type GPHEN1 = crate::Reg<gphen1::GPHEN1_SPEC>;
    #[doc = "GPIO Pin High Detect Enable 1"]
    pub mod gphen1 {
        #[doc = "Register `GPHEN1` reader"]
        pub type R = crate::R<GPHEN1_SPEC>;
        #[doc = "Register `GPHEN1` writer"]
        pub type W = crate::W<GPHEN1_SPEC>;
        #[doc = "Field `HEN32` reader - High detect enabled 32"]
        pub type HEN32_R = crate::BitReader;
        #[doc = "Field `HEN32` writer - High detect enabled 32"]
        pub type HEN32_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN33` reader - High detect enabled 33"]
        pub type HEN33_R = crate::BitReader;
        #[doc = "Field `HEN33` writer - High detect enabled 33"]
        pub type HEN33_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN34` reader - High detect enabled 34"]
        pub type HEN34_R = crate::BitReader;
        #[doc = "Field `HEN34` writer - High detect enabled 34"]
        pub type HEN34_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN35` reader - High detect enabled 35"]
        pub type HEN35_R = crate::BitReader;
        #[doc = "Field `HEN35` writer - High detect enabled 35"]
        pub type HEN35_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN36` reader - High detect enabled 36"]
        pub type HEN36_R = crate::BitReader;
        #[doc = "Field `HEN36` writer - High detect enabled 36"]
        pub type HEN36_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN37` reader - High detect enabled 37"]
        pub type HEN37_R = crate::BitReader;
        #[doc = "Field `HEN37` writer - High detect enabled 37"]
        pub type HEN37_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN38` reader - High detect enabled 38"]
        pub type HEN38_R = crate::BitReader;
        #[doc = "Field `HEN38` writer - High detect enabled 38"]
        pub type HEN38_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN39` reader - High detect enabled 39"]
        pub type HEN39_R = crate::BitReader;
        #[doc = "Field `HEN39` writer - High detect enabled 39"]
        pub type HEN39_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN40` reader - High detect enabled 40"]
        pub type HEN40_R = crate::BitReader;
        #[doc = "Field `HEN40` writer - High detect enabled 40"]
        pub type HEN40_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN41` reader - High detect enabled 41"]
        pub type HEN41_R = crate::BitReader;
        #[doc = "Field `HEN41` writer - High detect enabled 41"]
        pub type HEN41_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN42` reader - High detect enabled 42"]
        pub type HEN42_R = crate::BitReader;
        #[doc = "Field `HEN42` writer - High detect enabled 42"]
        pub type HEN42_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN43` reader - High detect enabled 43"]
        pub type HEN43_R = crate::BitReader;
        #[doc = "Field `HEN43` writer - High detect enabled 43"]
        pub type HEN43_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN44` reader - High detect enabled 44"]
        pub type HEN44_R = crate::BitReader;
        #[doc = "Field `HEN44` writer - High detect enabled 44"]
        pub type HEN44_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN45` reader - High detect enabled 45"]
        pub type HEN45_R = crate::BitReader;
        #[doc = "Field `HEN45` writer - High detect enabled 45"]
        pub type HEN45_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN46` reader - High detect enabled 46"]
        pub type HEN46_R = crate::BitReader;
        #[doc = "Field `HEN46` writer - High detect enabled 46"]
        pub type HEN46_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN47` reader - High detect enabled 47"]
        pub type HEN47_R = crate::BitReader;
        #[doc = "Field `HEN47` writer - High detect enabled 47"]
        pub type HEN47_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN48` reader - High detect enabled 48"]
        pub type HEN48_R = crate::BitReader;
        #[doc = "Field `HEN48` writer - High detect enabled 48"]
        pub type HEN48_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN49` reader - High detect enabled 49"]
        pub type HEN49_R = crate::BitReader;
        #[doc = "Field `HEN49` writer - High detect enabled 49"]
        pub type HEN49_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN50` reader - High detect enabled 50"]
        pub type HEN50_R = crate::BitReader;
        #[doc = "Field `HEN50` writer - High detect enabled 50"]
        pub type HEN50_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN51` reader - High detect enabled 51"]
        pub type HEN51_R = crate::BitReader;
        #[doc = "Field `HEN51` writer - High detect enabled 51"]
        pub type HEN51_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN52` reader - High detect enabled 52"]
        pub type HEN52_R = crate::BitReader;
        #[doc = "Field `HEN52` writer - High detect enabled 52"]
        pub type HEN52_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HEN53` reader - High detect enabled 53"]
        pub type HEN53_R = crate::BitReader;
        #[doc = "Field `HEN53` writer - High detect enabled 53"]
        pub type HEN53_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - High detect enabled 32"]
            #[inline(always)]
            pub fn hen32(&self) -> HEN32_R {
                HEN32_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - High detect enabled 33"]
            #[inline(always)]
            pub fn hen33(&self) -> HEN33_R {
                HEN33_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - High detect enabled 34"]
            #[inline(always)]
            pub fn hen34(&self) -> HEN34_R {
                HEN34_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - High detect enabled 35"]
            #[inline(always)]
            pub fn hen35(&self) -> HEN35_R {
                HEN35_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - High detect enabled 36"]
            #[inline(always)]
            pub fn hen36(&self) -> HEN36_R {
                HEN36_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - High detect enabled 37"]
            #[inline(always)]
            pub fn hen37(&self) -> HEN37_R {
                HEN37_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - High detect enabled 38"]
            #[inline(always)]
            pub fn hen38(&self) -> HEN38_R {
                HEN38_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - High detect enabled 39"]
            #[inline(always)]
            pub fn hen39(&self) -> HEN39_R {
                HEN39_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - High detect enabled 40"]
            #[inline(always)]
            pub fn hen40(&self) -> HEN40_R {
                HEN40_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - High detect enabled 41"]
            #[inline(always)]
            pub fn hen41(&self) -> HEN41_R {
                HEN41_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - High detect enabled 42"]
            #[inline(always)]
            pub fn hen42(&self) -> HEN42_R {
                HEN42_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - High detect enabled 43"]
            #[inline(always)]
            pub fn hen43(&self) -> HEN43_R {
                HEN43_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - High detect enabled 44"]
            #[inline(always)]
            pub fn hen44(&self) -> HEN44_R {
                HEN44_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - High detect enabled 45"]
            #[inline(always)]
            pub fn hen45(&self) -> HEN45_R {
                HEN45_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - High detect enabled 46"]
            #[inline(always)]
            pub fn hen46(&self) -> HEN46_R {
                HEN46_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - High detect enabled 47"]
            #[inline(always)]
            pub fn hen47(&self) -> HEN47_R {
                HEN47_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - High detect enabled 48"]
            #[inline(always)]
            pub fn hen48(&self) -> HEN48_R {
                HEN48_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - High detect enabled 49"]
            #[inline(always)]
            pub fn hen49(&self) -> HEN49_R {
                HEN49_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - High detect enabled 50"]
            #[inline(always)]
            pub fn hen50(&self) -> HEN50_R {
                HEN50_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - High detect enabled 51"]
            #[inline(always)]
            pub fn hen51(&self) -> HEN51_R {
                HEN51_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - High detect enabled 52"]
            #[inline(always)]
            pub fn hen52(&self) -> HEN52_R {
                HEN52_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - High detect enabled 53"]
            #[inline(always)]
            pub fn hen53(&self) -> HEN53_R {
                HEN53_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPHEN1")
                    .field("hen32", &format_args!("{}", self.hen32().bit()))
                    .field("hen33", &format_args!("{}", self.hen33().bit()))
                    .field("hen34", &format_args!("{}", self.hen34().bit()))
                    .field("hen35", &format_args!("{}", self.hen35().bit()))
                    .field("hen36", &format_args!("{}", self.hen36().bit()))
                    .field("hen37", &format_args!("{}", self.hen37().bit()))
                    .field("hen38", &format_args!("{}", self.hen38().bit()))
                    .field("hen39", &format_args!("{}", self.hen39().bit()))
                    .field("hen40", &format_args!("{}", self.hen40().bit()))
                    .field("hen41", &format_args!("{}", self.hen41().bit()))
                    .field("hen42", &format_args!("{}", self.hen42().bit()))
                    .field("hen43", &format_args!("{}", self.hen43().bit()))
                    .field("hen44", &format_args!("{}", self.hen44().bit()))
                    .field("hen45", &format_args!("{}", self.hen45().bit()))
                    .field("hen46", &format_args!("{}", self.hen46().bit()))
                    .field("hen47", &format_args!("{}", self.hen47().bit()))
                    .field("hen48", &format_args!("{}", self.hen48().bit()))
                    .field("hen49", &format_args!("{}", self.hen49().bit()))
                    .field("hen50", &format_args!("{}", self.hen50().bit()))
                    .field("hen51", &format_args!("{}", self.hen51().bit()))
                    .field("hen52", &format_args!("{}", self.hen52().bit()))
                    .field("hen53", &format_args!("{}", self.hen53().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPHEN1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - High detect enabled 32"]
            #[inline(always)]
            #[must_use]
            pub fn hen32(&mut self) -> HEN32_W<GPHEN1_SPEC, 0> {
                HEN32_W::new(self)
            }
            #[doc = "Bit 1 - High detect enabled 33"]
            #[inline(always)]
            #[must_use]
            pub fn hen33(&mut self) -> HEN33_W<GPHEN1_SPEC, 1> {
                HEN33_W::new(self)
            }
            #[doc = "Bit 2 - High detect enabled 34"]
            #[inline(always)]
            #[must_use]
            pub fn hen34(&mut self) -> HEN34_W<GPHEN1_SPEC, 2> {
                HEN34_W::new(self)
            }
            #[doc = "Bit 3 - High detect enabled 35"]
            #[inline(always)]
            #[must_use]
            pub fn hen35(&mut self) -> HEN35_W<GPHEN1_SPEC, 3> {
                HEN35_W::new(self)
            }
            #[doc = "Bit 4 - High detect enabled 36"]
            #[inline(always)]
            #[must_use]
            pub fn hen36(&mut self) -> HEN36_W<GPHEN1_SPEC, 4> {
                HEN36_W::new(self)
            }
            #[doc = "Bit 5 - High detect enabled 37"]
            #[inline(always)]
            #[must_use]
            pub fn hen37(&mut self) -> HEN37_W<GPHEN1_SPEC, 5> {
                HEN37_W::new(self)
            }
            #[doc = "Bit 6 - High detect enabled 38"]
            #[inline(always)]
            #[must_use]
            pub fn hen38(&mut self) -> HEN38_W<GPHEN1_SPEC, 6> {
                HEN38_W::new(self)
            }
            #[doc = "Bit 7 - High detect enabled 39"]
            #[inline(always)]
            #[must_use]
            pub fn hen39(&mut self) -> HEN39_W<GPHEN1_SPEC, 7> {
                HEN39_W::new(self)
            }
            #[doc = "Bit 8 - High detect enabled 40"]
            #[inline(always)]
            #[must_use]
            pub fn hen40(&mut self) -> HEN40_W<GPHEN1_SPEC, 8> {
                HEN40_W::new(self)
            }
            #[doc = "Bit 9 - High detect enabled 41"]
            #[inline(always)]
            #[must_use]
            pub fn hen41(&mut self) -> HEN41_W<GPHEN1_SPEC, 9> {
                HEN41_W::new(self)
            }
            #[doc = "Bit 10 - High detect enabled 42"]
            #[inline(always)]
            #[must_use]
            pub fn hen42(&mut self) -> HEN42_W<GPHEN1_SPEC, 10> {
                HEN42_W::new(self)
            }
            #[doc = "Bit 11 - High detect enabled 43"]
            #[inline(always)]
            #[must_use]
            pub fn hen43(&mut self) -> HEN43_W<GPHEN1_SPEC, 11> {
                HEN43_W::new(self)
            }
            #[doc = "Bit 12 - High detect enabled 44"]
            #[inline(always)]
            #[must_use]
            pub fn hen44(&mut self) -> HEN44_W<GPHEN1_SPEC, 12> {
                HEN44_W::new(self)
            }
            #[doc = "Bit 13 - High detect enabled 45"]
            #[inline(always)]
            #[must_use]
            pub fn hen45(&mut self) -> HEN45_W<GPHEN1_SPEC, 13> {
                HEN45_W::new(self)
            }
            #[doc = "Bit 14 - High detect enabled 46"]
            #[inline(always)]
            #[must_use]
            pub fn hen46(&mut self) -> HEN46_W<GPHEN1_SPEC, 14> {
                HEN46_W::new(self)
            }
            #[doc = "Bit 15 - High detect enabled 47"]
            #[inline(always)]
            #[must_use]
            pub fn hen47(&mut self) -> HEN47_W<GPHEN1_SPEC, 15> {
                HEN47_W::new(self)
            }
            #[doc = "Bit 16 - High detect enabled 48"]
            #[inline(always)]
            #[must_use]
            pub fn hen48(&mut self) -> HEN48_W<GPHEN1_SPEC, 16> {
                HEN48_W::new(self)
            }
            #[doc = "Bit 17 - High detect enabled 49"]
            #[inline(always)]
            #[must_use]
            pub fn hen49(&mut self) -> HEN49_W<GPHEN1_SPEC, 17> {
                HEN49_W::new(self)
            }
            #[doc = "Bit 18 - High detect enabled 50"]
            #[inline(always)]
            #[must_use]
            pub fn hen50(&mut self) -> HEN50_W<GPHEN1_SPEC, 18> {
                HEN50_W::new(self)
            }
            #[doc = "Bit 19 - High detect enabled 51"]
            #[inline(always)]
            #[must_use]
            pub fn hen51(&mut self) -> HEN51_W<GPHEN1_SPEC, 19> {
                HEN51_W::new(self)
            }
            #[doc = "Bit 20 - High detect enabled 52"]
            #[inline(always)]
            #[must_use]
            pub fn hen52(&mut self) -> HEN52_W<GPHEN1_SPEC, 20> {
                HEN52_W::new(self)
            }
            #[doc = "Bit 21 - High detect enabled 53"]
            #[inline(always)]
            #[must_use]
            pub fn hen53(&mut self) -> HEN53_W<GPHEN1_SPEC, 21> {
                HEN53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin High Detect Enable 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gphen1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gphen1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPHEN1_SPEC;
        impl crate::RegisterSpec for GPHEN1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gphen1::R`](R) reader structure"]
        impl crate::Readable for GPHEN1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gphen1::W`](W) writer structure"]
        impl crate::Writable for GPHEN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPLEN0 (rw) register accessor: GPIO Pin Low Detect Enable 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gplen0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gplen0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gplen0`]
module"]
    pub type GPLEN0 = crate::Reg<gplen0::GPLEN0_SPEC>;
    #[doc = "GPIO Pin Low Detect Enable 0"]
    pub mod gplen0 {
        #[doc = "Register `GPLEN0` reader"]
        pub type R = crate::R<GPLEN0_SPEC>;
        #[doc = "Register `GPLEN0` writer"]
        pub type W = crate::W<GPLEN0_SPEC>;
        #[doc = "Field `LEN0` reader - Low detect enabled 0"]
        pub type LEN0_R = crate::BitReader;
        #[doc = "Field `LEN0` writer - Low detect enabled 0"]
        pub type LEN0_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN1` reader - Low detect enabled 1"]
        pub type LEN1_R = crate::BitReader;
        #[doc = "Field `LEN1` writer - Low detect enabled 1"]
        pub type LEN1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN2` reader - Low detect enabled 2"]
        pub type LEN2_R = crate::BitReader;
        #[doc = "Field `LEN2` writer - Low detect enabled 2"]
        pub type LEN2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN3` reader - Low detect enabled 3"]
        pub type LEN3_R = crate::BitReader;
        #[doc = "Field `LEN3` writer - Low detect enabled 3"]
        pub type LEN3_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN4` reader - Low detect enabled 4"]
        pub type LEN4_R = crate::BitReader;
        #[doc = "Field `LEN4` writer - Low detect enabled 4"]
        pub type LEN4_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN5` reader - Low detect enabled 5"]
        pub type LEN5_R = crate::BitReader;
        #[doc = "Field `LEN5` writer - Low detect enabled 5"]
        pub type LEN5_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN6` reader - Low detect enabled 6"]
        pub type LEN6_R = crate::BitReader;
        #[doc = "Field `LEN6` writer - Low detect enabled 6"]
        pub type LEN6_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN7` reader - Low detect enabled 7"]
        pub type LEN7_R = crate::BitReader;
        #[doc = "Field `LEN7` writer - Low detect enabled 7"]
        pub type LEN7_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN8` reader - Low detect enabled 8"]
        pub type LEN8_R = crate::BitReader;
        #[doc = "Field `LEN8` writer - Low detect enabled 8"]
        pub type LEN8_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN9` reader - Low detect enabled 9"]
        pub type LEN9_R = crate::BitReader;
        #[doc = "Field `LEN9` writer - Low detect enabled 9"]
        pub type LEN9_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN10` reader - Low detect enabled 10"]
        pub type LEN10_R = crate::BitReader;
        #[doc = "Field `LEN10` writer - Low detect enabled 10"]
        pub type LEN10_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN11` reader - Low detect enabled 11"]
        pub type LEN11_R = crate::BitReader;
        #[doc = "Field `LEN11` writer - Low detect enabled 11"]
        pub type LEN11_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN12` reader - Low detect enabled 12"]
        pub type LEN12_R = crate::BitReader;
        #[doc = "Field `LEN12` writer - Low detect enabled 12"]
        pub type LEN12_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN13` reader - Low detect enabled 13"]
        pub type LEN13_R = crate::BitReader;
        #[doc = "Field `LEN13` writer - Low detect enabled 13"]
        pub type LEN13_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN14` reader - Low detect enabled 14"]
        pub type LEN14_R = crate::BitReader;
        #[doc = "Field `LEN14` writer - Low detect enabled 14"]
        pub type LEN14_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN15` reader - Low detect enabled 15"]
        pub type LEN15_R = crate::BitReader;
        #[doc = "Field `LEN15` writer - Low detect enabled 15"]
        pub type LEN15_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN16` reader - Low detect enabled 16"]
        pub type LEN16_R = crate::BitReader;
        #[doc = "Field `LEN16` writer - Low detect enabled 16"]
        pub type LEN16_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN17` reader - Low detect enabled 17"]
        pub type LEN17_R = crate::BitReader;
        #[doc = "Field `LEN17` writer - Low detect enabled 17"]
        pub type LEN17_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN18` reader - Low detect enabled 18"]
        pub type LEN18_R = crate::BitReader;
        #[doc = "Field `LEN18` writer - Low detect enabled 18"]
        pub type LEN18_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN19` reader - Low detect enabled 19"]
        pub type LEN19_R = crate::BitReader;
        #[doc = "Field `LEN19` writer - Low detect enabled 19"]
        pub type LEN19_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN20` reader - Low detect enabled 20"]
        pub type LEN20_R = crate::BitReader;
        #[doc = "Field `LEN20` writer - Low detect enabled 20"]
        pub type LEN20_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN21` reader - Low detect enabled 21"]
        pub type LEN21_R = crate::BitReader;
        #[doc = "Field `LEN21` writer - Low detect enabled 21"]
        pub type LEN21_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN22` reader - Low detect enabled 22"]
        pub type LEN22_R = crate::BitReader;
        #[doc = "Field `LEN22` writer - Low detect enabled 22"]
        pub type LEN22_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN23` reader - Low detect enabled 23"]
        pub type LEN23_R = crate::BitReader;
        #[doc = "Field `LEN23` writer - Low detect enabled 23"]
        pub type LEN23_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN24` reader - Low detect enabled 24"]
        pub type LEN24_R = crate::BitReader;
        #[doc = "Field `LEN24` writer - Low detect enabled 24"]
        pub type LEN24_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN25` reader - Low detect enabled 25"]
        pub type LEN25_R = crate::BitReader;
        #[doc = "Field `LEN25` writer - Low detect enabled 25"]
        pub type LEN25_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN26` reader - Low detect enabled 26"]
        pub type LEN26_R = crate::BitReader;
        #[doc = "Field `LEN26` writer - Low detect enabled 26"]
        pub type LEN26_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN27` reader - Low detect enabled 27"]
        pub type LEN27_R = crate::BitReader;
        #[doc = "Field `LEN27` writer - Low detect enabled 27"]
        pub type LEN27_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN28` reader - Low detect enabled 28"]
        pub type LEN28_R = crate::BitReader;
        #[doc = "Field `LEN28` writer - Low detect enabled 28"]
        pub type LEN28_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN29` reader - Low detect enabled 29"]
        pub type LEN29_R = crate::BitReader;
        #[doc = "Field `LEN29` writer - Low detect enabled 29"]
        pub type LEN29_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN30` reader - Low detect enabled 30"]
        pub type LEN30_R = crate::BitReader;
        #[doc = "Field `LEN30` writer - Low detect enabled 30"]
        pub type LEN30_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN31` reader - Low detect enabled 31"]
        pub type LEN31_R = crate::BitReader;
        #[doc = "Field `LEN31` writer - Low detect enabled 31"]
        pub type LEN31_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Low detect enabled 0"]
            #[inline(always)]
            pub fn len0(&self) -> LEN0_R {
                LEN0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Low detect enabled 1"]
            #[inline(always)]
            pub fn len1(&self) -> LEN1_R {
                LEN1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Low detect enabled 2"]
            #[inline(always)]
            pub fn len2(&self) -> LEN2_R {
                LEN2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Low detect enabled 3"]
            #[inline(always)]
            pub fn len3(&self) -> LEN3_R {
                LEN3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Low detect enabled 4"]
            #[inline(always)]
            pub fn len4(&self) -> LEN4_R {
                LEN4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Low detect enabled 5"]
            #[inline(always)]
            pub fn len5(&self) -> LEN5_R {
                LEN5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Low detect enabled 6"]
            #[inline(always)]
            pub fn len6(&self) -> LEN6_R {
                LEN6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Low detect enabled 7"]
            #[inline(always)]
            pub fn len7(&self) -> LEN7_R {
                LEN7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Low detect enabled 8"]
            #[inline(always)]
            pub fn len8(&self) -> LEN8_R {
                LEN8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Low detect enabled 9"]
            #[inline(always)]
            pub fn len9(&self) -> LEN9_R {
                LEN9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Low detect enabled 10"]
            #[inline(always)]
            pub fn len10(&self) -> LEN10_R {
                LEN10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Low detect enabled 11"]
            #[inline(always)]
            pub fn len11(&self) -> LEN11_R {
                LEN11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Low detect enabled 12"]
            #[inline(always)]
            pub fn len12(&self) -> LEN12_R {
                LEN12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Low detect enabled 13"]
            #[inline(always)]
            pub fn len13(&self) -> LEN13_R {
                LEN13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Low detect enabled 14"]
            #[inline(always)]
            pub fn len14(&self) -> LEN14_R {
                LEN14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Low detect enabled 15"]
            #[inline(always)]
            pub fn len15(&self) -> LEN15_R {
                LEN15_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Low detect enabled 16"]
            #[inline(always)]
            pub fn len16(&self) -> LEN16_R {
                LEN16_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Low detect enabled 17"]
            #[inline(always)]
            pub fn len17(&self) -> LEN17_R {
                LEN17_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Low detect enabled 18"]
            #[inline(always)]
            pub fn len18(&self) -> LEN18_R {
                LEN18_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Low detect enabled 19"]
            #[inline(always)]
            pub fn len19(&self) -> LEN19_R {
                LEN19_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Low detect enabled 20"]
            #[inline(always)]
            pub fn len20(&self) -> LEN20_R {
                LEN20_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Low detect enabled 21"]
            #[inline(always)]
            pub fn len21(&self) -> LEN21_R {
                LEN21_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Low detect enabled 22"]
            #[inline(always)]
            pub fn len22(&self) -> LEN22_R {
                LEN22_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Low detect enabled 23"]
            #[inline(always)]
            pub fn len23(&self) -> LEN23_R {
                LEN23_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Low detect enabled 24"]
            #[inline(always)]
            pub fn len24(&self) -> LEN24_R {
                LEN24_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Low detect enabled 25"]
            #[inline(always)]
            pub fn len25(&self) -> LEN25_R {
                LEN25_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Low detect enabled 26"]
            #[inline(always)]
            pub fn len26(&self) -> LEN26_R {
                LEN26_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Low detect enabled 27"]
            #[inline(always)]
            pub fn len27(&self) -> LEN27_R {
                LEN27_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - Low detect enabled 28"]
            #[inline(always)]
            pub fn len28(&self) -> LEN28_R {
                LEN28_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Low detect enabled 29"]
            #[inline(always)]
            pub fn len29(&self) -> LEN29_R {
                LEN29_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Low detect enabled 30"]
            #[inline(always)]
            pub fn len30(&self) -> LEN30_R {
                LEN30_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Low detect enabled 31"]
            #[inline(always)]
            pub fn len31(&self) -> LEN31_R {
                LEN31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPLEN0")
                    .field("len0", &format_args!("{}", self.len0().bit()))
                    .field("len1", &format_args!("{}", self.len1().bit()))
                    .field("len2", &format_args!("{}", self.len2().bit()))
                    .field("len3", &format_args!("{}", self.len3().bit()))
                    .field("len4", &format_args!("{}", self.len4().bit()))
                    .field("len5", &format_args!("{}", self.len5().bit()))
                    .field("len6", &format_args!("{}", self.len6().bit()))
                    .field("len7", &format_args!("{}", self.len7().bit()))
                    .field("len8", &format_args!("{}", self.len8().bit()))
                    .field("len9", &format_args!("{}", self.len9().bit()))
                    .field("len10", &format_args!("{}", self.len10().bit()))
                    .field("len11", &format_args!("{}", self.len11().bit()))
                    .field("len12", &format_args!("{}", self.len12().bit()))
                    .field("len13", &format_args!("{}", self.len13().bit()))
                    .field("len14", &format_args!("{}", self.len14().bit()))
                    .field("len15", &format_args!("{}", self.len15().bit()))
                    .field("len16", &format_args!("{}", self.len16().bit()))
                    .field("len17", &format_args!("{}", self.len17().bit()))
                    .field("len18", &format_args!("{}", self.len18().bit()))
                    .field("len19", &format_args!("{}", self.len19().bit()))
                    .field("len20", &format_args!("{}", self.len20().bit()))
                    .field("len21", &format_args!("{}", self.len21().bit()))
                    .field("len22", &format_args!("{}", self.len22().bit()))
                    .field("len23", &format_args!("{}", self.len23().bit()))
                    .field("len24", &format_args!("{}", self.len24().bit()))
                    .field("len25", &format_args!("{}", self.len25().bit()))
                    .field("len26", &format_args!("{}", self.len26().bit()))
                    .field("len27", &format_args!("{}", self.len27().bit()))
                    .field("len28", &format_args!("{}", self.len28().bit()))
                    .field("len29", &format_args!("{}", self.len29().bit()))
                    .field("len30", &format_args!("{}", self.len30().bit()))
                    .field("len31", &format_args!("{}", self.len31().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPLEN0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Low detect enabled 0"]
            #[inline(always)]
            #[must_use]
            pub fn len0(&mut self) -> LEN0_W<GPLEN0_SPEC, 0> {
                LEN0_W::new(self)
            }
            #[doc = "Bit 1 - Low detect enabled 1"]
            #[inline(always)]
            #[must_use]
            pub fn len1(&mut self) -> LEN1_W<GPLEN0_SPEC, 1> {
                LEN1_W::new(self)
            }
            #[doc = "Bit 2 - Low detect enabled 2"]
            #[inline(always)]
            #[must_use]
            pub fn len2(&mut self) -> LEN2_W<GPLEN0_SPEC, 2> {
                LEN2_W::new(self)
            }
            #[doc = "Bit 3 - Low detect enabled 3"]
            #[inline(always)]
            #[must_use]
            pub fn len3(&mut self) -> LEN3_W<GPLEN0_SPEC, 3> {
                LEN3_W::new(self)
            }
            #[doc = "Bit 4 - Low detect enabled 4"]
            #[inline(always)]
            #[must_use]
            pub fn len4(&mut self) -> LEN4_W<GPLEN0_SPEC, 4> {
                LEN4_W::new(self)
            }
            #[doc = "Bit 5 - Low detect enabled 5"]
            #[inline(always)]
            #[must_use]
            pub fn len5(&mut self) -> LEN5_W<GPLEN0_SPEC, 5> {
                LEN5_W::new(self)
            }
            #[doc = "Bit 6 - Low detect enabled 6"]
            #[inline(always)]
            #[must_use]
            pub fn len6(&mut self) -> LEN6_W<GPLEN0_SPEC, 6> {
                LEN6_W::new(self)
            }
            #[doc = "Bit 7 - Low detect enabled 7"]
            #[inline(always)]
            #[must_use]
            pub fn len7(&mut self) -> LEN7_W<GPLEN0_SPEC, 7> {
                LEN7_W::new(self)
            }
            #[doc = "Bit 8 - Low detect enabled 8"]
            #[inline(always)]
            #[must_use]
            pub fn len8(&mut self) -> LEN8_W<GPLEN0_SPEC, 8> {
                LEN8_W::new(self)
            }
            #[doc = "Bit 9 - Low detect enabled 9"]
            #[inline(always)]
            #[must_use]
            pub fn len9(&mut self) -> LEN9_W<GPLEN0_SPEC, 9> {
                LEN9_W::new(self)
            }
            #[doc = "Bit 10 - Low detect enabled 10"]
            #[inline(always)]
            #[must_use]
            pub fn len10(&mut self) -> LEN10_W<GPLEN0_SPEC, 10> {
                LEN10_W::new(self)
            }
            #[doc = "Bit 11 - Low detect enabled 11"]
            #[inline(always)]
            #[must_use]
            pub fn len11(&mut self) -> LEN11_W<GPLEN0_SPEC, 11> {
                LEN11_W::new(self)
            }
            #[doc = "Bit 12 - Low detect enabled 12"]
            #[inline(always)]
            #[must_use]
            pub fn len12(&mut self) -> LEN12_W<GPLEN0_SPEC, 12> {
                LEN12_W::new(self)
            }
            #[doc = "Bit 13 - Low detect enabled 13"]
            #[inline(always)]
            #[must_use]
            pub fn len13(&mut self) -> LEN13_W<GPLEN0_SPEC, 13> {
                LEN13_W::new(self)
            }
            #[doc = "Bit 14 - Low detect enabled 14"]
            #[inline(always)]
            #[must_use]
            pub fn len14(&mut self) -> LEN14_W<GPLEN0_SPEC, 14> {
                LEN14_W::new(self)
            }
            #[doc = "Bit 15 - Low detect enabled 15"]
            #[inline(always)]
            #[must_use]
            pub fn len15(&mut self) -> LEN15_W<GPLEN0_SPEC, 15> {
                LEN15_W::new(self)
            }
            #[doc = "Bit 16 - Low detect enabled 16"]
            #[inline(always)]
            #[must_use]
            pub fn len16(&mut self) -> LEN16_W<GPLEN0_SPEC, 16> {
                LEN16_W::new(self)
            }
            #[doc = "Bit 17 - Low detect enabled 17"]
            #[inline(always)]
            #[must_use]
            pub fn len17(&mut self) -> LEN17_W<GPLEN0_SPEC, 17> {
                LEN17_W::new(self)
            }
            #[doc = "Bit 18 - Low detect enabled 18"]
            #[inline(always)]
            #[must_use]
            pub fn len18(&mut self) -> LEN18_W<GPLEN0_SPEC, 18> {
                LEN18_W::new(self)
            }
            #[doc = "Bit 19 - Low detect enabled 19"]
            #[inline(always)]
            #[must_use]
            pub fn len19(&mut self) -> LEN19_W<GPLEN0_SPEC, 19> {
                LEN19_W::new(self)
            }
            #[doc = "Bit 20 - Low detect enabled 20"]
            #[inline(always)]
            #[must_use]
            pub fn len20(&mut self) -> LEN20_W<GPLEN0_SPEC, 20> {
                LEN20_W::new(self)
            }
            #[doc = "Bit 21 - Low detect enabled 21"]
            #[inline(always)]
            #[must_use]
            pub fn len21(&mut self) -> LEN21_W<GPLEN0_SPEC, 21> {
                LEN21_W::new(self)
            }
            #[doc = "Bit 22 - Low detect enabled 22"]
            #[inline(always)]
            #[must_use]
            pub fn len22(&mut self) -> LEN22_W<GPLEN0_SPEC, 22> {
                LEN22_W::new(self)
            }
            #[doc = "Bit 23 - Low detect enabled 23"]
            #[inline(always)]
            #[must_use]
            pub fn len23(&mut self) -> LEN23_W<GPLEN0_SPEC, 23> {
                LEN23_W::new(self)
            }
            #[doc = "Bit 24 - Low detect enabled 24"]
            #[inline(always)]
            #[must_use]
            pub fn len24(&mut self) -> LEN24_W<GPLEN0_SPEC, 24> {
                LEN24_W::new(self)
            }
            #[doc = "Bit 25 - Low detect enabled 25"]
            #[inline(always)]
            #[must_use]
            pub fn len25(&mut self) -> LEN25_W<GPLEN0_SPEC, 25> {
                LEN25_W::new(self)
            }
            #[doc = "Bit 26 - Low detect enabled 26"]
            #[inline(always)]
            #[must_use]
            pub fn len26(&mut self) -> LEN26_W<GPLEN0_SPEC, 26> {
                LEN26_W::new(self)
            }
            #[doc = "Bit 27 - Low detect enabled 27"]
            #[inline(always)]
            #[must_use]
            pub fn len27(&mut self) -> LEN27_W<GPLEN0_SPEC, 27> {
                LEN27_W::new(self)
            }
            #[doc = "Bit 28 - Low detect enabled 28"]
            #[inline(always)]
            #[must_use]
            pub fn len28(&mut self) -> LEN28_W<GPLEN0_SPEC, 28> {
                LEN28_W::new(self)
            }
            #[doc = "Bit 29 - Low detect enabled 29"]
            #[inline(always)]
            #[must_use]
            pub fn len29(&mut self) -> LEN29_W<GPLEN0_SPEC, 29> {
                LEN29_W::new(self)
            }
            #[doc = "Bit 30 - Low detect enabled 30"]
            #[inline(always)]
            #[must_use]
            pub fn len30(&mut self) -> LEN30_W<GPLEN0_SPEC, 30> {
                LEN30_W::new(self)
            }
            #[doc = "Bit 31 - Low detect enabled 31"]
            #[inline(always)]
            #[must_use]
            pub fn len31(&mut self) -> LEN31_W<GPLEN0_SPEC, 31> {
                LEN31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Low Detect Enable 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gplen0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gplen0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPLEN0_SPEC;
        impl crate::RegisterSpec for GPLEN0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gplen0::R`](R) reader structure"]
        impl crate::Readable for GPLEN0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gplen0::W`](W) writer structure"]
        impl crate::Writable for GPLEN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPLEN1 (rw) register accessor: GPIO Pin Low Detect Enable 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gplen1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gplen1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gplen1`]
module"]
    pub type GPLEN1 = crate::Reg<gplen1::GPLEN1_SPEC>;
    #[doc = "GPIO Pin Low Detect Enable 1"]
    pub mod gplen1 {
        #[doc = "Register `GPLEN1` reader"]
        pub type R = crate::R<GPLEN1_SPEC>;
        #[doc = "Register `GPLEN1` writer"]
        pub type W = crate::W<GPLEN1_SPEC>;
        #[doc = "Field `LEN32` reader - Low detect enabled 32"]
        pub type LEN32_R = crate::BitReader;
        #[doc = "Field `LEN32` writer - Low detect enabled 32"]
        pub type LEN32_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN33` reader - Low detect enabled 33"]
        pub type LEN33_R = crate::BitReader;
        #[doc = "Field `LEN33` writer - Low detect enabled 33"]
        pub type LEN33_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN34` reader - Low detect enabled 34"]
        pub type LEN34_R = crate::BitReader;
        #[doc = "Field `LEN34` writer - Low detect enabled 34"]
        pub type LEN34_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN35` reader - Low detect enabled 35"]
        pub type LEN35_R = crate::BitReader;
        #[doc = "Field `LEN35` writer - Low detect enabled 35"]
        pub type LEN35_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN36` reader - Low detect enabled 36"]
        pub type LEN36_R = crate::BitReader;
        #[doc = "Field `LEN36` writer - Low detect enabled 36"]
        pub type LEN36_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN37` reader - Low detect enabled 37"]
        pub type LEN37_R = crate::BitReader;
        #[doc = "Field `LEN37` writer - Low detect enabled 37"]
        pub type LEN37_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN38` reader - Low detect enabled 38"]
        pub type LEN38_R = crate::BitReader;
        #[doc = "Field `LEN38` writer - Low detect enabled 38"]
        pub type LEN38_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN39` reader - Low detect enabled 39"]
        pub type LEN39_R = crate::BitReader;
        #[doc = "Field `LEN39` writer - Low detect enabled 39"]
        pub type LEN39_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN40` reader - Low detect enabled 40"]
        pub type LEN40_R = crate::BitReader;
        #[doc = "Field `LEN40` writer - Low detect enabled 40"]
        pub type LEN40_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN41` reader - Low detect enabled 41"]
        pub type LEN41_R = crate::BitReader;
        #[doc = "Field `LEN41` writer - Low detect enabled 41"]
        pub type LEN41_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN42` reader - Low detect enabled 42"]
        pub type LEN42_R = crate::BitReader;
        #[doc = "Field `LEN42` writer - Low detect enabled 42"]
        pub type LEN42_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN43` reader - Low detect enabled 43"]
        pub type LEN43_R = crate::BitReader;
        #[doc = "Field `LEN43` writer - Low detect enabled 43"]
        pub type LEN43_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN44` reader - Low detect enabled 44"]
        pub type LEN44_R = crate::BitReader;
        #[doc = "Field `LEN44` writer - Low detect enabled 44"]
        pub type LEN44_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN45` reader - Low detect enabled 45"]
        pub type LEN45_R = crate::BitReader;
        #[doc = "Field `LEN45` writer - Low detect enabled 45"]
        pub type LEN45_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN46` reader - Low detect enabled 46"]
        pub type LEN46_R = crate::BitReader;
        #[doc = "Field `LEN46` writer - Low detect enabled 46"]
        pub type LEN46_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN47` reader - Low detect enabled 47"]
        pub type LEN47_R = crate::BitReader;
        #[doc = "Field `LEN47` writer - Low detect enabled 47"]
        pub type LEN47_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN48` reader - Low detect enabled 48"]
        pub type LEN48_R = crate::BitReader;
        #[doc = "Field `LEN48` writer - Low detect enabled 48"]
        pub type LEN48_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN49` reader - Low detect enabled 49"]
        pub type LEN49_R = crate::BitReader;
        #[doc = "Field `LEN49` writer - Low detect enabled 49"]
        pub type LEN49_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN50` reader - Low detect enabled 50"]
        pub type LEN50_R = crate::BitReader;
        #[doc = "Field `LEN50` writer - Low detect enabled 50"]
        pub type LEN50_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN51` reader - Low detect enabled 51"]
        pub type LEN51_R = crate::BitReader;
        #[doc = "Field `LEN51` writer - Low detect enabled 51"]
        pub type LEN51_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN52` reader - Low detect enabled 52"]
        pub type LEN52_R = crate::BitReader;
        #[doc = "Field `LEN52` writer - Low detect enabled 52"]
        pub type LEN52_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN53` reader - Low detect enabled 53"]
        pub type LEN53_R = crate::BitReader;
        #[doc = "Field `LEN53` writer - Low detect enabled 53"]
        pub type LEN53_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Low detect enabled 32"]
            #[inline(always)]
            pub fn len32(&self) -> LEN32_R {
                LEN32_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Low detect enabled 33"]
            #[inline(always)]
            pub fn len33(&self) -> LEN33_R {
                LEN33_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Low detect enabled 34"]
            #[inline(always)]
            pub fn len34(&self) -> LEN34_R {
                LEN34_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Low detect enabled 35"]
            #[inline(always)]
            pub fn len35(&self) -> LEN35_R {
                LEN35_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Low detect enabled 36"]
            #[inline(always)]
            pub fn len36(&self) -> LEN36_R {
                LEN36_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Low detect enabled 37"]
            #[inline(always)]
            pub fn len37(&self) -> LEN37_R {
                LEN37_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Low detect enabled 38"]
            #[inline(always)]
            pub fn len38(&self) -> LEN38_R {
                LEN38_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Low detect enabled 39"]
            #[inline(always)]
            pub fn len39(&self) -> LEN39_R {
                LEN39_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Low detect enabled 40"]
            #[inline(always)]
            pub fn len40(&self) -> LEN40_R {
                LEN40_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Low detect enabled 41"]
            #[inline(always)]
            pub fn len41(&self) -> LEN41_R {
                LEN41_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Low detect enabled 42"]
            #[inline(always)]
            pub fn len42(&self) -> LEN42_R {
                LEN42_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Low detect enabled 43"]
            #[inline(always)]
            pub fn len43(&self) -> LEN43_R {
                LEN43_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Low detect enabled 44"]
            #[inline(always)]
            pub fn len44(&self) -> LEN44_R {
                LEN44_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Low detect enabled 45"]
            #[inline(always)]
            pub fn len45(&self) -> LEN45_R {
                LEN45_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Low detect enabled 46"]
            #[inline(always)]
            pub fn len46(&self) -> LEN46_R {
                LEN46_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Low detect enabled 47"]
            #[inline(always)]
            pub fn len47(&self) -> LEN47_R {
                LEN47_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Low detect enabled 48"]
            #[inline(always)]
            pub fn len48(&self) -> LEN48_R {
                LEN48_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Low detect enabled 49"]
            #[inline(always)]
            pub fn len49(&self) -> LEN49_R {
                LEN49_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Low detect enabled 50"]
            #[inline(always)]
            pub fn len50(&self) -> LEN50_R {
                LEN50_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Low detect enabled 51"]
            #[inline(always)]
            pub fn len51(&self) -> LEN51_R {
                LEN51_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Low detect enabled 52"]
            #[inline(always)]
            pub fn len52(&self) -> LEN52_R {
                LEN52_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Low detect enabled 53"]
            #[inline(always)]
            pub fn len53(&self) -> LEN53_R {
                LEN53_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPLEN1")
                    .field("len32", &format_args!("{}", self.len32().bit()))
                    .field("len33", &format_args!("{}", self.len33().bit()))
                    .field("len34", &format_args!("{}", self.len34().bit()))
                    .field("len35", &format_args!("{}", self.len35().bit()))
                    .field("len36", &format_args!("{}", self.len36().bit()))
                    .field("len37", &format_args!("{}", self.len37().bit()))
                    .field("len38", &format_args!("{}", self.len38().bit()))
                    .field("len39", &format_args!("{}", self.len39().bit()))
                    .field("len40", &format_args!("{}", self.len40().bit()))
                    .field("len41", &format_args!("{}", self.len41().bit()))
                    .field("len42", &format_args!("{}", self.len42().bit()))
                    .field("len43", &format_args!("{}", self.len43().bit()))
                    .field("len44", &format_args!("{}", self.len44().bit()))
                    .field("len45", &format_args!("{}", self.len45().bit()))
                    .field("len46", &format_args!("{}", self.len46().bit()))
                    .field("len47", &format_args!("{}", self.len47().bit()))
                    .field("len48", &format_args!("{}", self.len48().bit()))
                    .field("len49", &format_args!("{}", self.len49().bit()))
                    .field("len50", &format_args!("{}", self.len50().bit()))
                    .field("len51", &format_args!("{}", self.len51().bit()))
                    .field("len52", &format_args!("{}", self.len52().bit()))
                    .field("len53", &format_args!("{}", self.len53().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPLEN1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Low detect enabled 32"]
            #[inline(always)]
            #[must_use]
            pub fn len32(&mut self) -> LEN32_W<GPLEN1_SPEC, 0> {
                LEN32_W::new(self)
            }
            #[doc = "Bit 1 - Low detect enabled 33"]
            #[inline(always)]
            #[must_use]
            pub fn len33(&mut self) -> LEN33_W<GPLEN1_SPEC, 1> {
                LEN33_W::new(self)
            }
            #[doc = "Bit 2 - Low detect enabled 34"]
            #[inline(always)]
            #[must_use]
            pub fn len34(&mut self) -> LEN34_W<GPLEN1_SPEC, 2> {
                LEN34_W::new(self)
            }
            #[doc = "Bit 3 - Low detect enabled 35"]
            #[inline(always)]
            #[must_use]
            pub fn len35(&mut self) -> LEN35_W<GPLEN1_SPEC, 3> {
                LEN35_W::new(self)
            }
            #[doc = "Bit 4 - Low detect enabled 36"]
            #[inline(always)]
            #[must_use]
            pub fn len36(&mut self) -> LEN36_W<GPLEN1_SPEC, 4> {
                LEN36_W::new(self)
            }
            #[doc = "Bit 5 - Low detect enabled 37"]
            #[inline(always)]
            #[must_use]
            pub fn len37(&mut self) -> LEN37_W<GPLEN1_SPEC, 5> {
                LEN37_W::new(self)
            }
            #[doc = "Bit 6 - Low detect enabled 38"]
            #[inline(always)]
            #[must_use]
            pub fn len38(&mut self) -> LEN38_W<GPLEN1_SPEC, 6> {
                LEN38_W::new(self)
            }
            #[doc = "Bit 7 - Low detect enabled 39"]
            #[inline(always)]
            #[must_use]
            pub fn len39(&mut self) -> LEN39_W<GPLEN1_SPEC, 7> {
                LEN39_W::new(self)
            }
            #[doc = "Bit 8 - Low detect enabled 40"]
            #[inline(always)]
            #[must_use]
            pub fn len40(&mut self) -> LEN40_W<GPLEN1_SPEC, 8> {
                LEN40_W::new(self)
            }
            #[doc = "Bit 9 - Low detect enabled 41"]
            #[inline(always)]
            #[must_use]
            pub fn len41(&mut self) -> LEN41_W<GPLEN1_SPEC, 9> {
                LEN41_W::new(self)
            }
            #[doc = "Bit 10 - Low detect enabled 42"]
            #[inline(always)]
            #[must_use]
            pub fn len42(&mut self) -> LEN42_W<GPLEN1_SPEC, 10> {
                LEN42_W::new(self)
            }
            #[doc = "Bit 11 - Low detect enabled 43"]
            #[inline(always)]
            #[must_use]
            pub fn len43(&mut self) -> LEN43_W<GPLEN1_SPEC, 11> {
                LEN43_W::new(self)
            }
            #[doc = "Bit 12 - Low detect enabled 44"]
            #[inline(always)]
            #[must_use]
            pub fn len44(&mut self) -> LEN44_W<GPLEN1_SPEC, 12> {
                LEN44_W::new(self)
            }
            #[doc = "Bit 13 - Low detect enabled 45"]
            #[inline(always)]
            #[must_use]
            pub fn len45(&mut self) -> LEN45_W<GPLEN1_SPEC, 13> {
                LEN45_W::new(self)
            }
            #[doc = "Bit 14 - Low detect enabled 46"]
            #[inline(always)]
            #[must_use]
            pub fn len46(&mut self) -> LEN46_W<GPLEN1_SPEC, 14> {
                LEN46_W::new(self)
            }
            #[doc = "Bit 15 - Low detect enabled 47"]
            #[inline(always)]
            #[must_use]
            pub fn len47(&mut self) -> LEN47_W<GPLEN1_SPEC, 15> {
                LEN47_W::new(self)
            }
            #[doc = "Bit 16 - Low detect enabled 48"]
            #[inline(always)]
            #[must_use]
            pub fn len48(&mut self) -> LEN48_W<GPLEN1_SPEC, 16> {
                LEN48_W::new(self)
            }
            #[doc = "Bit 17 - Low detect enabled 49"]
            #[inline(always)]
            #[must_use]
            pub fn len49(&mut self) -> LEN49_W<GPLEN1_SPEC, 17> {
                LEN49_W::new(self)
            }
            #[doc = "Bit 18 - Low detect enabled 50"]
            #[inline(always)]
            #[must_use]
            pub fn len50(&mut self) -> LEN50_W<GPLEN1_SPEC, 18> {
                LEN50_W::new(self)
            }
            #[doc = "Bit 19 - Low detect enabled 51"]
            #[inline(always)]
            #[must_use]
            pub fn len51(&mut self) -> LEN51_W<GPLEN1_SPEC, 19> {
                LEN51_W::new(self)
            }
            #[doc = "Bit 20 - Low detect enabled 52"]
            #[inline(always)]
            #[must_use]
            pub fn len52(&mut self) -> LEN52_W<GPLEN1_SPEC, 20> {
                LEN52_W::new(self)
            }
            #[doc = "Bit 21 - Low detect enabled 53"]
            #[inline(always)]
            #[must_use]
            pub fn len53(&mut self) -> LEN53_W<GPLEN1_SPEC, 21> {
                LEN53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Low Detect Enable 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gplen1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gplen1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPLEN1_SPEC;
        impl crate::RegisterSpec for GPLEN1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gplen1::R`](R) reader structure"]
        impl crate::Readable for GPLEN1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gplen1::W`](W) writer structure"]
        impl crate::Writable for GPLEN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPAREN0 (rw) register accessor: GPIO Pin Async. Rising Edge Detect 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gparen0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gparen0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gparen0`]
module"]
    pub type GPAREN0 = crate::Reg<gparen0::GPAREN0_SPEC>;
    #[doc = "GPIO Pin Async. Rising Edge Detect 0"]
    pub mod gparen0 {
        #[doc = "Register `GPAREN0` reader"]
        pub type R = crate::R<GPAREN0_SPEC>;
        #[doc = "Register `GPAREN0` writer"]
        pub type W = crate::W<GPAREN0_SPEC>;
        #[doc = "Field `AREN0` reader - Async rising enabled 0"]
        pub type AREN0_R = crate::BitReader;
        #[doc = "Field `AREN0` writer - Async rising enabled 0"]
        pub type AREN0_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN1` reader - Async rising enabled 1"]
        pub type AREN1_R = crate::BitReader;
        #[doc = "Field `AREN1` writer - Async rising enabled 1"]
        pub type AREN1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN2` reader - Async rising enabled 2"]
        pub type AREN2_R = crate::BitReader;
        #[doc = "Field `AREN2` writer - Async rising enabled 2"]
        pub type AREN2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN3` reader - Async rising enabled 3"]
        pub type AREN3_R = crate::BitReader;
        #[doc = "Field `AREN3` writer - Async rising enabled 3"]
        pub type AREN3_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN4` reader - Async rising enabled 4"]
        pub type AREN4_R = crate::BitReader;
        #[doc = "Field `AREN4` writer - Async rising enabled 4"]
        pub type AREN4_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN5` reader - Async rising enabled 5"]
        pub type AREN5_R = crate::BitReader;
        #[doc = "Field `AREN5` writer - Async rising enabled 5"]
        pub type AREN5_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN6` reader - Async rising enabled 6"]
        pub type AREN6_R = crate::BitReader;
        #[doc = "Field `AREN6` writer - Async rising enabled 6"]
        pub type AREN6_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN7` reader - Async rising enabled 7"]
        pub type AREN7_R = crate::BitReader;
        #[doc = "Field `AREN7` writer - Async rising enabled 7"]
        pub type AREN7_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN8` reader - Async rising enabled 8"]
        pub type AREN8_R = crate::BitReader;
        #[doc = "Field `AREN8` writer - Async rising enabled 8"]
        pub type AREN8_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN9` reader - Async rising enabled 9"]
        pub type AREN9_R = crate::BitReader;
        #[doc = "Field `AREN9` writer - Async rising enabled 9"]
        pub type AREN9_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN10` reader - Async rising enabled 10"]
        pub type AREN10_R = crate::BitReader;
        #[doc = "Field `AREN10` writer - Async rising enabled 10"]
        pub type AREN10_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN11` reader - Async rising enabled 11"]
        pub type AREN11_R = crate::BitReader;
        #[doc = "Field `AREN11` writer - Async rising enabled 11"]
        pub type AREN11_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN12` reader - Async rising enabled 12"]
        pub type AREN12_R = crate::BitReader;
        #[doc = "Field `AREN12` writer - Async rising enabled 12"]
        pub type AREN12_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN13` reader - Async rising enabled 13"]
        pub type AREN13_R = crate::BitReader;
        #[doc = "Field `AREN13` writer - Async rising enabled 13"]
        pub type AREN13_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN14` reader - Async rising enabled 14"]
        pub type AREN14_R = crate::BitReader;
        #[doc = "Field `AREN14` writer - Async rising enabled 14"]
        pub type AREN14_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN15` reader - Async rising enabled 15"]
        pub type AREN15_R = crate::BitReader;
        #[doc = "Field `AREN15` writer - Async rising enabled 15"]
        pub type AREN15_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN16` reader - Async rising enabled 16"]
        pub type AREN16_R = crate::BitReader;
        #[doc = "Field `AREN16` writer - Async rising enabled 16"]
        pub type AREN16_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN17` reader - Async rising enabled 17"]
        pub type AREN17_R = crate::BitReader;
        #[doc = "Field `AREN17` writer - Async rising enabled 17"]
        pub type AREN17_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN18` reader - Async rising enabled 18"]
        pub type AREN18_R = crate::BitReader;
        #[doc = "Field `AREN18` writer - Async rising enabled 18"]
        pub type AREN18_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN19` reader - Async rising enabled 19"]
        pub type AREN19_R = crate::BitReader;
        #[doc = "Field `AREN19` writer - Async rising enabled 19"]
        pub type AREN19_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN20` reader - Async rising enabled 20"]
        pub type AREN20_R = crate::BitReader;
        #[doc = "Field `AREN20` writer - Async rising enabled 20"]
        pub type AREN20_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN21` reader - Async rising enabled 21"]
        pub type AREN21_R = crate::BitReader;
        #[doc = "Field `AREN21` writer - Async rising enabled 21"]
        pub type AREN21_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN22` reader - Async rising enabled 22"]
        pub type AREN22_R = crate::BitReader;
        #[doc = "Field `AREN22` writer - Async rising enabled 22"]
        pub type AREN22_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN23` reader - Async rising enabled 23"]
        pub type AREN23_R = crate::BitReader;
        #[doc = "Field `AREN23` writer - Async rising enabled 23"]
        pub type AREN23_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN24` reader - Async rising enabled 24"]
        pub type AREN24_R = crate::BitReader;
        #[doc = "Field `AREN24` writer - Async rising enabled 24"]
        pub type AREN24_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN25` reader - Async rising enabled 25"]
        pub type AREN25_R = crate::BitReader;
        #[doc = "Field `AREN25` writer - Async rising enabled 25"]
        pub type AREN25_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN26` reader - Async rising enabled 26"]
        pub type AREN26_R = crate::BitReader;
        #[doc = "Field `AREN26` writer - Async rising enabled 26"]
        pub type AREN26_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN27` reader - Async rising enabled 27"]
        pub type AREN27_R = crate::BitReader;
        #[doc = "Field `AREN27` writer - Async rising enabled 27"]
        pub type AREN27_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN28` reader - Async rising enabled 28"]
        pub type AREN28_R = crate::BitReader;
        #[doc = "Field `AREN28` writer - Async rising enabled 28"]
        pub type AREN28_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN29` reader - Async rising enabled 29"]
        pub type AREN29_R = crate::BitReader;
        #[doc = "Field `AREN29` writer - Async rising enabled 29"]
        pub type AREN29_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN30` reader - Async rising enabled 30"]
        pub type AREN30_R = crate::BitReader;
        #[doc = "Field `AREN30` writer - Async rising enabled 30"]
        pub type AREN30_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN31` reader - Async rising enabled 31"]
        pub type AREN31_R = crate::BitReader;
        #[doc = "Field `AREN31` writer - Async rising enabled 31"]
        pub type AREN31_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Async rising enabled 0"]
            #[inline(always)]
            pub fn aren0(&self) -> AREN0_R {
                AREN0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Async rising enabled 1"]
            #[inline(always)]
            pub fn aren1(&self) -> AREN1_R {
                AREN1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Async rising enabled 2"]
            #[inline(always)]
            pub fn aren2(&self) -> AREN2_R {
                AREN2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Async rising enabled 3"]
            #[inline(always)]
            pub fn aren3(&self) -> AREN3_R {
                AREN3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Async rising enabled 4"]
            #[inline(always)]
            pub fn aren4(&self) -> AREN4_R {
                AREN4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Async rising enabled 5"]
            #[inline(always)]
            pub fn aren5(&self) -> AREN5_R {
                AREN5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Async rising enabled 6"]
            #[inline(always)]
            pub fn aren6(&self) -> AREN6_R {
                AREN6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Async rising enabled 7"]
            #[inline(always)]
            pub fn aren7(&self) -> AREN7_R {
                AREN7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Async rising enabled 8"]
            #[inline(always)]
            pub fn aren8(&self) -> AREN8_R {
                AREN8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Async rising enabled 9"]
            #[inline(always)]
            pub fn aren9(&self) -> AREN9_R {
                AREN9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Async rising enabled 10"]
            #[inline(always)]
            pub fn aren10(&self) -> AREN10_R {
                AREN10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Async rising enabled 11"]
            #[inline(always)]
            pub fn aren11(&self) -> AREN11_R {
                AREN11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Async rising enabled 12"]
            #[inline(always)]
            pub fn aren12(&self) -> AREN12_R {
                AREN12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Async rising enabled 13"]
            #[inline(always)]
            pub fn aren13(&self) -> AREN13_R {
                AREN13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Async rising enabled 14"]
            #[inline(always)]
            pub fn aren14(&self) -> AREN14_R {
                AREN14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Async rising enabled 15"]
            #[inline(always)]
            pub fn aren15(&self) -> AREN15_R {
                AREN15_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Async rising enabled 16"]
            #[inline(always)]
            pub fn aren16(&self) -> AREN16_R {
                AREN16_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Async rising enabled 17"]
            #[inline(always)]
            pub fn aren17(&self) -> AREN17_R {
                AREN17_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Async rising enabled 18"]
            #[inline(always)]
            pub fn aren18(&self) -> AREN18_R {
                AREN18_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Async rising enabled 19"]
            #[inline(always)]
            pub fn aren19(&self) -> AREN19_R {
                AREN19_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Async rising enabled 20"]
            #[inline(always)]
            pub fn aren20(&self) -> AREN20_R {
                AREN20_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Async rising enabled 21"]
            #[inline(always)]
            pub fn aren21(&self) -> AREN21_R {
                AREN21_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Async rising enabled 22"]
            #[inline(always)]
            pub fn aren22(&self) -> AREN22_R {
                AREN22_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Async rising enabled 23"]
            #[inline(always)]
            pub fn aren23(&self) -> AREN23_R {
                AREN23_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Async rising enabled 24"]
            #[inline(always)]
            pub fn aren24(&self) -> AREN24_R {
                AREN24_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Async rising enabled 25"]
            #[inline(always)]
            pub fn aren25(&self) -> AREN25_R {
                AREN25_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Async rising enabled 26"]
            #[inline(always)]
            pub fn aren26(&self) -> AREN26_R {
                AREN26_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Async rising enabled 27"]
            #[inline(always)]
            pub fn aren27(&self) -> AREN27_R {
                AREN27_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - Async rising enabled 28"]
            #[inline(always)]
            pub fn aren28(&self) -> AREN28_R {
                AREN28_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Async rising enabled 29"]
            #[inline(always)]
            pub fn aren29(&self) -> AREN29_R {
                AREN29_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Async rising enabled 30"]
            #[inline(always)]
            pub fn aren30(&self) -> AREN30_R {
                AREN30_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Async rising enabled 31"]
            #[inline(always)]
            pub fn aren31(&self) -> AREN31_R {
                AREN31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPAREN0")
                    .field("aren0", &format_args!("{}", self.aren0().bit()))
                    .field("aren1", &format_args!("{}", self.aren1().bit()))
                    .field("aren2", &format_args!("{}", self.aren2().bit()))
                    .field("aren3", &format_args!("{}", self.aren3().bit()))
                    .field("aren4", &format_args!("{}", self.aren4().bit()))
                    .field("aren5", &format_args!("{}", self.aren5().bit()))
                    .field("aren6", &format_args!("{}", self.aren6().bit()))
                    .field("aren7", &format_args!("{}", self.aren7().bit()))
                    .field("aren8", &format_args!("{}", self.aren8().bit()))
                    .field("aren9", &format_args!("{}", self.aren9().bit()))
                    .field("aren10", &format_args!("{}", self.aren10().bit()))
                    .field("aren11", &format_args!("{}", self.aren11().bit()))
                    .field("aren12", &format_args!("{}", self.aren12().bit()))
                    .field("aren13", &format_args!("{}", self.aren13().bit()))
                    .field("aren14", &format_args!("{}", self.aren14().bit()))
                    .field("aren15", &format_args!("{}", self.aren15().bit()))
                    .field("aren16", &format_args!("{}", self.aren16().bit()))
                    .field("aren17", &format_args!("{}", self.aren17().bit()))
                    .field("aren18", &format_args!("{}", self.aren18().bit()))
                    .field("aren19", &format_args!("{}", self.aren19().bit()))
                    .field("aren20", &format_args!("{}", self.aren20().bit()))
                    .field("aren21", &format_args!("{}", self.aren21().bit()))
                    .field("aren22", &format_args!("{}", self.aren22().bit()))
                    .field("aren23", &format_args!("{}", self.aren23().bit()))
                    .field("aren24", &format_args!("{}", self.aren24().bit()))
                    .field("aren25", &format_args!("{}", self.aren25().bit()))
                    .field("aren26", &format_args!("{}", self.aren26().bit()))
                    .field("aren27", &format_args!("{}", self.aren27().bit()))
                    .field("aren28", &format_args!("{}", self.aren28().bit()))
                    .field("aren29", &format_args!("{}", self.aren29().bit()))
                    .field("aren30", &format_args!("{}", self.aren30().bit()))
                    .field("aren31", &format_args!("{}", self.aren31().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPAREN0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Async rising enabled 0"]
            #[inline(always)]
            #[must_use]
            pub fn aren0(&mut self) -> AREN0_W<GPAREN0_SPEC, 0> {
                AREN0_W::new(self)
            }
            #[doc = "Bit 1 - Async rising enabled 1"]
            #[inline(always)]
            #[must_use]
            pub fn aren1(&mut self) -> AREN1_W<GPAREN0_SPEC, 1> {
                AREN1_W::new(self)
            }
            #[doc = "Bit 2 - Async rising enabled 2"]
            #[inline(always)]
            #[must_use]
            pub fn aren2(&mut self) -> AREN2_W<GPAREN0_SPEC, 2> {
                AREN2_W::new(self)
            }
            #[doc = "Bit 3 - Async rising enabled 3"]
            #[inline(always)]
            #[must_use]
            pub fn aren3(&mut self) -> AREN3_W<GPAREN0_SPEC, 3> {
                AREN3_W::new(self)
            }
            #[doc = "Bit 4 - Async rising enabled 4"]
            #[inline(always)]
            #[must_use]
            pub fn aren4(&mut self) -> AREN4_W<GPAREN0_SPEC, 4> {
                AREN4_W::new(self)
            }
            #[doc = "Bit 5 - Async rising enabled 5"]
            #[inline(always)]
            #[must_use]
            pub fn aren5(&mut self) -> AREN5_W<GPAREN0_SPEC, 5> {
                AREN5_W::new(self)
            }
            #[doc = "Bit 6 - Async rising enabled 6"]
            #[inline(always)]
            #[must_use]
            pub fn aren6(&mut self) -> AREN6_W<GPAREN0_SPEC, 6> {
                AREN6_W::new(self)
            }
            #[doc = "Bit 7 - Async rising enabled 7"]
            #[inline(always)]
            #[must_use]
            pub fn aren7(&mut self) -> AREN7_W<GPAREN0_SPEC, 7> {
                AREN7_W::new(self)
            }
            #[doc = "Bit 8 - Async rising enabled 8"]
            #[inline(always)]
            #[must_use]
            pub fn aren8(&mut self) -> AREN8_W<GPAREN0_SPEC, 8> {
                AREN8_W::new(self)
            }
            #[doc = "Bit 9 - Async rising enabled 9"]
            #[inline(always)]
            #[must_use]
            pub fn aren9(&mut self) -> AREN9_W<GPAREN0_SPEC, 9> {
                AREN9_W::new(self)
            }
            #[doc = "Bit 10 - Async rising enabled 10"]
            #[inline(always)]
            #[must_use]
            pub fn aren10(&mut self) -> AREN10_W<GPAREN0_SPEC, 10> {
                AREN10_W::new(self)
            }
            #[doc = "Bit 11 - Async rising enabled 11"]
            #[inline(always)]
            #[must_use]
            pub fn aren11(&mut self) -> AREN11_W<GPAREN0_SPEC, 11> {
                AREN11_W::new(self)
            }
            #[doc = "Bit 12 - Async rising enabled 12"]
            #[inline(always)]
            #[must_use]
            pub fn aren12(&mut self) -> AREN12_W<GPAREN0_SPEC, 12> {
                AREN12_W::new(self)
            }
            #[doc = "Bit 13 - Async rising enabled 13"]
            #[inline(always)]
            #[must_use]
            pub fn aren13(&mut self) -> AREN13_W<GPAREN0_SPEC, 13> {
                AREN13_W::new(self)
            }
            #[doc = "Bit 14 - Async rising enabled 14"]
            #[inline(always)]
            #[must_use]
            pub fn aren14(&mut self) -> AREN14_W<GPAREN0_SPEC, 14> {
                AREN14_W::new(self)
            }
            #[doc = "Bit 15 - Async rising enabled 15"]
            #[inline(always)]
            #[must_use]
            pub fn aren15(&mut self) -> AREN15_W<GPAREN0_SPEC, 15> {
                AREN15_W::new(self)
            }
            #[doc = "Bit 16 - Async rising enabled 16"]
            #[inline(always)]
            #[must_use]
            pub fn aren16(&mut self) -> AREN16_W<GPAREN0_SPEC, 16> {
                AREN16_W::new(self)
            }
            #[doc = "Bit 17 - Async rising enabled 17"]
            #[inline(always)]
            #[must_use]
            pub fn aren17(&mut self) -> AREN17_W<GPAREN0_SPEC, 17> {
                AREN17_W::new(self)
            }
            #[doc = "Bit 18 - Async rising enabled 18"]
            #[inline(always)]
            #[must_use]
            pub fn aren18(&mut self) -> AREN18_W<GPAREN0_SPEC, 18> {
                AREN18_W::new(self)
            }
            #[doc = "Bit 19 - Async rising enabled 19"]
            #[inline(always)]
            #[must_use]
            pub fn aren19(&mut self) -> AREN19_W<GPAREN0_SPEC, 19> {
                AREN19_W::new(self)
            }
            #[doc = "Bit 20 - Async rising enabled 20"]
            #[inline(always)]
            #[must_use]
            pub fn aren20(&mut self) -> AREN20_W<GPAREN0_SPEC, 20> {
                AREN20_W::new(self)
            }
            #[doc = "Bit 21 - Async rising enabled 21"]
            #[inline(always)]
            #[must_use]
            pub fn aren21(&mut self) -> AREN21_W<GPAREN0_SPEC, 21> {
                AREN21_W::new(self)
            }
            #[doc = "Bit 22 - Async rising enabled 22"]
            #[inline(always)]
            #[must_use]
            pub fn aren22(&mut self) -> AREN22_W<GPAREN0_SPEC, 22> {
                AREN22_W::new(self)
            }
            #[doc = "Bit 23 - Async rising enabled 23"]
            #[inline(always)]
            #[must_use]
            pub fn aren23(&mut self) -> AREN23_W<GPAREN0_SPEC, 23> {
                AREN23_W::new(self)
            }
            #[doc = "Bit 24 - Async rising enabled 24"]
            #[inline(always)]
            #[must_use]
            pub fn aren24(&mut self) -> AREN24_W<GPAREN0_SPEC, 24> {
                AREN24_W::new(self)
            }
            #[doc = "Bit 25 - Async rising enabled 25"]
            #[inline(always)]
            #[must_use]
            pub fn aren25(&mut self) -> AREN25_W<GPAREN0_SPEC, 25> {
                AREN25_W::new(self)
            }
            #[doc = "Bit 26 - Async rising enabled 26"]
            #[inline(always)]
            #[must_use]
            pub fn aren26(&mut self) -> AREN26_W<GPAREN0_SPEC, 26> {
                AREN26_W::new(self)
            }
            #[doc = "Bit 27 - Async rising enabled 27"]
            #[inline(always)]
            #[must_use]
            pub fn aren27(&mut self) -> AREN27_W<GPAREN0_SPEC, 27> {
                AREN27_W::new(self)
            }
            #[doc = "Bit 28 - Async rising enabled 28"]
            #[inline(always)]
            #[must_use]
            pub fn aren28(&mut self) -> AREN28_W<GPAREN0_SPEC, 28> {
                AREN28_W::new(self)
            }
            #[doc = "Bit 29 - Async rising enabled 29"]
            #[inline(always)]
            #[must_use]
            pub fn aren29(&mut self) -> AREN29_W<GPAREN0_SPEC, 29> {
                AREN29_W::new(self)
            }
            #[doc = "Bit 30 - Async rising enabled 30"]
            #[inline(always)]
            #[must_use]
            pub fn aren30(&mut self) -> AREN30_W<GPAREN0_SPEC, 30> {
                AREN30_W::new(self)
            }
            #[doc = "Bit 31 - Async rising enabled 31"]
            #[inline(always)]
            #[must_use]
            pub fn aren31(&mut self) -> AREN31_W<GPAREN0_SPEC, 31> {
                AREN31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Async. Rising Edge Detect 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gparen0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gparen0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPAREN0_SPEC;
        impl crate::RegisterSpec for GPAREN0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gparen0::R`](R) reader structure"]
        impl crate::Readable for GPAREN0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gparen0::W`](W) writer structure"]
        impl crate::Writable for GPAREN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPAREN1 (rw) register accessor: GPIO Pin Async. Rising Edge Detect 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gparen1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gparen1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gparen1`]
module"]
    pub type GPAREN1 = crate::Reg<gparen1::GPAREN1_SPEC>;
    #[doc = "GPIO Pin Async. Rising Edge Detect 1"]
    pub mod gparen1 {
        #[doc = "Register `GPAREN1` reader"]
        pub type R = crate::R<GPAREN1_SPEC>;
        #[doc = "Register `GPAREN1` writer"]
        pub type W = crate::W<GPAREN1_SPEC>;
        #[doc = "Field `AREN32` reader - Async rising enabled 32"]
        pub type AREN32_R = crate::BitReader;
        #[doc = "Field `AREN32` writer - Async rising enabled 32"]
        pub type AREN32_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN33` reader - Async rising enabled 33"]
        pub type AREN33_R = crate::BitReader;
        #[doc = "Field `AREN33` writer - Async rising enabled 33"]
        pub type AREN33_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN34` reader - Async rising enabled 34"]
        pub type AREN34_R = crate::BitReader;
        #[doc = "Field `AREN34` writer - Async rising enabled 34"]
        pub type AREN34_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN35` reader - Async rising enabled 35"]
        pub type AREN35_R = crate::BitReader;
        #[doc = "Field `AREN35` writer - Async rising enabled 35"]
        pub type AREN35_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN36` reader - Async rising enabled 36"]
        pub type AREN36_R = crate::BitReader;
        #[doc = "Field `AREN36` writer - Async rising enabled 36"]
        pub type AREN36_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN37` reader - Async rising enabled 37"]
        pub type AREN37_R = crate::BitReader;
        #[doc = "Field `AREN37` writer - Async rising enabled 37"]
        pub type AREN37_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN38` reader - Async rising enabled 38"]
        pub type AREN38_R = crate::BitReader;
        #[doc = "Field `AREN38` writer - Async rising enabled 38"]
        pub type AREN38_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN39` reader - Async rising enabled 39"]
        pub type AREN39_R = crate::BitReader;
        #[doc = "Field `AREN39` writer - Async rising enabled 39"]
        pub type AREN39_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN40` reader - Async rising enabled 40"]
        pub type AREN40_R = crate::BitReader;
        #[doc = "Field `AREN40` writer - Async rising enabled 40"]
        pub type AREN40_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN41` reader - Async rising enabled 41"]
        pub type AREN41_R = crate::BitReader;
        #[doc = "Field `AREN41` writer - Async rising enabled 41"]
        pub type AREN41_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN42` reader - Async rising enabled 42"]
        pub type AREN42_R = crate::BitReader;
        #[doc = "Field `AREN42` writer - Async rising enabled 42"]
        pub type AREN42_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN43` reader - Async rising enabled 43"]
        pub type AREN43_R = crate::BitReader;
        #[doc = "Field `AREN43` writer - Async rising enabled 43"]
        pub type AREN43_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN44` reader - Async rising enabled 44"]
        pub type AREN44_R = crate::BitReader;
        #[doc = "Field `AREN44` writer - Async rising enabled 44"]
        pub type AREN44_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN45` reader - Async rising enabled 45"]
        pub type AREN45_R = crate::BitReader;
        #[doc = "Field `AREN45` writer - Async rising enabled 45"]
        pub type AREN45_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN46` reader - Async rising enabled 46"]
        pub type AREN46_R = crate::BitReader;
        #[doc = "Field `AREN46` writer - Async rising enabled 46"]
        pub type AREN46_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN47` reader - Async rising enabled 47"]
        pub type AREN47_R = crate::BitReader;
        #[doc = "Field `AREN47` writer - Async rising enabled 47"]
        pub type AREN47_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN48` reader - Async rising enabled 48"]
        pub type AREN48_R = crate::BitReader;
        #[doc = "Field `AREN48` writer - Async rising enabled 48"]
        pub type AREN48_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN49` reader - Async rising enabled 49"]
        pub type AREN49_R = crate::BitReader;
        #[doc = "Field `AREN49` writer - Async rising enabled 49"]
        pub type AREN49_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN50` reader - Async rising enabled 50"]
        pub type AREN50_R = crate::BitReader;
        #[doc = "Field `AREN50` writer - Async rising enabled 50"]
        pub type AREN50_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN51` reader - Async rising enabled 51"]
        pub type AREN51_R = crate::BitReader;
        #[doc = "Field `AREN51` writer - Async rising enabled 51"]
        pub type AREN51_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN52` reader - Async rising enabled 52"]
        pub type AREN52_R = crate::BitReader;
        #[doc = "Field `AREN52` writer - Async rising enabled 52"]
        pub type AREN52_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AREN53` reader - Async rising enabled 53"]
        pub type AREN53_R = crate::BitReader;
        #[doc = "Field `AREN53` writer - Async rising enabled 53"]
        pub type AREN53_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Async rising enabled 32"]
            #[inline(always)]
            pub fn aren32(&self) -> AREN32_R {
                AREN32_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Async rising enabled 33"]
            #[inline(always)]
            pub fn aren33(&self) -> AREN33_R {
                AREN33_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Async rising enabled 34"]
            #[inline(always)]
            pub fn aren34(&self) -> AREN34_R {
                AREN34_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Async rising enabled 35"]
            #[inline(always)]
            pub fn aren35(&self) -> AREN35_R {
                AREN35_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Async rising enabled 36"]
            #[inline(always)]
            pub fn aren36(&self) -> AREN36_R {
                AREN36_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Async rising enabled 37"]
            #[inline(always)]
            pub fn aren37(&self) -> AREN37_R {
                AREN37_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Async rising enabled 38"]
            #[inline(always)]
            pub fn aren38(&self) -> AREN38_R {
                AREN38_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Async rising enabled 39"]
            #[inline(always)]
            pub fn aren39(&self) -> AREN39_R {
                AREN39_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Async rising enabled 40"]
            #[inline(always)]
            pub fn aren40(&self) -> AREN40_R {
                AREN40_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Async rising enabled 41"]
            #[inline(always)]
            pub fn aren41(&self) -> AREN41_R {
                AREN41_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Async rising enabled 42"]
            #[inline(always)]
            pub fn aren42(&self) -> AREN42_R {
                AREN42_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Async rising enabled 43"]
            #[inline(always)]
            pub fn aren43(&self) -> AREN43_R {
                AREN43_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Async rising enabled 44"]
            #[inline(always)]
            pub fn aren44(&self) -> AREN44_R {
                AREN44_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Async rising enabled 45"]
            #[inline(always)]
            pub fn aren45(&self) -> AREN45_R {
                AREN45_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Async rising enabled 46"]
            #[inline(always)]
            pub fn aren46(&self) -> AREN46_R {
                AREN46_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Async rising enabled 47"]
            #[inline(always)]
            pub fn aren47(&self) -> AREN47_R {
                AREN47_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Async rising enabled 48"]
            #[inline(always)]
            pub fn aren48(&self) -> AREN48_R {
                AREN48_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Async rising enabled 49"]
            #[inline(always)]
            pub fn aren49(&self) -> AREN49_R {
                AREN49_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Async rising enabled 50"]
            #[inline(always)]
            pub fn aren50(&self) -> AREN50_R {
                AREN50_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Async rising enabled 51"]
            #[inline(always)]
            pub fn aren51(&self) -> AREN51_R {
                AREN51_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Async rising enabled 52"]
            #[inline(always)]
            pub fn aren52(&self) -> AREN52_R {
                AREN52_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Async rising enabled 53"]
            #[inline(always)]
            pub fn aren53(&self) -> AREN53_R {
                AREN53_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPAREN1")
                    .field("aren32", &format_args!("{}", self.aren32().bit()))
                    .field("aren33", &format_args!("{}", self.aren33().bit()))
                    .field("aren34", &format_args!("{}", self.aren34().bit()))
                    .field("aren35", &format_args!("{}", self.aren35().bit()))
                    .field("aren36", &format_args!("{}", self.aren36().bit()))
                    .field("aren37", &format_args!("{}", self.aren37().bit()))
                    .field("aren38", &format_args!("{}", self.aren38().bit()))
                    .field("aren39", &format_args!("{}", self.aren39().bit()))
                    .field("aren40", &format_args!("{}", self.aren40().bit()))
                    .field("aren41", &format_args!("{}", self.aren41().bit()))
                    .field("aren42", &format_args!("{}", self.aren42().bit()))
                    .field("aren43", &format_args!("{}", self.aren43().bit()))
                    .field("aren44", &format_args!("{}", self.aren44().bit()))
                    .field("aren45", &format_args!("{}", self.aren45().bit()))
                    .field("aren46", &format_args!("{}", self.aren46().bit()))
                    .field("aren47", &format_args!("{}", self.aren47().bit()))
                    .field("aren48", &format_args!("{}", self.aren48().bit()))
                    .field("aren49", &format_args!("{}", self.aren49().bit()))
                    .field("aren50", &format_args!("{}", self.aren50().bit()))
                    .field("aren51", &format_args!("{}", self.aren51().bit()))
                    .field("aren52", &format_args!("{}", self.aren52().bit()))
                    .field("aren53", &format_args!("{}", self.aren53().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPAREN1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Async rising enabled 32"]
            #[inline(always)]
            #[must_use]
            pub fn aren32(&mut self) -> AREN32_W<GPAREN1_SPEC, 0> {
                AREN32_W::new(self)
            }
            #[doc = "Bit 1 - Async rising enabled 33"]
            #[inline(always)]
            #[must_use]
            pub fn aren33(&mut self) -> AREN33_W<GPAREN1_SPEC, 1> {
                AREN33_W::new(self)
            }
            #[doc = "Bit 2 - Async rising enabled 34"]
            #[inline(always)]
            #[must_use]
            pub fn aren34(&mut self) -> AREN34_W<GPAREN1_SPEC, 2> {
                AREN34_W::new(self)
            }
            #[doc = "Bit 3 - Async rising enabled 35"]
            #[inline(always)]
            #[must_use]
            pub fn aren35(&mut self) -> AREN35_W<GPAREN1_SPEC, 3> {
                AREN35_W::new(self)
            }
            #[doc = "Bit 4 - Async rising enabled 36"]
            #[inline(always)]
            #[must_use]
            pub fn aren36(&mut self) -> AREN36_W<GPAREN1_SPEC, 4> {
                AREN36_W::new(self)
            }
            #[doc = "Bit 5 - Async rising enabled 37"]
            #[inline(always)]
            #[must_use]
            pub fn aren37(&mut self) -> AREN37_W<GPAREN1_SPEC, 5> {
                AREN37_W::new(self)
            }
            #[doc = "Bit 6 - Async rising enabled 38"]
            #[inline(always)]
            #[must_use]
            pub fn aren38(&mut self) -> AREN38_W<GPAREN1_SPEC, 6> {
                AREN38_W::new(self)
            }
            #[doc = "Bit 7 - Async rising enabled 39"]
            #[inline(always)]
            #[must_use]
            pub fn aren39(&mut self) -> AREN39_W<GPAREN1_SPEC, 7> {
                AREN39_W::new(self)
            }
            #[doc = "Bit 8 - Async rising enabled 40"]
            #[inline(always)]
            #[must_use]
            pub fn aren40(&mut self) -> AREN40_W<GPAREN1_SPEC, 8> {
                AREN40_W::new(self)
            }
            #[doc = "Bit 9 - Async rising enabled 41"]
            #[inline(always)]
            #[must_use]
            pub fn aren41(&mut self) -> AREN41_W<GPAREN1_SPEC, 9> {
                AREN41_W::new(self)
            }
            #[doc = "Bit 10 - Async rising enabled 42"]
            #[inline(always)]
            #[must_use]
            pub fn aren42(&mut self) -> AREN42_W<GPAREN1_SPEC, 10> {
                AREN42_W::new(self)
            }
            #[doc = "Bit 11 - Async rising enabled 43"]
            #[inline(always)]
            #[must_use]
            pub fn aren43(&mut self) -> AREN43_W<GPAREN1_SPEC, 11> {
                AREN43_W::new(self)
            }
            #[doc = "Bit 12 - Async rising enabled 44"]
            #[inline(always)]
            #[must_use]
            pub fn aren44(&mut self) -> AREN44_W<GPAREN1_SPEC, 12> {
                AREN44_W::new(self)
            }
            #[doc = "Bit 13 - Async rising enabled 45"]
            #[inline(always)]
            #[must_use]
            pub fn aren45(&mut self) -> AREN45_W<GPAREN1_SPEC, 13> {
                AREN45_W::new(self)
            }
            #[doc = "Bit 14 - Async rising enabled 46"]
            #[inline(always)]
            #[must_use]
            pub fn aren46(&mut self) -> AREN46_W<GPAREN1_SPEC, 14> {
                AREN46_W::new(self)
            }
            #[doc = "Bit 15 - Async rising enabled 47"]
            #[inline(always)]
            #[must_use]
            pub fn aren47(&mut self) -> AREN47_W<GPAREN1_SPEC, 15> {
                AREN47_W::new(self)
            }
            #[doc = "Bit 16 - Async rising enabled 48"]
            #[inline(always)]
            #[must_use]
            pub fn aren48(&mut self) -> AREN48_W<GPAREN1_SPEC, 16> {
                AREN48_W::new(self)
            }
            #[doc = "Bit 17 - Async rising enabled 49"]
            #[inline(always)]
            #[must_use]
            pub fn aren49(&mut self) -> AREN49_W<GPAREN1_SPEC, 17> {
                AREN49_W::new(self)
            }
            #[doc = "Bit 18 - Async rising enabled 50"]
            #[inline(always)]
            #[must_use]
            pub fn aren50(&mut self) -> AREN50_W<GPAREN1_SPEC, 18> {
                AREN50_W::new(self)
            }
            #[doc = "Bit 19 - Async rising enabled 51"]
            #[inline(always)]
            #[must_use]
            pub fn aren51(&mut self) -> AREN51_W<GPAREN1_SPEC, 19> {
                AREN51_W::new(self)
            }
            #[doc = "Bit 20 - Async rising enabled 52"]
            #[inline(always)]
            #[must_use]
            pub fn aren52(&mut self) -> AREN52_W<GPAREN1_SPEC, 20> {
                AREN52_W::new(self)
            }
            #[doc = "Bit 21 - Async rising enabled 53"]
            #[inline(always)]
            #[must_use]
            pub fn aren53(&mut self) -> AREN53_W<GPAREN1_SPEC, 21> {
                AREN53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Async. Rising Edge Detect 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gparen1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gparen1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPAREN1_SPEC;
        impl crate::RegisterSpec for GPAREN1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gparen1::R`](R) reader structure"]
        impl crate::Readable for GPAREN1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gparen1::W`](W) writer structure"]
        impl crate::Writable for GPAREN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPAFEN0 (rw) register accessor: GPIO Pin Async. Falling Edge Detect 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpafen0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpafen0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpafen0`]
module"]
    pub type GPAFEN0 = crate::Reg<gpafen0::GPAFEN0_SPEC>;
    #[doc = "GPIO Pin Async. Falling Edge Detect 0"]
    pub mod gpafen0 {
        #[doc = "Register `GPAFEN0` reader"]
        pub type R = crate::R<GPAFEN0_SPEC>;
        #[doc = "Register `GPAFEN0` writer"]
        pub type W = crate::W<GPAFEN0_SPEC>;
        #[doc = "Field `AFEN0` reader - Async falling enabled 0"]
        pub type AFEN0_R = crate::BitReader;
        #[doc = "Field `AFEN0` writer - Async falling enabled 0"]
        pub type AFEN0_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN1` reader - Async falling enabled 1"]
        pub type AFEN1_R = crate::BitReader;
        #[doc = "Field `AFEN1` writer - Async falling enabled 1"]
        pub type AFEN1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN2` reader - Async falling enabled 2"]
        pub type AFEN2_R = crate::BitReader;
        #[doc = "Field `AFEN2` writer - Async falling enabled 2"]
        pub type AFEN2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN3` reader - Async falling enabled 3"]
        pub type AFEN3_R = crate::BitReader;
        #[doc = "Field `AFEN3` writer - Async falling enabled 3"]
        pub type AFEN3_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN4` reader - Async falling enabled 4"]
        pub type AFEN4_R = crate::BitReader;
        #[doc = "Field `AFEN4` writer - Async falling enabled 4"]
        pub type AFEN4_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN5` reader - Async falling enabled 5"]
        pub type AFEN5_R = crate::BitReader;
        #[doc = "Field `AFEN5` writer - Async falling enabled 5"]
        pub type AFEN5_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN6` reader - Async falling enabled 6"]
        pub type AFEN6_R = crate::BitReader;
        #[doc = "Field `AFEN6` writer - Async falling enabled 6"]
        pub type AFEN6_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN7` reader - Async falling enabled 7"]
        pub type AFEN7_R = crate::BitReader;
        #[doc = "Field `AFEN7` writer - Async falling enabled 7"]
        pub type AFEN7_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN8` reader - Async falling enabled 8"]
        pub type AFEN8_R = crate::BitReader;
        #[doc = "Field `AFEN8` writer - Async falling enabled 8"]
        pub type AFEN8_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN9` reader - Async falling enabled 9"]
        pub type AFEN9_R = crate::BitReader;
        #[doc = "Field `AFEN9` writer - Async falling enabled 9"]
        pub type AFEN9_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN10` reader - Async falling enabled 10"]
        pub type AFEN10_R = crate::BitReader;
        #[doc = "Field `AFEN10` writer - Async falling enabled 10"]
        pub type AFEN10_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN11` reader - Async falling enabled 11"]
        pub type AFEN11_R = crate::BitReader;
        #[doc = "Field `AFEN11` writer - Async falling enabled 11"]
        pub type AFEN11_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN12` reader - Async falling enabled 12"]
        pub type AFEN12_R = crate::BitReader;
        #[doc = "Field `AFEN12` writer - Async falling enabled 12"]
        pub type AFEN12_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN13` reader - Async falling enabled 13"]
        pub type AFEN13_R = crate::BitReader;
        #[doc = "Field `AFEN13` writer - Async falling enabled 13"]
        pub type AFEN13_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN14` reader - Async falling enabled 14"]
        pub type AFEN14_R = crate::BitReader;
        #[doc = "Field `AFEN14` writer - Async falling enabled 14"]
        pub type AFEN14_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN15` reader - Async falling enabled 15"]
        pub type AFEN15_R = crate::BitReader;
        #[doc = "Field `AFEN15` writer - Async falling enabled 15"]
        pub type AFEN15_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN16` reader - Async falling enabled 16"]
        pub type AFEN16_R = crate::BitReader;
        #[doc = "Field `AFEN16` writer - Async falling enabled 16"]
        pub type AFEN16_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN17` reader - Async falling enabled 17"]
        pub type AFEN17_R = crate::BitReader;
        #[doc = "Field `AFEN17` writer - Async falling enabled 17"]
        pub type AFEN17_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN18` reader - Async falling enabled 18"]
        pub type AFEN18_R = crate::BitReader;
        #[doc = "Field `AFEN18` writer - Async falling enabled 18"]
        pub type AFEN18_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN19` reader - Async falling enabled 19"]
        pub type AFEN19_R = crate::BitReader;
        #[doc = "Field `AFEN19` writer - Async falling enabled 19"]
        pub type AFEN19_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN20` reader - Async falling enabled 20"]
        pub type AFEN20_R = crate::BitReader;
        #[doc = "Field `AFEN20` writer - Async falling enabled 20"]
        pub type AFEN20_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN21` reader - Async falling enabled 21"]
        pub type AFEN21_R = crate::BitReader;
        #[doc = "Field `AFEN21` writer - Async falling enabled 21"]
        pub type AFEN21_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN22` reader - Async falling enabled 22"]
        pub type AFEN22_R = crate::BitReader;
        #[doc = "Field `AFEN22` writer - Async falling enabled 22"]
        pub type AFEN22_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN23` reader - Async falling enabled 23"]
        pub type AFEN23_R = crate::BitReader;
        #[doc = "Field `AFEN23` writer - Async falling enabled 23"]
        pub type AFEN23_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN24` reader - Async falling enabled 24"]
        pub type AFEN24_R = crate::BitReader;
        #[doc = "Field `AFEN24` writer - Async falling enabled 24"]
        pub type AFEN24_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN25` reader - Async falling enabled 25"]
        pub type AFEN25_R = crate::BitReader;
        #[doc = "Field `AFEN25` writer - Async falling enabled 25"]
        pub type AFEN25_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN26` reader - Async falling enabled 26"]
        pub type AFEN26_R = crate::BitReader;
        #[doc = "Field `AFEN26` writer - Async falling enabled 26"]
        pub type AFEN26_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN27` reader - Async falling enabled 27"]
        pub type AFEN27_R = crate::BitReader;
        #[doc = "Field `AFEN27` writer - Async falling enabled 27"]
        pub type AFEN27_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN28` reader - Async falling enabled 28"]
        pub type AFEN28_R = crate::BitReader;
        #[doc = "Field `AFEN28` writer - Async falling enabled 28"]
        pub type AFEN28_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN29` reader - Async falling enabled 29"]
        pub type AFEN29_R = crate::BitReader;
        #[doc = "Field `AFEN29` writer - Async falling enabled 29"]
        pub type AFEN29_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN30` reader - Async falling enabled 30"]
        pub type AFEN30_R = crate::BitReader;
        #[doc = "Field `AFEN30` writer - Async falling enabled 30"]
        pub type AFEN30_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN31` reader - Async falling enabled 31"]
        pub type AFEN31_R = crate::BitReader;
        #[doc = "Field `AFEN31` writer - Async falling enabled 31"]
        pub type AFEN31_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Async falling enabled 0"]
            #[inline(always)]
            pub fn afen0(&self) -> AFEN0_R {
                AFEN0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Async falling enabled 1"]
            #[inline(always)]
            pub fn afen1(&self) -> AFEN1_R {
                AFEN1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Async falling enabled 2"]
            #[inline(always)]
            pub fn afen2(&self) -> AFEN2_R {
                AFEN2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Async falling enabled 3"]
            #[inline(always)]
            pub fn afen3(&self) -> AFEN3_R {
                AFEN3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Async falling enabled 4"]
            #[inline(always)]
            pub fn afen4(&self) -> AFEN4_R {
                AFEN4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Async falling enabled 5"]
            #[inline(always)]
            pub fn afen5(&self) -> AFEN5_R {
                AFEN5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Async falling enabled 6"]
            #[inline(always)]
            pub fn afen6(&self) -> AFEN6_R {
                AFEN6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Async falling enabled 7"]
            #[inline(always)]
            pub fn afen7(&self) -> AFEN7_R {
                AFEN7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Async falling enabled 8"]
            #[inline(always)]
            pub fn afen8(&self) -> AFEN8_R {
                AFEN8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Async falling enabled 9"]
            #[inline(always)]
            pub fn afen9(&self) -> AFEN9_R {
                AFEN9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Async falling enabled 10"]
            #[inline(always)]
            pub fn afen10(&self) -> AFEN10_R {
                AFEN10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Async falling enabled 11"]
            #[inline(always)]
            pub fn afen11(&self) -> AFEN11_R {
                AFEN11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Async falling enabled 12"]
            #[inline(always)]
            pub fn afen12(&self) -> AFEN12_R {
                AFEN12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Async falling enabled 13"]
            #[inline(always)]
            pub fn afen13(&self) -> AFEN13_R {
                AFEN13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Async falling enabled 14"]
            #[inline(always)]
            pub fn afen14(&self) -> AFEN14_R {
                AFEN14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Async falling enabled 15"]
            #[inline(always)]
            pub fn afen15(&self) -> AFEN15_R {
                AFEN15_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Async falling enabled 16"]
            #[inline(always)]
            pub fn afen16(&self) -> AFEN16_R {
                AFEN16_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Async falling enabled 17"]
            #[inline(always)]
            pub fn afen17(&self) -> AFEN17_R {
                AFEN17_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Async falling enabled 18"]
            #[inline(always)]
            pub fn afen18(&self) -> AFEN18_R {
                AFEN18_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Async falling enabled 19"]
            #[inline(always)]
            pub fn afen19(&self) -> AFEN19_R {
                AFEN19_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Async falling enabled 20"]
            #[inline(always)]
            pub fn afen20(&self) -> AFEN20_R {
                AFEN20_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Async falling enabled 21"]
            #[inline(always)]
            pub fn afen21(&self) -> AFEN21_R {
                AFEN21_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Async falling enabled 22"]
            #[inline(always)]
            pub fn afen22(&self) -> AFEN22_R {
                AFEN22_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Async falling enabled 23"]
            #[inline(always)]
            pub fn afen23(&self) -> AFEN23_R {
                AFEN23_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Async falling enabled 24"]
            #[inline(always)]
            pub fn afen24(&self) -> AFEN24_R {
                AFEN24_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Async falling enabled 25"]
            #[inline(always)]
            pub fn afen25(&self) -> AFEN25_R {
                AFEN25_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Async falling enabled 26"]
            #[inline(always)]
            pub fn afen26(&self) -> AFEN26_R {
                AFEN26_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Async falling enabled 27"]
            #[inline(always)]
            pub fn afen27(&self) -> AFEN27_R {
                AFEN27_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - Async falling enabled 28"]
            #[inline(always)]
            pub fn afen28(&self) -> AFEN28_R {
                AFEN28_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Async falling enabled 29"]
            #[inline(always)]
            pub fn afen29(&self) -> AFEN29_R {
                AFEN29_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Async falling enabled 30"]
            #[inline(always)]
            pub fn afen30(&self) -> AFEN30_R {
                AFEN30_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Async falling enabled 31"]
            #[inline(always)]
            pub fn afen31(&self) -> AFEN31_R {
                AFEN31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPAFEN0")
                    .field("afen0", &format_args!("{}", self.afen0().bit()))
                    .field("afen1", &format_args!("{}", self.afen1().bit()))
                    .field("afen2", &format_args!("{}", self.afen2().bit()))
                    .field("afen3", &format_args!("{}", self.afen3().bit()))
                    .field("afen4", &format_args!("{}", self.afen4().bit()))
                    .field("afen5", &format_args!("{}", self.afen5().bit()))
                    .field("afen6", &format_args!("{}", self.afen6().bit()))
                    .field("afen7", &format_args!("{}", self.afen7().bit()))
                    .field("afen8", &format_args!("{}", self.afen8().bit()))
                    .field("afen9", &format_args!("{}", self.afen9().bit()))
                    .field("afen10", &format_args!("{}", self.afen10().bit()))
                    .field("afen11", &format_args!("{}", self.afen11().bit()))
                    .field("afen12", &format_args!("{}", self.afen12().bit()))
                    .field("afen13", &format_args!("{}", self.afen13().bit()))
                    .field("afen14", &format_args!("{}", self.afen14().bit()))
                    .field("afen15", &format_args!("{}", self.afen15().bit()))
                    .field("afen16", &format_args!("{}", self.afen16().bit()))
                    .field("afen17", &format_args!("{}", self.afen17().bit()))
                    .field("afen18", &format_args!("{}", self.afen18().bit()))
                    .field("afen19", &format_args!("{}", self.afen19().bit()))
                    .field("afen20", &format_args!("{}", self.afen20().bit()))
                    .field("afen21", &format_args!("{}", self.afen21().bit()))
                    .field("afen22", &format_args!("{}", self.afen22().bit()))
                    .field("afen23", &format_args!("{}", self.afen23().bit()))
                    .field("afen24", &format_args!("{}", self.afen24().bit()))
                    .field("afen25", &format_args!("{}", self.afen25().bit()))
                    .field("afen26", &format_args!("{}", self.afen26().bit()))
                    .field("afen27", &format_args!("{}", self.afen27().bit()))
                    .field("afen28", &format_args!("{}", self.afen28().bit()))
                    .field("afen29", &format_args!("{}", self.afen29().bit()))
                    .field("afen30", &format_args!("{}", self.afen30().bit()))
                    .field("afen31", &format_args!("{}", self.afen31().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPAFEN0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Async falling enabled 0"]
            #[inline(always)]
            #[must_use]
            pub fn afen0(&mut self) -> AFEN0_W<GPAFEN0_SPEC, 0> {
                AFEN0_W::new(self)
            }
            #[doc = "Bit 1 - Async falling enabled 1"]
            #[inline(always)]
            #[must_use]
            pub fn afen1(&mut self) -> AFEN1_W<GPAFEN0_SPEC, 1> {
                AFEN1_W::new(self)
            }
            #[doc = "Bit 2 - Async falling enabled 2"]
            #[inline(always)]
            #[must_use]
            pub fn afen2(&mut self) -> AFEN2_W<GPAFEN0_SPEC, 2> {
                AFEN2_W::new(self)
            }
            #[doc = "Bit 3 - Async falling enabled 3"]
            #[inline(always)]
            #[must_use]
            pub fn afen3(&mut self) -> AFEN3_W<GPAFEN0_SPEC, 3> {
                AFEN3_W::new(self)
            }
            #[doc = "Bit 4 - Async falling enabled 4"]
            #[inline(always)]
            #[must_use]
            pub fn afen4(&mut self) -> AFEN4_W<GPAFEN0_SPEC, 4> {
                AFEN4_W::new(self)
            }
            #[doc = "Bit 5 - Async falling enabled 5"]
            #[inline(always)]
            #[must_use]
            pub fn afen5(&mut self) -> AFEN5_W<GPAFEN0_SPEC, 5> {
                AFEN5_W::new(self)
            }
            #[doc = "Bit 6 - Async falling enabled 6"]
            #[inline(always)]
            #[must_use]
            pub fn afen6(&mut self) -> AFEN6_W<GPAFEN0_SPEC, 6> {
                AFEN6_W::new(self)
            }
            #[doc = "Bit 7 - Async falling enabled 7"]
            #[inline(always)]
            #[must_use]
            pub fn afen7(&mut self) -> AFEN7_W<GPAFEN0_SPEC, 7> {
                AFEN7_W::new(self)
            }
            #[doc = "Bit 8 - Async falling enabled 8"]
            #[inline(always)]
            #[must_use]
            pub fn afen8(&mut self) -> AFEN8_W<GPAFEN0_SPEC, 8> {
                AFEN8_W::new(self)
            }
            #[doc = "Bit 9 - Async falling enabled 9"]
            #[inline(always)]
            #[must_use]
            pub fn afen9(&mut self) -> AFEN9_W<GPAFEN0_SPEC, 9> {
                AFEN9_W::new(self)
            }
            #[doc = "Bit 10 - Async falling enabled 10"]
            #[inline(always)]
            #[must_use]
            pub fn afen10(&mut self) -> AFEN10_W<GPAFEN0_SPEC, 10> {
                AFEN10_W::new(self)
            }
            #[doc = "Bit 11 - Async falling enabled 11"]
            #[inline(always)]
            #[must_use]
            pub fn afen11(&mut self) -> AFEN11_W<GPAFEN0_SPEC, 11> {
                AFEN11_W::new(self)
            }
            #[doc = "Bit 12 - Async falling enabled 12"]
            #[inline(always)]
            #[must_use]
            pub fn afen12(&mut self) -> AFEN12_W<GPAFEN0_SPEC, 12> {
                AFEN12_W::new(self)
            }
            #[doc = "Bit 13 - Async falling enabled 13"]
            #[inline(always)]
            #[must_use]
            pub fn afen13(&mut self) -> AFEN13_W<GPAFEN0_SPEC, 13> {
                AFEN13_W::new(self)
            }
            #[doc = "Bit 14 - Async falling enabled 14"]
            #[inline(always)]
            #[must_use]
            pub fn afen14(&mut self) -> AFEN14_W<GPAFEN0_SPEC, 14> {
                AFEN14_W::new(self)
            }
            #[doc = "Bit 15 - Async falling enabled 15"]
            #[inline(always)]
            #[must_use]
            pub fn afen15(&mut self) -> AFEN15_W<GPAFEN0_SPEC, 15> {
                AFEN15_W::new(self)
            }
            #[doc = "Bit 16 - Async falling enabled 16"]
            #[inline(always)]
            #[must_use]
            pub fn afen16(&mut self) -> AFEN16_W<GPAFEN0_SPEC, 16> {
                AFEN16_W::new(self)
            }
            #[doc = "Bit 17 - Async falling enabled 17"]
            #[inline(always)]
            #[must_use]
            pub fn afen17(&mut self) -> AFEN17_W<GPAFEN0_SPEC, 17> {
                AFEN17_W::new(self)
            }
            #[doc = "Bit 18 - Async falling enabled 18"]
            #[inline(always)]
            #[must_use]
            pub fn afen18(&mut self) -> AFEN18_W<GPAFEN0_SPEC, 18> {
                AFEN18_W::new(self)
            }
            #[doc = "Bit 19 - Async falling enabled 19"]
            #[inline(always)]
            #[must_use]
            pub fn afen19(&mut self) -> AFEN19_W<GPAFEN0_SPEC, 19> {
                AFEN19_W::new(self)
            }
            #[doc = "Bit 20 - Async falling enabled 20"]
            #[inline(always)]
            #[must_use]
            pub fn afen20(&mut self) -> AFEN20_W<GPAFEN0_SPEC, 20> {
                AFEN20_W::new(self)
            }
            #[doc = "Bit 21 - Async falling enabled 21"]
            #[inline(always)]
            #[must_use]
            pub fn afen21(&mut self) -> AFEN21_W<GPAFEN0_SPEC, 21> {
                AFEN21_W::new(self)
            }
            #[doc = "Bit 22 - Async falling enabled 22"]
            #[inline(always)]
            #[must_use]
            pub fn afen22(&mut self) -> AFEN22_W<GPAFEN0_SPEC, 22> {
                AFEN22_W::new(self)
            }
            #[doc = "Bit 23 - Async falling enabled 23"]
            #[inline(always)]
            #[must_use]
            pub fn afen23(&mut self) -> AFEN23_W<GPAFEN0_SPEC, 23> {
                AFEN23_W::new(self)
            }
            #[doc = "Bit 24 - Async falling enabled 24"]
            #[inline(always)]
            #[must_use]
            pub fn afen24(&mut self) -> AFEN24_W<GPAFEN0_SPEC, 24> {
                AFEN24_W::new(self)
            }
            #[doc = "Bit 25 - Async falling enabled 25"]
            #[inline(always)]
            #[must_use]
            pub fn afen25(&mut self) -> AFEN25_W<GPAFEN0_SPEC, 25> {
                AFEN25_W::new(self)
            }
            #[doc = "Bit 26 - Async falling enabled 26"]
            #[inline(always)]
            #[must_use]
            pub fn afen26(&mut self) -> AFEN26_W<GPAFEN0_SPEC, 26> {
                AFEN26_W::new(self)
            }
            #[doc = "Bit 27 - Async falling enabled 27"]
            #[inline(always)]
            #[must_use]
            pub fn afen27(&mut self) -> AFEN27_W<GPAFEN0_SPEC, 27> {
                AFEN27_W::new(self)
            }
            #[doc = "Bit 28 - Async falling enabled 28"]
            #[inline(always)]
            #[must_use]
            pub fn afen28(&mut self) -> AFEN28_W<GPAFEN0_SPEC, 28> {
                AFEN28_W::new(self)
            }
            #[doc = "Bit 29 - Async falling enabled 29"]
            #[inline(always)]
            #[must_use]
            pub fn afen29(&mut self) -> AFEN29_W<GPAFEN0_SPEC, 29> {
                AFEN29_W::new(self)
            }
            #[doc = "Bit 30 - Async falling enabled 30"]
            #[inline(always)]
            #[must_use]
            pub fn afen30(&mut self) -> AFEN30_W<GPAFEN0_SPEC, 30> {
                AFEN30_W::new(self)
            }
            #[doc = "Bit 31 - Async falling enabled 31"]
            #[inline(always)]
            #[must_use]
            pub fn afen31(&mut self) -> AFEN31_W<GPAFEN0_SPEC, 31> {
                AFEN31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Async. Falling Edge Detect 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpafen0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpafen0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPAFEN0_SPEC;
        impl crate::RegisterSpec for GPAFEN0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpafen0::R`](R) reader structure"]
        impl crate::Readable for GPAFEN0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpafen0::W`](W) writer structure"]
        impl crate::Writable for GPAFEN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPAFEN1 (rw) register accessor: GPIO Pin Async. Falling Edge Detect 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpafen1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpafen1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpafen1`]
module"]
    pub type GPAFEN1 = crate::Reg<gpafen1::GPAFEN1_SPEC>;
    #[doc = "GPIO Pin Async. Falling Edge Detect 1"]
    pub mod gpafen1 {
        #[doc = "Register `GPAFEN1` reader"]
        pub type R = crate::R<GPAFEN1_SPEC>;
        #[doc = "Register `GPAFEN1` writer"]
        pub type W = crate::W<GPAFEN1_SPEC>;
        #[doc = "Field `AFEN32` reader - Async falling enabled 32"]
        pub type AFEN32_R = crate::BitReader;
        #[doc = "Field `AFEN32` writer - Async falling enabled 32"]
        pub type AFEN32_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN33` reader - Async falling enabled 33"]
        pub type AFEN33_R = crate::BitReader;
        #[doc = "Field `AFEN33` writer - Async falling enabled 33"]
        pub type AFEN33_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN34` reader - Async falling enabled 34"]
        pub type AFEN34_R = crate::BitReader;
        #[doc = "Field `AFEN34` writer - Async falling enabled 34"]
        pub type AFEN34_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN35` reader - Async falling enabled 35"]
        pub type AFEN35_R = crate::BitReader;
        #[doc = "Field `AFEN35` writer - Async falling enabled 35"]
        pub type AFEN35_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN36` reader - Async falling enabled 36"]
        pub type AFEN36_R = crate::BitReader;
        #[doc = "Field `AFEN36` writer - Async falling enabled 36"]
        pub type AFEN36_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN37` reader - Async falling enabled 37"]
        pub type AFEN37_R = crate::BitReader;
        #[doc = "Field `AFEN37` writer - Async falling enabled 37"]
        pub type AFEN37_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN38` reader - Async falling enabled 38"]
        pub type AFEN38_R = crate::BitReader;
        #[doc = "Field `AFEN38` writer - Async falling enabled 38"]
        pub type AFEN38_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN39` reader - Async falling enabled 39"]
        pub type AFEN39_R = crate::BitReader;
        #[doc = "Field `AFEN39` writer - Async falling enabled 39"]
        pub type AFEN39_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN40` reader - Async falling enabled 40"]
        pub type AFEN40_R = crate::BitReader;
        #[doc = "Field `AFEN40` writer - Async falling enabled 40"]
        pub type AFEN40_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN41` reader - Async falling enabled 41"]
        pub type AFEN41_R = crate::BitReader;
        #[doc = "Field `AFEN41` writer - Async falling enabled 41"]
        pub type AFEN41_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN42` reader - Async falling enabled 42"]
        pub type AFEN42_R = crate::BitReader;
        #[doc = "Field `AFEN42` writer - Async falling enabled 42"]
        pub type AFEN42_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN43` reader - Async falling enabled 43"]
        pub type AFEN43_R = crate::BitReader;
        #[doc = "Field `AFEN43` writer - Async falling enabled 43"]
        pub type AFEN43_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN44` reader - Async falling enabled 44"]
        pub type AFEN44_R = crate::BitReader;
        #[doc = "Field `AFEN44` writer - Async falling enabled 44"]
        pub type AFEN44_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN45` reader - Async falling enabled 45"]
        pub type AFEN45_R = crate::BitReader;
        #[doc = "Field `AFEN45` writer - Async falling enabled 45"]
        pub type AFEN45_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN46` reader - Async falling enabled 46"]
        pub type AFEN46_R = crate::BitReader;
        #[doc = "Field `AFEN46` writer - Async falling enabled 46"]
        pub type AFEN46_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN47` reader - Async falling enabled 47"]
        pub type AFEN47_R = crate::BitReader;
        #[doc = "Field `AFEN47` writer - Async falling enabled 47"]
        pub type AFEN47_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN48` reader - Async falling enabled 48"]
        pub type AFEN48_R = crate::BitReader;
        #[doc = "Field `AFEN48` writer - Async falling enabled 48"]
        pub type AFEN48_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN49` reader - Async falling enabled 49"]
        pub type AFEN49_R = crate::BitReader;
        #[doc = "Field `AFEN49` writer - Async falling enabled 49"]
        pub type AFEN49_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN50` reader - Async falling enabled 50"]
        pub type AFEN50_R = crate::BitReader;
        #[doc = "Field `AFEN50` writer - Async falling enabled 50"]
        pub type AFEN50_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN51` reader - Async falling enabled 51"]
        pub type AFEN51_R = crate::BitReader;
        #[doc = "Field `AFEN51` writer - Async falling enabled 51"]
        pub type AFEN51_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN52` reader - Async falling enabled 52"]
        pub type AFEN52_R = crate::BitReader;
        #[doc = "Field `AFEN52` writer - Async falling enabled 52"]
        pub type AFEN52_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AFEN53` reader - Async falling enabled 53"]
        pub type AFEN53_R = crate::BitReader;
        #[doc = "Field `AFEN53` writer - Async falling enabled 53"]
        pub type AFEN53_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Async falling enabled 32"]
            #[inline(always)]
            pub fn afen32(&self) -> AFEN32_R {
                AFEN32_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Async falling enabled 33"]
            #[inline(always)]
            pub fn afen33(&self) -> AFEN33_R {
                AFEN33_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Async falling enabled 34"]
            #[inline(always)]
            pub fn afen34(&self) -> AFEN34_R {
                AFEN34_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Async falling enabled 35"]
            #[inline(always)]
            pub fn afen35(&self) -> AFEN35_R {
                AFEN35_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Async falling enabled 36"]
            #[inline(always)]
            pub fn afen36(&self) -> AFEN36_R {
                AFEN36_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Async falling enabled 37"]
            #[inline(always)]
            pub fn afen37(&self) -> AFEN37_R {
                AFEN37_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Async falling enabled 38"]
            #[inline(always)]
            pub fn afen38(&self) -> AFEN38_R {
                AFEN38_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Async falling enabled 39"]
            #[inline(always)]
            pub fn afen39(&self) -> AFEN39_R {
                AFEN39_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Async falling enabled 40"]
            #[inline(always)]
            pub fn afen40(&self) -> AFEN40_R {
                AFEN40_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Async falling enabled 41"]
            #[inline(always)]
            pub fn afen41(&self) -> AFEN41_R {
                AFEN41_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Async falling enabled 42"]
            #[inline(always)]
            pub fn afen42(&self) -> AFEN42_R {
                AFEN42_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Async falling enabled 43"]
            #[inline(always)]
            pub fn afen43(&self) -> AFEN43_R {
                AFEN43_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Async falling enabled 44"]
            #[inline(always)]
            pub fn afen44(&self) -> AFEN44_R {
                AFEN44_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Async falling enabled 45"]
            #[inline(always)]
            pub fn afen45(&self) -> AFEN45_R {
                AFEN45_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Async falling enabled 46"]
            #[inline(always)]
            pub fn afen46(&self) -> AFEN46_R {
                AFEN46_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Async falling enabled 47"]
            #[inline(always)]
            pub fn afen47(&self) -> AFEN47_R {
                AFEN47_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Async falling enabled 48"]
            #[inline(always)]
            pub fn afen48(&self) -> AFEN48_R {
                AFEN48_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Async falling enabled 49"]
            #[inline(always)]
            pub fn afen49(&self) -> AFEN49_R {
                AFEN49_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Async falling enabled 50"]
            #[inline(always)]
            pub fn afen50(&self) -> AFEN50_R {
                AFEN50_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Async falling enabled 51"]
            #[inline(always)]
            pub fn afen51(&self) -> AFEN51_R {
                AFEN51_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Async falling enabled 52"]
            #[inline(always)]
            pub fn afen52(&self) -> AFEN52_R {
                AFEN52_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Async falling enabled 53"]
            #[inline(always)]
            pub fn afen53(&self) -> AFEN53_R {
                AFEN53_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPAFEN1")
                    .field("afen32", &format_args!("{}", self.afen32().bit()))
                    .field("afen33", &format_args!("{}", self.afen33().bit()))
                    .field("afen34", &format_args!("{}", self.afen34().bit()))
                    .field("afen35", &format_args!("{}", self.afen35().bit()))
                    .field("afen36", &format_args!("{}", self.afen36().bit()))
                    .field("afen37", &format_args!("{}", self.afen37().bit()))
                    .field("afen38", &format_args!("{}", self.afen38().bit()))
                    .field("afen39", &format_args!("{}", self.afen39().bit()))
                    .field("afen40", &format_args!("{}", self.afen40().bit()))
                    .field("afen41", &format_args!("{}", self.afen41().bit()))
                    .field("afen42", &format_args!("{}", self.afen42().bit()))
                    .field("afen43", &format_args!("{}", self.afen43().bit()))
                    .field("afen44", &format_args!("{}", self.afen44().bit()))
                    .field("afen45", &format_args!("{}", self.afen45().bit()))
                    .field("afen46", &format_args!("{}", self.afen46().bit()))
                    .field("afen47", &format_args!("{}", self.afen47().bit()))
                    .field("afen48", &format_args!("{}", self.afen48().bit()))
                    .field("afen49", &format_args!("{}", self.afen49().bit()))
                    .field("afen50", &format_args!("{}", self.afen50().bit()))
                    .field("afen51", &format_args!("{}", self.afen51().bit()))
                    .field("afen52", &format_args!("{}", self.afen52().bit()))
                    .field("afen53", &format_args!("{}", self.afen53().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPAFEN1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Async falling enabled 32"]
            #[inline(always)]
            #[must_use]
            pub fn afen32(&mut self) -> AFEN32_W<GPAFEN1_SPEC, 0> {
                AFEN32_W::new(self)
            }
            #[doc = "Bit 1 - Async falling enabled 33"]
            #[inline(always)]
            #[must_use]
            pub fn afen33(&mut self) -> AFEN33_W<GPAFEN1_SPEC, 1> {
                AFEN33_W::new(self)
            }
            #[doc = "Bit 2 - Async falling enabled 34"]
            #[inline(always)]
            #[must_use]
            pub fn afen34(&mut self) -> AFEN34_W<GPAFEN1_SPEC, 2> {
                AFEN34_W::new(self)
            }
            #[doc = "Bit 3 - Async falling enabled 35"]
            #[inline(always)]
            #[must_use]
            pub fn afen35(&mut self) -> AFEN35_W<GPAFEN1_SPEC, 3> {
                AFEN35_W::new(self)
            }
            #[doc = "Bit 4 - Async falling enabled 36"]
            #[inline(always)]
            #[must_use]
            pub fn afen36(&mut self) -> AFEN36_W<GPAFEN1_SPEC, 4> {
                AFEN36_W::new(self)
            }
            #[doc = "Bit 5 - Async falling enabled 37"]
            #[inline(always)]
            #[must_use]
            pub fn afen37(&mut self) -> AFEN37_W<GPAFEN1_SPEC, 5> {
                AFEN37_W::new(self)
            }
            #[doc = "Bit 6 - Async falling enabled 38"]
            #[inline(always)]
            #[must_use]
            pub fn afen38(&mut self) -> AFEN38_W<GPAFEN1_SPEC, 6> {
                AFEN38_W::new(self)
            }
            #[doc = "Bit 7 - Async falling enabled 39"]
            #[inline(always)]
            #[must_use]
            pub fn afen39(&mut self) -> AFEN39_W<GPAFEN1_SPEC, 7> {
                AFEN39_W::new(self)
            }
            #[doc = "Bit 8 - Async falling enabled 40"]
            #[inline(always)]
            #[must_use]
            pub fn afen40(&mut self) -> AFEN40_W<GPAFEN1_SPEC, 8> {
                AFEN40_W::new(self)
            }
            #[doc = "Bit 9 - Async falling enabled 41"]
            #[inline(always)]
            #[must_use]
            pub fn afen41(&mut self) -> AFEN41_W<GPAFEN1_SPEC, 9> {
                AFEN41_W::new(self)
            }
            #[doc = "Bit 10 - Async falling enabled 42"]
            #[inline(always)]
            #[must_use]
            pub fn afen42(&mut self) -> AFEN42_W<GPAFEN1_SPEC, 10> {
                AFEN42_W::new(self)
            }
            #[doc = "Bit 11 - Async falling enabled 43"]
            #[inline(always)]
            #[must_use]
            pub fn afen43(&mut self) -> AFEN43_W<GPAFEN1_SPEC, 11> {
                AFEN43_W::new(self)
            }
            #[doc = "Bit 12 - Async falling enabled 44"]
            #[inline(always)]
            #[must_use]
            pub fn afen44(&mut self) -> AFEN44_W<GPAFEN1_SPEC, 12> {
                AFEN44_W::new(self)
            }
            #[doc = "Bit 13 - Async falling enabled 45"]
            #[inline(always)]
            #[must_use]
            pub fn afen45(&mut self) -> AFEN45_W<GPAFEN1_SPEC, 13> {
                AFEN45_W::new(self)
            }
            #[doc = "Bit 14 - Async falling enabled 46"]
            #[inline(always)]
            #[must_use]
            pub fn afen46(&mut self) -> AFEN46_W<GPAFEN1_SPEC, 14> {
                AFEN46_W::new(self)
            }
            #[doc = "Bit 15 - Async falling enabled 47"]
            #[inline(always)]
            #[must_use]
            pub fn afen47(&mut self) -> AFEN47_W<GPAFEN1_SPEC, 15> {
                AFEN47_W::new(self)
            }
            #[doc = "Bit 16 - Async falling enabled 48"]
            #[inline(always)]
            #[must_use]
            pub fn afen48(&mut self) -> AFEN48_W<GPAFEN1_SPEC, 16> {
                AFEN48_W::new(self)
            }
            #[doc = "Bit 17 - Async falling enabled 49"]
            #[inline(always)]
            #[must_use]
            pub fn afen49(&mut self) -> AFEN49_W<GPAFEN1_SPEC, 17> {
                AFEN49_W::new(self)
            }
            #[doc = "Bit 18 - Async falling enabled 50"]
            #[inline(always)]
            #[must_use]
            pub fn afen50(&mut self) -> AFEN50_W<GPAFEN1_SPEC, 18> {
                AFEN50_W::new(self)
            }
            #[doc = "Bit 19 - Async falling enabled 51"]
            #[inline(always)]
            #[must_use]
            pub fn afen51(&mut self) -> AFEN51_W<GPAFEN1_SPEC, 19> {
                AFEN51_W::new(self)
            }
            #[doc = "Bit 20 - Async falling enabled 52"]
            #[inline(always)]
            #[must_use]
            pub fn afen52(&mut self) -> AFEN52_W<GPAFEN1_SPEC, 20> {
                AFEN52_W::new(self)
            }
            #[doc = "Bit 21 - Async falling enabled 53"]
            #[inline(always)]
            #[must_use]
            pub fn afen53(&mut self) -> AFEN53_W<GPAFEN1_SPEC, 21> {
                AFEN53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pin Async. Falling Edge Detect 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpafen1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpafen1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPAFEN1_SPEC;
        impl crate::RegisterSpec for GPAFEN1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpafen1::R`](R) reader structure"]
        impl crate::Readable for GPAFEN1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpafen1::W`](W) writer structure"]
        impl crate::Writable for GPAFEN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "EXTRA_MUX (rw) register accessor: Undocumented multiplexing bits\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`extra_mux::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`extra_mux::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@extra_mux`]
module"]
    pub type EXTRA_MUX = crate::Reg<extra_mux::EXTRA_MUX_SPEC>;
    #[doc = "Undocumented multiplexing bits"]
    pub mod extra_mux {
        #[doc = "Register `EXTRA_MUX` reader"]
        pub type R = crate::R<EXTRA_MUX_SPEC>;
        #[doc = "Register `EXTRA_MUX` writer"]
        pub type W = crate::W<EXTRA_MUX_SPEC>;
        #[doc = "Field `SDIO` reader - Switch peripheral connection to undocumented SDIO pins used on Pi 4"]
        pub type SDIO_R = crate::BitReader<SDIO_A>;
        #[doc = "Switch peripheral connection to undocumented SDIO pins used on Pi 4"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SDIO_A {
            #[doc = "0: Connect the newer SD host"]
            SDHOST = 0,
            #[doc = "1: Connect Arasan SD/EMMC host"]
            ARASAN = 1,
        }
        impl From<SDIO_A> for bool {
            #[inline(always)]
            fn from(variant: SDIO_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SDIO_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SDIO_A {
                match self.bits {
                    false => SDIO_A::SDHOST,
                    true => SDIO_A::ARASAN,
                }
            }
            #[doc = "Connect the newer SD host"]
            #[inline(always)]
            pub fn is_sdhost(&self) -> bool {
                *self == SDIO_A::SDHOST
            }
            #[doc = "Connect Arasan SD/EMMC host"]
            #[inline(always)]
            pub fn is_arasan(&self) -> bool {
                *self == SDIO_A::ARASAN
            }
        }
        #[doc = "Field `SDIO` writer - Switch peripheral connection to undocumented SDIO pins used on Pi 4"]
        pub type SDIO_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, SDIO_A>;
        impl<'a, REG, const O: u8> SDIO_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Connect the newer SD host"]
            #[inline(always)]
            pub fn sdhost(self) -> &'a mut crate::W<REG> {
                self.variant(SDIO_A::SDHOST)
            }
            #[doc = "Connect Arasan SD/EMMC host"]
            #[inline(always)]
            pub fn arasan(self) -> &'a mut crate::W<REG> {
                self.variant(SDIO_A::ARASAN)
            }
        }
        impl R {
            #[doc = "Bit 1 - Switch peripheral connection to undocumented SDIO pins used on Pi 4"]
            #[inline(always)]
            pub fn sdio(&self) -> SDIO_R {
                SDIO_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EXTRA_MUX")
                    .field("sdio", &format_args!("{}", self.sdio().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<EXTRA_MUX_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - Switch peripheral connection to undocumented SDIO pins used on Pi 4"]
            #[inline(always)]
            #[must_use]
            pub fn sdio(&mut self) -> SDIO_W<EXTRA_MUX_SPEC, 1> {
                SDIO_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Undocumented multiplexing bits\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`extra_mux::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`extra_mux::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EXTRA_MUX_SPEC;
        impl crate::RegisterSpec for EXTRA_MUX_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`extra_mux::R`](R) reader structure"]
        impl crate::Readable for EXTRA_MUX_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`extra_mux::W`](W) writer structure"]
        impl crate::Writable for EXTRA_MUX_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPIO_PUP_PDN_CNTRL_REG0 (rw) register accessor: GPIO Pull-up / Pull-down Register 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpio_pup_pdn_cntrl_reg0::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpio_pup_pdn_cntrl_reg0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpio_pup_pdn_cntrl_reg0`]
module"]
    pub type GPIO_PUP_PDN_CNTRL_REG0 =
        crate::Reg<gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL_REG0_SPEC>;
    #[doc = "GPIO Pull-up / Pull-down Register 0"]
    pub mod gpio_pup_pdn_cntrl_reg0 {
        #[doc = "Register `GPIO_PUP_PDN_CNTRL_REG0` reader"]
        pub type R = crate::R<GPIO_PUP_PDN_CNTRL_REG0_SPEC>;
        #[doc = "Register `GPIO_PUP_PDN_CNTRL_REG0` writer"]
        pub type W = crate::W<GPIO_PUP_PDN_CNTRL_REG0_SPEC>;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL0` reader - Resistor select for 0"]
        pub type GPIO_PUP_PDN_CNTRL0_R = crate::FieldReader<BP_PULL_A>;
        #[doc = "Resistor select for 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum BP_PULL_A {
            #[doc = "0: No pull"]
            NONE = 0,
            #[doc = "1: Pull up"]
            UP = 1,
            #[doc = "2: Pull down"]
            DOWN = 2,
        }
        impl From<BP_PULL_A> for u8 {
            #[inline(always)]
            fn from(variant: BP_PULL_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for BP_PULL_A {
            type Ux = u8;
        }
        impl GPIO_PUP_PDN_CNTRL0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<BP_PULL_A> {
                match self.bits {
                    0 => Some(BP_PULL_A::NONE),
                    1 => Some(BP_PULL_A::UP),
                    2 => Some(BP_PULL_A::DOWN),
                    _ => None,
                }
            }
            #[doc = "No pull"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == BP_PULL_A::NONE
            }
            #[doc = "Pull up"]
            #[inline(always)]
            pub fn is_up(&self) -> bool {
                *self == BP_PULL_A::UP
            }
            #[doc = "Pull down"]
            #[inline(always)]
            pub fn is_down(&self) -> bool {
                *self == BP_PULL_A::DOWN
            }
        }
        #[doc = "Field `GPIO_PUP_PDN_CNTRL0` writer - Resistor select for 0"]
        pub type GPIO_PUP_PDN_CNTRL0_W<'a, REG, const O: u8> =
            crate::FieldWriter<'a, REG, 2, O, BP_PULL_A>;
        impl<'a, REG, const O: u8> GPIO_PUP_PDN_CNTRL0_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "No pull"]
            #[inline(always)]
            pub fn none(self) -> &'a mut crate::W<REG> {
                self.variant(BP_PULL_A::NONE)
            }
            #[doc = "Pull up"]
            #[inline(always)]
            pub fn up(self) -> &'a mut crate::W<REG> {
                self.variant(BP_PULL_A::UP)
            }
            #[doc = "Pull down"]
            #[inline(always)]
            pub fn down(self) -> &'a mut crate::W<REG> {
                self.variant(BP_PULL_A::DOWN)
            }
        }
        #[doc = "Field `GPIO_PUP_PDN_CNTRL1` reader - Resistor select for 1"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL1_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL2` reader - Resistor select for 2"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL2_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL3` reader - Resistor select for 3"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL3_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL4` reader - Resistor select for 4"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL4_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL5` reader - Resistor select for 5"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL5_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL6` reader - Resistor select for 6"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL6_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL7` reader - Resistor select for 7"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL7_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL8` reader - Resistor select for 8"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL8_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL9` reader - Resistor select for 9"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL9_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL10` reader - Resistor select for 10"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL10_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL11` reader - Resistor select for 11"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL11_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL12` reader - Resistor select for 12"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL12_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL13` reader - Resistor select for 13"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL13_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL14` reader - Resistor select for 14"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL14_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL15` reader - Resistor select for 15"]
        pub use GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL15_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL1` writer - Resistor select for 1"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL1_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL2` writer - Resistor select for 2"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL2_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL3` writer - Resistor select for 3"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL3_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL4` writer - Resistor select for 4"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL4_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL5` writer - Resistor select for 5"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL5_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL6` writer - Resistor select for 6"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL6_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL7` writer - Resistor select for 7"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL7_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL8` writer - Resistor select for 8"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL8_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL9` writer - Resistor select for 9"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL9_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL10` writer - Resistor select for 10"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL10_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL11` writer - Resistor select for 11"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL11_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL12` writer - Resistor select for 12"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL12_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL13` writer - Resistor select for 13"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL13_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL14` writer - Resistor select for 14"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL14_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL15` writer - Resistor select for 15"]
        pub use GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL15_W;
        impl R {
            #[doc = "Bits 0:1 - Resistor select for 0"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl0(&self) -> GPIO_PUP_PDN_CNTRL0_R {
                GPIO_PUP_PDN_CNTRL0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Resistor select for 1"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl1(&self) -> GPIO_PUP_PDN_CNTRL1_R {
                GPIO_PUP_PDN_CNTRL1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Resistor select for 2"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl2(&self) -> GPIO_PUP_PDN_CNTRL2_R {
                GPIO_PUP_PDN_CNTRL2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Resistor select for 3"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl3(&self) -> GPIO_PUP_PDN_CNTRL3_R {
                GPIO_PUP_PDN_CNTRL3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Resistor select for 4"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl4(&self) -> GPIO_PUP_PDN_CNTRL4_R {
                GPIO_PUP_PDN_CNTRL4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Resistor select for 5"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl5(&self) -> GPIO_PUP_PDN_CNTRL5_R {
                GPIO_PUP_PDN_CNTRL5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Resistor select for 6"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl6(&self) -> GPIO_PUP_PDN_CNTRL6_R {
                GPIO_PUP_PDN_CNTRL6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Resistor select for 7"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl7(&self) -> GPIO_PUP_PDN_CNTRL7_R {
                GPIO_PUP_PDN_CNTRL7_R::new(((self.bits >> 14) & 3) as u8)
            }
            #[doc = "Bits 16:17 - Resistor select for 8"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl8(&self) -> GPIO_PUP_PDN_CNTRL8_R {
                GPIO_PUP_PDN_CNTRL8_R::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bits 18:19 - Resistor select for 9"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl9(&self) -> GPIO_PUP_PDN_CNTRL9_R {
                GPIO_PUP_PDN_CNTRL9_R::new(((self.bits >> 18) & 3) as u8)
            }
            #[doc = "Bits 20:21 - Resistor select for 10"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl10(&self) -> GPIO_PUP_PDN_CNTRL10_R {
                GPIO_PUP_PDN_CNTRL10_R::new(((self.bits >> 20) & 3) as u8)
            }
            #[doc = "Bits 22:23 - Resistor select for 11"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl11(&self) -> GPIO_PUP_PDN_CNTRL11_R {
                GPIO_PUP_PDN_CNTRL11_R::new(((self.bits >> 22) & 3) as u8)
            }
            #[doc = "Bits 24:25 - Resistor select for 12"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl12(&self) -> GPIO_PUP_PDN_CNTRL12_R {
                GPIO_PUP_PDN_CNTRL12_R::new(((self.bits >> 24) & 3) as u8)
            }
            #[doc = "Bits 26:27 - Resistor select for 13"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl13(&self) -> GPIO_PUP_PDN_CNTRL13_R {
                GPIO_PUP_PDN_CNTRL13_R::new(((self.bits >> 26) & 3) as u8)
            }
            #[doc = "Bits 28:29 - Resistor select for 14"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl14(&self) -> GPIO_PUP_PDN_CNTRL14_R {
                GPIO_PUP_PDN_CNTRL14_R::new(((self.bits >> 28) & 3) as u8)
            }
            #[doc = "Bits 30:31 - Resistor select for 15"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl15(&self) -> GPIO_PUP_PDN_CNTRL15_R {
                GPIO_PUP_PDN_CNTRL15_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPIO_PUP_PDN_CNTRL_REG0")
                    .field(
                        "gpio_pup_pdn_cntrl0",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl0().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl1",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl1().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl2",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl2().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl3",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl3().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl4",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl4().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl5",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl5().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl6",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl6().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl7",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl7().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl8",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl8().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl9",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl9().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl10",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl10().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl11",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl11().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl12",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl12().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl13",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl13().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl14",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl14().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl15",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl15().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPIO_PUP_PDN_CNTRL_REG0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Resistor select for 0"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl0(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL0_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 0> {
                GPIO_PUP_PDN_CNTRL0_W::new(self)
            }
            #[doc = "Bits 2:3 - Resistor select for 1"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl1(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL1_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 2> {
                GPIO_PUP_PDN_CNTRL1_W::new(self)
            }
            #[doc = "Bits 4:5 - Resistor select for 2"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl2(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL2_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 4> {
                GPIO_PUP_PDN_CNTRL2_W::new(self)
            }
            #[doc = "Bits 6:7 - Resistor select for 3"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl3(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL3_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 6> {
                GPIO_PUP_PDN_CNTRL3_W::new(self)
            }
            #[doc = "Bits 8:9 - Resistor select for 4"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl4(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL4_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 8> {
                GPIO_PUP_PDN_CNTRL4_W::new(self)
            }
            #[doc = "Bits 10:11 - Resistor select for 5"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl5(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL5_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 10> {
                GPIO_PUP_PDN_CNTRL5_W::new(self)
            }
            #[doc = "Bits 12:13 - Resistor select for 6"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl6(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL6_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 12> {
                GPIO_PUP_PDN_CNTRL6_W::new(self)
            }
            #[doc = "Bits 14:15 - Resistor select for 7"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl7(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL7_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 14> {
                GPIO_PUP_PDN_CNTRL7_W::new(self)
            }
            #[doc = "Bits 16:17 - Resistor select for 8"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl8(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL8_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 16> {
                GPIO_PUP_PDN_CNTRL8_W::new(self)
            }
            #[doc = "Bits 18:19 - Resistor select for 9"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl9(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL9_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 18> {
                GPIO_PUP_PDN_CNTRL9_W::new(self)
            }
            #[doc = "Bits 20:21 - Resistor select for 10"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl10(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL10_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 20> {
                GPIO_PUP_PDN_CNTRL10_W::new(self)
            }
            #[doc = "Bits 22:23 - Resistor select for 11"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl11(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL11_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 22> {
                GPIO_PUP_PDN_CNTRL11_W::new(self)
            }
            #[doc = "Bits 24:25 - Resistor select for 12"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl12(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL12_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 24> {
                GPIO_PUP_PDN_CNTRL12_W::new(self)
            }
            #[doc = "Bits 26:27 - Resistor select for 13"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl13(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL13_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 26> {
                GPIO_PUP_PDN_CNTRL13_W::new(self)
            }
            #[doc = "Bits 28:29 - Resistor select for 14"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl14(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL14_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 28> {
                GPIO_PUP_PDN_CNTRL14_W::new(self)
            }
            #[doc = "Bits 30:31 - Resistor select for 15"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl15(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL15_W<GPIO_PUP_PDN_CNTRL_REG0_SPEC, 30> {
                GPIO_PUP_PDN_CNTRL15_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pull-up / Pull-down Register 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpio_pup_pdn_cntrl_reg0::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpio_pup_pdn_cntrl_reg0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPIO_PUP_PDN_CNTRL_REG0_SPEC;
        impl crate::RegisterSpec for GPIO_PUP_PDN_CNTRL_REG0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpio_pup_pdn_cntrl_reg0::R`](R) reader structure"]
        impl crate::Readable for GPIO_PUP_PDN_CNTRL_REG0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpio_pup_pdn_cntrl_reg0::W`](W) writer structure"]
        impl crate::Writable for GPIO_PUP_PDN_CNTRL_REG0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPIO_PUP_PDN_CNTRL_REG1 (rw) register accessor: GPIO Pull-up / Pull-down Register 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpio_pup_pdn_cntrl_reg1::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpio_pup_pdn_cntrl_reg1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpio_pup_pdn_cntrl_reg1`]
module"]
    pub type GPIO_PUP_PDN_CNTRL_REG1 =
        crate::Reg<gpio_pup_pdn_cntrl_reg1::GPIO_PUP_PDN_CNTRL_REG1_SPEC>;
    #[doc = "GPIO Pull-up / Pull-down Register 1"]
    pub mod gpio_pup_pdn_cntrl_reg1 {
        #[doc = "Register `GPIO_PUP_PDN_CNTRL_REG1` reader"]
        pub type R = crate::R<GPIO_PUP_PDN_CNTRL_REG1_SPEC>;
        #[doc = "Register `GPIO_PUP_PDN_CNTRL_REG1` writer"]
        pub type W = crate::W<GPIO_PUP_PDN_CNTRL_REG1_SPEC>;
        #[doc = "Resistor select for 16"]
        pub use super::gpio_pup_pdn_cntrl_reg0::BP_PULL_A;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL16` reader - Resistor select for 16"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL16_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL17` reader - Resistor select for 17"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL17_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL18` reader - Resistor select for 18"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL18_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL19` reader - Resistor select for 19"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL19_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL20` reader - Resistor select for 20"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL20_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL21` reader - Resistor select for 21"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL21_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL22` reader - Resistor select for 22"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL22_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL23` reader - Resistor select for 23"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL23_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL24` reader - Resistor select for 24"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL24_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL25` reader - Resistor select for 25"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL25_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL26` reader - Resistor select for 26"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL26_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL27` reader - Resistor select for 27"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL27_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL28` reader - Resistor select for 28"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL28_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL29` reader - Resistor select for 29"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL29_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL30` reader - Resistor select for 30"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL30_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL31` reader - Resistor select for 31"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL31_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL16` writer - Resistor select for 16"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL16_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL17` writer - Resistor select for 17"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL17_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL18` writer - Resistor select for 18"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL18_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL19` writer - Resistor select for 19"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL19_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL20` writer - Resistor select for 20"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL20_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL21` writer - Resistor select for 21"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL21_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL22` writer - Resistor select for 22"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL22_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL23` writer - Resistor select for 23"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL23_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL24` writer - Resistor select for 24"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL24_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL25` writer - Resistor select for 25"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL25_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL26` writer - Resistor select for 26"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL26_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL27` writer - Resistor select for 27"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL27_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL28` writer - Resistor select for 28"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL28_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL29` writer - Resistor select for 29"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL29_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL30` writer - Resistor select for 30"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL30_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL31` writer - Resistor select for 31"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL31_W;
        impl R {
            #[doc = "Bits 0:1 - Resistor select for 16"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl16(&self) -> GPIO_PUP_PDN_CNTRL16_R {
                GPIO_PUP_PDN_CNTRL16_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Resistor select for 17"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl17(&self) -> GPIO_PUP_PDN_CNTRL17_R {
                GPIO_PUP_PDN_CNTRL17_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Resistor select for 18"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl18(&self) -> GPIO_PUP_PDN_CNTRL18_R {
                GPIO_PUP_PDN_CNTRL18_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Resistor select for 19"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl19(&self) -> GPIO_PUP_PDN_CNTRL19_R {
                GPIO_PUP_PDN_CNTRL19_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Resistor select for 20"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl20(&self) -> GPIO_PUP_PDN_CNTRL20_R {
                GPIO_PUP_PDN_CNTRL20_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Resistor select for 21"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl21(&self) -> GPIO_PUP_PDN_CNTRL21_R {
                GPIO_PUP_PDN_CNTRL21_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Resistor select for 22"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl22(&self) -> GPIO_PUP_PDN_CNTRL22_R {
                GPIO_PUP_PDN_CNTRL22_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Resistor select for 23"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl23(&self) -> GPIO_PUP_PDN_CNTRL23_R {
                GPIO_PUP_PDN_CNTRL23_R::new(((self.bits >> 14) & 3) as u8)
            }
            #[doc = "Bits 16:17 - Resistor select for 24"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl24(&self) -> GPIO_PUP_PDN_CNTRL24_R {
                GPIO_PUP_PDN_CNTRL24_R::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bits 18:19 - Resistor select for 25"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl25(&self) -> GPIO_PUP_PDN_CNTRL25_R {
                GPIO_PUP_PDN_CNTRL25_R::new(((self.bits >> 18) & 3) as u8)
            }
            #[doc = "Bits 20:21 - Resistor select for 26"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl26(&self) -> GPIO_PUP_PDN_CNTRL26_R {
                GPIO_PUP_PDN_CNTRL26_R::new(((self.bits >> 20) & 3) as u8)
            }
            #[doc = "Bits 22:23 - Resistor select for 27"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl27(&self) -> GPIO_PUP_PDN_CNTRL27_R {
                GPIO_PUP_PDN_CNTRL27_R::new(((self.bits >> 22) & 3) as u8)
            }
            #[doc = "Bits 24:25 - Resistor select for 28"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl28(&self) -> GPIO_PUP_PDN_CNTRL28_R {
                GPIO_PUP_PDN_CNTRL28_R::new(((self.bits >> 24) & 3) as u8)
            }
            #[doc = "Bits 26:27 - Resistor select for 29"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl29(&self) -> GPIO_PUP_PDN_CNTRL29_R {
                GPIO_PUP_PDN_CNTRL29_R::new(((self.bits >> 26) & 3) as u8)
            }
            #[doc = "Bits 28:29 - Resistor select for 30"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl30(&self) -> GPIO_PUP_PDN_CNTRL30_R {
                GPIO_PUP_PDN_CNTRL30_R::new(((self.bits >> 28) & 3) as u8)
            }
            #[doc = "Bits 30:31 - Resistor select for 31"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl31(&self) -> GPIO_PUP_PDN_CNTRL31_R {
                GPIO_PUP_PDN_CNTRL31_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPIO_PUP_PDN_CNTRL_REG1")
                    .field(
                        "gpio_pup_pdn_cntrl16",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl16().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl17",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl17().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl18",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl18().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl19",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl19().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl20",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl20().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl21",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl21().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl22",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl22().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl23",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl23().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl24",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl24().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl25",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl25().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl26",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl26().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl27",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl27().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl28",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl28().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl29",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl29().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl30",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl30().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl31",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl31().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPIO_PUP_PDN_CNTRL_REG1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Resistor select for 16"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl16(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL16_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 0> {
                GPIO_PUP_PDN_CNTRL16_W::new(self)
            }
            #[doc = "Bits 2:3 - Resistor select for 17"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl17(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL17_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 2> {
                GPIO_PUP_PDN_CNTRL17_W::new(self)
            }
            #[doc = "Bits 4:5 - Resistor select for 18"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl18(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL18_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 4> {
                GPIO_PUP_PDN_CNTRL18_W::new(self)
            }
            #[doc = "Bits 6:7 - Resistor select for 19"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl19(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL19_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 6> {
                GPIO_PUP_PDN_CNTRL19_W::new(self)
            }
            #[doc = "Bits 8:9 - Resistor select for 20"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl20(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL20_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 8> {
                GPIO_PUP_PDN_CNTRL20_W::new(self)
            }
            #[doc = "Bits 10:11 - Resistor select for 21"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl21(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL21_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 10> {
                GPIO_PUP_PDN_CNTRL21_W::new(self)
            }
            #[doc = "Bits 12:13 - Resistor select for 22"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl22(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL22_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 12> {
                GPIO_PUP_PDN_CNTRL22_W::new(self)
            }
            #[doc = "Bits 14:15 - Resistor select for 23"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl23(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL23_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 14> {
                GPIO_PUP_PDN_CNTRL23_W::new(self)
            }
            #[doc = "Bits 16:17 - Resistor select for 24"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl24(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL24_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 16> {
                GPIO_PUP_PDN_CNTRL24_W::new(self)
            }
            #[doc = "Bits 18:19 - Resistor select for 25"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl25(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL25_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 18> {
                GPIO_PUP_PDN_CNTRL25_W::new(self)
            }
            #[doc = "Bits 20:21 - Resistor select for 26"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl26(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL26_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 20> {
                GPIO_PUP_PDN_CNTRL26_W::new(self)
            }
            #[doc = "Bits 22:23 - Resistor select for 27"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl27(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL27_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 22> {
                GPIO_PUP_PDN_CNTRL27_W::new(self)
            }
            #[doc = "Bits 24:25 - Resistor select for 28"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl28(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL28_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 24> {
                GPIO_PUP_PDN_CNTRL28_W::new(self)
            }
            #[doc = "Bits 26:27 - Resistor select for 29"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl29(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL29_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 26> {
                GPIO_PUP_PDN_CNTRL29_W::new(self)
            }
            #[doc = "Bits 28:29 - Resistor select for 30"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl30(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL30_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 28> {
                GPIO_PUP_PDN_CNTRL30_W::new(self)
            }
            #[doc = "Bits 30:31 - Resistor select for 31"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl31(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL31_W<GPIO_PUP_PDN_CNTRL_REG1_SPEC, 30> {
                GPIO_PUP_PDN_CNTRL31_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pull-up / Pull-down Register 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpio_pup_pdn_cntrl_reg1::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpio_pup_pdn_cntrl_reg1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPIO_PUP_PDN_CNTRL_REG1_SPEC;
        impl crate::RegisterSpec for GPIO_PUP_PDN_CNTRL_REG1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpio_pup_pdn_cntrl_reg1::R`](R) reader structure"]
        impl crate::Readable for GPIO_PUP_PDN_CNTRL_REG1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpio_pup_pdn_cntrl_reg1::W`](W) writer structure"]
        impl crate::Writable for GPIO_PUP_PDN_CNTRL_REG1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPIO_PUP_PDN_CNTRL_REG2 (rw) register accessor: GPIO Pull-up / Pull-down Register 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpio_pup_pdn_cntrl_reg2::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpio_pup_pdn_cntrl_reg2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpio_pup_pdn_cntrl_reg2`]
module"]
    pub type GPIO_PUP_PDN_CNTRL_REG2 =
        crate::Reg<gpio_pup_pdn_cntrl_reg2::GPIO_PUP_PDN_CNTRL_REG2_SPEC>;
    #[doc = "GPIO Pull-up / Pull-down Register 2"]
    pub mod gpio_pup_pdn_cntrl_reg2 {
        #[doc = "Register `GPIO_PUP_PDN_CNTRL_REG2` reader"]
        pub type R = crate::R<GPIO_PUP_PDN_CNTRL_REG2_SPEC>;
        #[doc = "Register `GPIO_PUP_PDN_CNTRL_REG2` writer"]
        pub type W = crate::W<GPIO_PUP_PDN_CNTRL_REG2_SPEC>;
        #[doc = "Resistor select for 32"]
        pub use super::gpio_pup_pdn_cntrl_reg0::BP_PULL_A;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL32` reader - Resistor select for 32"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL32_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL33` reader - Resistor select for 33"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL33_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL34` reader - Resistor select for 34"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL34_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL35` reader - Resistor select for 35"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL35_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL36` reader - Resistor select for 36"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL36_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL37` reader - Resistor select for 37"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL37_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL38` reader - Resistor select for 38"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL38_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL39` reader - Resistor select for 39"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL39_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL40` reader - Resistor select for 40"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL40_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL41` reader - Resistor select for 41"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL41_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL42` reader - Resistor select for 42"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL42_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL43` reader - Resistor select for 43"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL43_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL44` reader - Resistor select for 44"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL44_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL45` reader - Resistor select for 45"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL45_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL46` reader - Resistor select for 46"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL46_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL47` reader - Resistor select for 47"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL47_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL32` writer - Resistor select for 32"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL32_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL33` writer - Resistor select for 33"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL33_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL34` writer - Resistor select for 34"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL34_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL35` writer - Resistor select for 35"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL35_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL36` writer - Resistor select for 36"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL36_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL37` writer - Resistor select for 37"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL37_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL38` writer - Resistor select for 38"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL38_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL39` writer - Resistor select for 39"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL39_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL40` writer - Resistor select for 40"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL40_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL41` writer - Resistor select for 41"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL41_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL42` writer - Resistor select for 42"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL42_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL43` writer - Resistor select for 43"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL43_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL44` writer - Resistor select for 44"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL44_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL45` writer - Resistor select for 45"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL45_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL46` writer - Resistor select for 46"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL46_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL47` writer - Resistor select for 47"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL47_W;
        impl R {
            #[doc = "Bits 0:1 - Resistor select for 32"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl32(&self) -> GPIO_PUP_PDN_CNTRL32_R {
                GPIO_PUP_PDN_CNTRL32_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Resistor select for 33"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl33(&self) -> GPIO_PUP_PDN_CNTRL33_R {
                GPIO_PUP_PDN_CNTRL33_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Resistor select for 34"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl34(&self) -> GPIO_PUP_PDN_CNTRL34_R {
                GPIO_PUP_PDN_CNTRL34_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Resistor select for 35"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl35(&self) -> GPIO_PUP_PDN_CNTRL35_R {
                GPIO_PUP_PDN_CNTRL35_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Resistor select for 36"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl36(&self) -> GPIO_PUP_PDN_CNTRL36_R {
                GPIO_PUP_PDN_CNTRL36_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Resistor select for 37"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl37(&self) -> GPIO_PUP_PDN_CNTRL37_R {
                GPIO_PUP_PDN_CNTRL37_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Resistor select for 38"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl38(&self) -> GPIO_PUP_PDN_CNTRL38_R {
                GPIO_PUP_PDN_CNTRL38_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Resistor select for 39"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl39(&self) -> GPIO_PUP_PDN_CNTRL39_R {
                GPIO_PUP_PDN_CNTRL39_R::new(((self.bits >> 14) & 3) as u8)
            }
            #[doc = "Bits 16:17 - Resistor select for 40"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl40(&self) -> GPIO_PUP_PDN_CNTRL40_R {
                GPIO_PUP_PDN_CNTRL40_R::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bits 18:19 - Resistor select for 41"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl41(&self) -> GPIO_PUP_PDN_CNTRL41_R {
                GPIO_PUP_PDN_CNTRL41_R::new(((self.bits >> 18) & 3) as u8)
            }
            #[doc = "Bits 20:21 - Resistor select for 42"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl42(&self) -> GPIO_PUP_PDN_CNTRL42_R {
                GPIO_PUP_PDN_CNTRL42_R::new(((self.bits >> 20) & 3) as u8)
            }
            #[doc = "Bits 22:23 - Resistor select for 43"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl43(&self) -> GPIO_PUP_PDN_CNTRL43_R {
                GPIO_PUP_PDN_CNTRL43_R::new(((self.bits >> 22) & 3) as u8)
            }
            #[doc = "Bits 24:25 - Resistor select for 44"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl44(&self) -> GPIO_PUP_PDN_CNTRL44_R {
                GPIO_PUP_PDN_CNTRL44_R::new(((self.bits >> 24) & 3) as u8)
            }
            #[doc = "Bits 26:27 - Resistor select for 45"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl45(&self) -> GPIO_PUP_PDN_CNTRL45_R {
                GPIO_PUP_PDN_CNTRL45_R::new(((self.bits >> 26) & 3) as u8)
            }
            #[doc = "Bits 28:29 - Resistor select for 46"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl46(&self) -> GPIO_PUP_PDN_CNTRL46_R {
                GPIO_PUP_PDN_CNTRL46_R::new(((self.bits >> 28) & 3) as u8)
            }
            #[doc = "Bits 30:31 - Resistor select for 47"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl47(&self) -> GPIO_PUP_PDN_CNTRL47_R {
                GPIO_PUP_PDN_CNTRL47_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPIO_PUP_PDN_CNTRL_REG2")
                    .field(
                        "gpio_pup_pdn_cntrl32",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl32().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl33",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl33().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl34",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl34().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl35",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl35().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl36",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl36().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl37",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl37().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl38",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl38().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl39",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl39().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl40",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl40().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl41",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl41().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl42",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl42().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl43",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl43().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl44",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl44().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl45",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl45().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl46",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl46().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl47",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl47().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPIO_PUP_PDN_CNTRL_REG2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Resistor select for 32"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl32(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL32_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 0> {
                GPIO_PUP_PDN_CNTRL32_W::new(self)
            }
            #[doc = "Bits 2:3 - Resistor select for 33"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl33(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL33_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 2> {
                GPIO_PUP_PDN_CNTRL33_W::new(self)
            }
            #[doc = "Bits 4:5 - Resistor select for 34"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl34(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL34_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 4> {
                GPIO_PUP_PDN_CNTRL34_W::new(self)
            }
            #[doc = "Bits 6:7 - Resistor select for 35"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl35(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL35_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 6> {
                GPIO_PUP_PDN_CNTRL35_W::new(self)
            }
            #[doc = "Bits 8:9 - Resistor select for 36"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl36(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL36_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 8> {
                GPIO_PUP_PDN_CNTRL36_W::new(self)
            }
            #[doc = "Bits 10:11 - Resistor select for 37"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl37(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL37_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 10> {
                GPIO_PUP_PDN_CNTRL37_W::new(self)
            }
            #[doc = "Bits 12:13 - Resistor select for 38"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl38(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL38_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 12> {
                GPIO_PUP_PDN_CNTRL38_W::new(self)
            }
            #[doc = "Bits 14:15 - Resistor select for 39"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl39(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL39_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 14> {
                GPIO_PUP_PDN_CNTRL39_W::new(self)
            }
            #[doc = "Bits 16:17 - Resistor select for 40"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl40(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL40_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 16> {
                GPIO_PUP_PDN_CNTRL40_W::new(self)
            }
            #[doc = "Bits 18:19 - Resistor select for 41"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl41(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL41_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 18> {
                GPIO_PUP_PDN_CNTRL41_W::new(self)
            }
            #[doc = "Bits 20:21 - Resistor select for 42"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl42(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL42_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 20> {
                GPIO_PUP_PDN_CNTRL42_W::new(self)
            }
            #[doc = "Bits 22:23 - Resistor select for 43"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl43(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL43_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 22> {
                GPIO_PUP_PDN_CNTRL43_W::new(self)
            }
            #[doc = "Bits 24:25 - Resistor select for 44"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl44(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL44_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 24> {
                GPIO_PUP_PDN_CNTRL44_W::new(self)
            }
            #[doc = "Bits 26:27 - Resistor select for 45"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl45(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL45_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 26> {
                GPIO_PUP_PDN_CNTRL45_W::new(self)
            }
            #[doc = "Bits 28:29 - Resistor select for 46"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl46(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL46_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 28> {
                GPIO_PUP_PDN_CNTRL46_W::new(self)
            }
            #[doc = "Bits 30:31 - Resistor select for 47"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl47(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL47_W<GPIO_PUP_PDN_CNTRL_REG2_SPEC, 30> {
                GPIO_PUP_PDN_CNTRL47_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pull-up / Pull-down Register 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpio_pup_pdn_cntrl_reg2::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpio_pup_pdn_cntrl_reg2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPIO_PUP_PDN_CNTRL_REG2_SPEC;
        impl crate::RegisterSpec for GPIO_PUP_PDN_CNTRL_REG2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpio_pup_pdn_cntrl_reg2::R`](R) reader structure"]
        impl crate::Readable for GPIO_PUP_PDN_CNTRL_REG2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpio_pup_pdn_cntrl_reg2::W`](W) writer structure"]
        impl crate::Writable for GPIO_PUP_PDN_CNTRL_REG2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
    #[doc = "GPIO_PUP_PDN_CNTRL_REG3 (rw) register accessor: GPIO Pull-up / Pull-down Register 3\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpio_pup_pdn_cntrl_reg3::R`].  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpio_pup_pdn_cntrl_reg3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gpio_pup_pdn_cntrl_reg3`]
module"]
    pub type GPIO_PUP_PDN_CNTRL_REG3 =
        crate::Reg<gpio_pup_pdn_cntrl_reg3::GPIO_PUP_PDN_CNTRL_REG3_SPEC>;
    #[doc = "GPIO Pull-up / Pull-down Register 3"]
    pub mod gpio_pup_pdn_cntrl_reg3 {
        #[doc = "Register `GPIO_PUP_PDN_CNTRL_REG3` reader"]
        pub type R = crate::R<GPIO_PUP_PDN_CNTRL_REG3_SPEC>;
        #[doc = "Register `GPIO_PUP_PDN_CNTRL_REG3` writer"]
        pub type W = crate::W<GPIO_PUP_PDN_CNTRL_REG3_SPEC>;
        #[doc = "Resistor select for 48"]
        pub use super::gpio_pup_pdn_cntrl_reg0::BP_PULL_A;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL48` reader - Resistor select for 48"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL48_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL49` reader - Resistor select for 49"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL49_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL50` reader - Resistor select for 50"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL50_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL51` reader - Resistor select for 51"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL51_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL52` reader - Resistor select for 52"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL52_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL53` reader - Resistor select for 53"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_R as GPIO_PUP_PDN_CNTRL53_R;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL48` writer - Resistor select for 48"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL48_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL49` writer - Resistor select for 49"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL49_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL50` writer - Resistor select for 50"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL50_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL51` writer - Resistor select for 51"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL51_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL52` writer - Resistor select for 52"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL52_W;
        #[doc = "Field `GPIO_PUP_PDN_CNTRL53` writer - Resistor select for 53"]
        pub use super::gpio_pup_pdn_cntrl_reg0::GPIO_PUP_PDN_CNTRL0_W as GPIO_PUP_PDN_CNTRL53_W;
        impl R {
            #[doc = "Bits 0:1 - Resistor select for 48"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl48(&self) -> GPIO_PUP_PDN_CNTRL48_R {
                GPIO_PUP_PDN_CNTRL48_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Resistor select for 49"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl49(&self) -> GPIO_PUP_PDN_CNTRL49_R {
                GPIO_PUP_PDN_CNTRL49_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Resistor select for 50"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl50(&self) -> GPIO_PUP_PDN_CNTRL50_R {
                GPIO_PUP_PDN_CNTRL50_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Resistor select for 51"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl51(&self) -> GPIO_PUP_PDN_CNTRL51_R {
                GPIO_PUP_PDN_CNTRL51_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Resistor select for 52"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl52(&self) -> GPIO_PUP_PDN_CNTRL52_R {
                GPIO_PUP_PDN_CNTRL52_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Resistor select for 53"]
            #[inline(always)]
            pub fn gpio_pup_pdn_cntrl53(&self) -> GPIO_PUP_PDN_CNTRL53_R {
                GPIO_PUP_PDN_CNTRL53_R::new(((self.bits >> 10) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPIO_PUP_PDN_CNTRL_REG3")
                    .field(
                        "gpio_pup_pdn_cntrl48",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl48().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl49",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl49().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl50",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl50().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl51",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl51().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl52",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl52().bits()),
                    )
                    .field(
                        "gpio_pup_pdn_cntrl53",
                        &format_args!("{}", self.gpio_pup_pdn_cntrl53().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GPIO_PUP_PDN_CNTRL_REG3_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Resistor select for 48"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl48(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL48_W<GPIO_PUP_PDN_CNTRL_REG3_SPEC, 0> {
                GPIO_PUP_PDN_CNTRL48_W::new(self)
            }
            #[doc = "Bits 2:3 - Resistor select for 49"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl49(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL49_W<GPIO_PUP_PDN_CNTRL_REG3_SPEC, 2> {
                GPIO_PUP_PDN_CNTRL49_W::new(self)
            }
            #[doc = "Bits 4:5 - Resistor select for 50"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl50(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL50_W<GPIO_PUP_PDN_CNTRL_REG3_SPEC, 4> {
                GPIO_PUP_PDN_CNTRL50_W::new(self)
            }
            #[doc = "Bits 6:7 - Resistor select for 51"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl51(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL51_W<GPIO_PUP_PDN_CNTRL_REG3_SPEC, 6> {
                GPIO_PUP_PDN_CNTRL51_W::new(self)
            }
            #[doc = "Bits 8:9 - Resistor select for 52"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl52(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL52_W<GPIO_PUP_PDN_CNTRL_REG3_SPEC, 8> {
                GPIO_PUP_PDN_CNTRL52_W::new(self)
            }
            #[doc = "Bits 10:11 - Resistor select for 53"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_pup_pdn_cntrl53(
                &mut self,
            ) -> GPIO_PUP_PDN_CNTRL53_W<GPIO_PUP_PDN_CNTRL_REG3_SPEC, 10> {
                GPIO_PUP_PDN_CNTRL53_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "GPIO Pull-up / Pull-down Register 3\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gpio_pup_pdn_cntrl_reg3::R`](R).  You can [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpio_pup_pdn_cntrl_reg3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GPIO_PUP_PDN_CNTRL_REG3_SPEC;
        impl crate::RegisterSpec for GPIO_PUP_PDN_CNTRL_REG3_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpio_pup_pdn_cntrl_reg3::R`](R) reader structure"]
        impl crate::Readable for GPIO_PUP_PDN_CNTRL_REG3_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gpio_pup_pdn_cntrl_reg3::W`](W) writer structure"]
        impl crate::Writable for GPIO_PUP_PDN_CNTRL_REG3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
    }
}
#[doc = "Broadcom System Timer"]
pub struct SYSTMR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTMR {}
impl SYSTMR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const systmr::RegisterBlock = 0x2000_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const systmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SYSTMR {
    type Target = systmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTMR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTMR").finish()
    }
}
#[doc = "Broadcom System Timer"]
pub mod systmr {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control / Status"]
        pub cs: CS,
        #[doc = "0x04 - Lower 32 bits for the free running counter"]
        pub clo: CLO,
        #[doc = "0x08 - Higher 32 bits for the free running counter"]
        pub chi: CHI,
        #[doc = "0x0c - Compare channel 0"]
        pub c0: C0,
        #[doc = "0x10 - Compare channel 1"]
        pub c1: C1,
        #[doc = "0x14 - Compare channel 2"]
        pub c2: C2,
        #[doc = "0x18 - Compare channel 3"]
        pub c3: C3,
    }
    #[doc = "CS (rw) register accessor: Control / Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cs::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cs::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cs`]
module"]
    pub type CS = crate::Reg<cs::CS_SPEC>;
    #[doc = "Control / Status"]
    pub mod cs {
        #[doc = "Register `CS` reader"]
        pub type R = crate::R<CS_SPEC>;
        #[doc = "Register `CS` writer"]
        pub type W = crate::W<CS_SPEC>;
        #[doc = "Field `M0` reader - System timer match 0"]
        pub type M0_R = crate::BitReader;
        #[doc = "Field `M0` writer - System timer match 0"]
        pub type M0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `M1` reader - System timer match 1"]
        pub type M1_R = crate::BitReader;
        #[doc = "Field `M1` writer - System timer match 1"]
        pub type M1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `M2` reader - System timer match 2"]
        pub type M2_R = crate::BitReader;
        #[doc = "Field `M2` writer - System timer match 2"]
        pub type M2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `M3` reader - System timer match 3"]
        pub type M3_R = crate::BitReader;
        #[doc = "Field `M3` writer - System timer match 3"]
        pub type M3_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - System timer match 0"]
            #[inline(always)]
            pub fn m0(&self) -> M0_R {
                M0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - System timer match 1"]
            #[inline(always)]
            pub fn m1(&self) -> M1_R {
                M1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - System timer match 2"]
            #[inline(always)]
            pub fn m2(&self) -> M2_R {
                M2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - System timer match 3"]
            #[inline(always)]
            pub fn m3(&self) -> M3_R {
                M3_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CS")
                    .field("m3", &format_args!("{}", self.m3().bit()))
                    .field("m2", &format_args!("{}", self.m2().bit()))
                    .field("m1", &format_args!("{}", self.m1().bit()))
                    .field("m0", &format_args!("{}", self.m0().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - System timer match 0"]
            #[inline(always)]
            #[must_use]
            pub fn m0(&mut self) -> M0_W<CS_SPEC, 0> {
                M0_W::new(self)
            }
            #[doc = "Bit 1 - System timer match 1"]
            #[inline(always)]
            #[must_use]
            pub fn m1(&mut self) -> M1_W<CS_SPEC, 1> {
                M1_W::new(self)
            }
            #[doc = "Bit 2 - System timer match 2"]
            #[inline(always)]
            #[must_use]
            pub fn m2(&mut self) -> M2_W<CS_SPEC, 2> {
                M2_W::new(self)
            }
            #[doc = "Bit 3 - System timer match 3"]
            #[inline(always)]
            #[must_use]
            pub fn m3(&mut self) -> M3_W<CS_SPEC, 3> {
                M3_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control / Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cs::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cs::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CS_SPEC;
        impl crate::RegisterSpec for CS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cs::R`](R) reader structure"]
        impl crate::Readable for CS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cs::W`](W) writer structure"]
        impl crate::Writable for CS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0f;
        }
        #[doc = "`reset()` method sets CS to value 0"]
        impl crate::Resettable for CS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CLO (r) register accessor: Lower 32 bits for the free running counter\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`clo::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clo`]
module"]
    pub type CLO = crate::Reg<clo::CLO_SPEC>;
    #[doc = "Lower 32 bits for the free running counter"]
    pub mod clo {
        #[doc = "Register `CLO` reader"]
        pub type R = crate::R<CLO_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CLO_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Lower 32 bits for the free running counter\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`clo::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CLO_SPEC;
        impl crate::RegisterSpec for CLO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clo::R`](R) reader structure"]
        impl crate::Readable for CLO_SPEC {}
        #[doc = "`reset()` method sets CLO to value 0"]
        impl crate::Resettable for CLO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CHI (r) register accessor: Higher 32 bits for the free running counter\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`chi::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chi`]
module"]
    pub type CHI = crate::Reg<chi::CHI_SPEC>;
    #[doc = "Higher 32 bits for the free running counter"]
    pub mod chi {
        #[doc = "Register `CHI` reader"]
        pub type R = crate::R<CHI_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CHI_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Higher 32 bits for the free running counter\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`chi::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CHI_SPEC;
        impl crate::RegisterSpec for CHI_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`chi::R`](R) reader structure"]
        impl crate::Readable for CHI_SPEC {}
        #[doc = "`reset()` method sets CHI to value 0"]
        impl crate::Resettable for CHI_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "C0 (rw) register accessor: Compare channel 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c0`]
module"]
    pub type C0 = crate::Reg<c0::C0_SPEC>;
    #[doc = "Compare channel 0"]
    pub mod c0 {
        #[doc = "Register `C0` reader"]
        pub type R = crate::R<C0_SPEC>;
        #[doc = "Register `C0` writer"]
        pub type W = crate::W<C0_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<C0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Compare channel 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct C0_SPEC;
        impl crate::RegisterSpec for C0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`c0::R`](R) reader structure"]
        impl crate::Readable for C0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`c0::W`](W) writer structure"]
        impl crate::Writable for C0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets C0 to value 0"]
        impl crate::Resettable for C0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "C1 (rw) register accessor: Compare channel 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1`]
module"]
    pub type C1 = crate::Reg<c1::C1_SPEC>;
    #[doc = "Compare channel 1"]
    pub mod c1 {
        #[doc = "Register `C1` reader"]
        pub type R = crate::R<C1_SPEC>;
        #[doc = "Register `C1` writer"]
        pub type W = crate::W<C1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<C1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Compare channel 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct C1_SPEC;
        impl crate::RegisterSpec for C1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`c1::R`](R) reader structure"]
        impl crate::Readable for C1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`c1::W`](W) writer structure"]
        impl crate::Writable for C1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets C1 to value 0"]
        impl crate::Resettable for C1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "C2 (rw) register accessor: Compare channel 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2`]
module"]
    pub type C2 = crate::Reg<c2::C2_SPEC>;
    #[doc = "Compare channel 2"]
    pub mod c2 {
        #[doc = "Register `C2` reader"]
        pub type R = crate::R<C2_SPEC>;
        #[doc = "Register `C2` writer"]
        pub type W = crate::W<C2_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<C2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Compare channel 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct C2_SPEC;
        impl crate::RegisterSpec for C2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`c2::R`](R) reader structure"]
        impl crate::Readable for C2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`c2::W`](W) writer structure"]
        impl crate::Writable for C2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets C2 to value 0"]
        impl crate::Resettable for C2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "C3 (rw) register accessor: Compare channel 3\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c3`]
module"]
    pub type C3 = crate::Reg<c3::C3_SPEC>;
    #[doc = "Compare channel 3"]
    pub mod c3 {
        #[doc = "Register `C3` reader"]
        pub type R = crate::R<C3_SPEC>;
        #[doc = "Register `C3` writer"]
        pub type W = crate::W<C3_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<C3_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Compare channel 3\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct C3_SPEC;
        impl crate::RegisterSpec for C3_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`c3::R`](R) reader structure"]
        impl crate::Readable for C3_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`c3::W`](W) writer structure"]
        impl crate::Writable for C3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets C3 to value 0"]
        impl crate::Resettable for C3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "ARM Prime Cell PL011"]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x2020_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "ARM Prime Cell PL011"]
pub mod uart0 {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Data Register"]
        pub dr: DR,
        _reserved_1_ecr: [u8; 0x04],
        _reserved2: [u8; 0x10],
        #[doc = "0x18 - Flag Register"]
        pub fr: FR,
        _reserved3: [u8; 0x08],
        #[doc = "0x24 - Integer Baud Rate Register"]
        pub ibrd: IBRD,
        #[doc = "0x28 - Fractional Baud Rate Register"]
        pub fbrd: FBRD,
        #[doc = "0x2c - Line Control Register"]
        pub lcr_h: LCR_H,
        #[doc = "0x30 - Control Register"]
        pub cr: CR,
        #[doc = "0x34 - Interrupt FIFO Level Select Register"]
        pub ifls: IFLS,
        #[doc = "0x38 - Interrupt Mask set_Clear Register"]
        pub imsc: IMSC,
        #[doc = "0x3c - Raw Interrupt Status Register"]
        pub ris: RIS,
        #[doc = "0x40 - Masked Interrupt Status Register"]
        pub mis: MIS,
        #[doc = "0x44 - Interrupt Clear Register"]
        pub icr: ICR,
        #[doc = "0x48 - DMA Control Register"]
        pub dmacr: DMACR,
    }
    impl RegisterBlock {
        #[doc = "0x04 - Error Clear Register"]
        #[inline(always)]
        pub const fn ecr(&self) -> &ECR {
            unsafe { &*(self as *const Self).cast::<u8>().add(4usize).cast() }
        }
        #[doc = "0x04 - Receive Status Register"]
        #[inline(always)]
        pub const fn rsr(&self) -> &RSR {
            unsafe { &*(self as *const Self).cast::<u8>().add(4usize).cast() }
        }
    }
    #[doc = "DR (rw) register accessor: Data Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`]
module"]
    pub type DR = crate::Reg<dr::DR_SPEC>;
    #[doc = "Data Register"]
    pub mod dr {
        #[doc = "Register `DR` reader"]
        pub type R = crate::R<DR_SPEC>;
        #[doc = "Register `DR` writer"]
        pub type W = crate::W<DR_SPEC>;
        #[doc = "Field `DATA` reader - DATA"]
        pub type DATA_R = crate::FieldReader;
        #[doc = "Field `DATA` writer - DATA"]
        pub type DATA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `FE` reader - FE"]
        pub type FE_R = crate::BitReader;
        #[doc = "Field `FE` writer - FE"]
        pub type FE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PE` reader - PE"]
        pub type PE_R = crate::BitReader;
        #[doc = "Field `PE` writer - PE"]
        pub type PE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BE` reader - BE"]
        pub type BE_R = crate::BitReader;
        #[doc = "Field `BE` writer - BE"]
        pub type BE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OE` reader - OE"]
        pub type OE_R = crate::BitReader;
        #[doc = "Field `OE` writer - OE"]
        pub type OE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bits 0:7 - DATA"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 8 - FE"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - PE"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - BE"]
            #[inline(always)]
            pub fn be(&self) -> BE_R {
                BE_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - OE"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DR")
                    .field("data", &format_args!("{}", self.data().bits()))
                    .field("fe", &format_args!("{}", self.fe().bit()))
                    .field("pe", &format_args!("{}", self.pe().bit()))
                    .field("be", &format_args!("{}", self.be().bit()))
                    .field("oe", &format_args!("{}", self.oe().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DATA"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<DR_SPEC, 0> {
                DATA_W::new(self)
            }
            #[doc = "Bit 8 - FE"]
            #[inline(always)]
            #[must_use]
            pub fn fe(&mut self) -> FE_W<DR_SPEC, 8> {
                FE_W::new(self)
            }
            #[doc = "Bit 9 - PE"]
            #[inline(always)]
            #[must_use]
            pub fn pe(&mut self) -> PE_W<DR_SPEC, 9> {
                PE_W::new(self)
            }
            #[doc = "Bit 10 - BE"]
            #[inline(always)]
            #[must_use]
            pub fn be(&mut self) -> BE_W<DR_SPEC, 10> {
                BE_W::new(self)
            }
            #[doc = "Bit 11 - OE"]
            #[inline(always)]
            #[must_use]
            pub fn oe(&mut self) -> OE_W<DR_SPEC, 11> {
                OE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Data Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dr::R`](R) reader structure"]
        impl crate::Readable for DR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"]
        impl crate::Writable for DR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DR to value 0"]
        impl crate::Resettable for DR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RSR (r) register accessor: Receive Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rsr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rsr`]
module"]
    pub type RSR = crate::Reg<rsr::RSR_SPEC>;
    #[doc = "Receive Status Register"]
    pub mod rsr {
        #[doc = "Register `RSR` reader"]
        pub type R = crate::R<RSR_SPEC>;
        #[doc = "Field `FE` reader - FE"]
        pub type FE_R = crate::BitReader;
        #[doc = "Field `PE` reader - PE"]
        pub type PE_R = crate::BitReader;
        #[doc = "Field `BE` reader - BE"]
        pub type BE_R = crate::BitReader;
        #[doc = "Field `OE` reader - OE"]
        pub type OE_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - FE"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - PE"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - BE"]
            #[inline(always)]
            pub fn be(&self) -> BE_R {
                BE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - OE"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RSR")
                    .field("fe", &format_args!("{}", self.fe().bit()))
                    .field("pe", &format_args!("{}", self.pe().bit()))
                    .field("be", &format_args!("{}", self.be().bit()))
                    .field("oe", &format_args!("{}", self.oe().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RSR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Receive Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rsr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RSR_SPEC;
        impl crate::RegisterSpec for RSR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rsr::R`](R) reader structure"]
        impl crate::Readable for RSR_SPEC {}
        #[doc = "`reset()` method sets RSR to value 0"]
        impl crate::Resettable for RSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ECR (w) register accessor: Error Clear Register\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ecr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ecr`]
module"]
    pub type ECR = crate::Reg<ecr::ECR_SPEC>;
    #[doc = "Error Clear Register"]
    pub mod ecr {
        #[doc = "Register `ECR` writer"]
        pub type W = crate::W<ECR_SPEC>;
        #[doc = "Field `FE` writer - FE"]
        pub type FE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PE` writer - PE"]
        pub type PE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BE` writer - BE"]
        pub type BE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OE` writer - OE"]
        pub type OE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl core::fmt::Debug for crate::generic::Reg<ECR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {
            #[doc = "Bit 0 - FE"]
            #[inline(always)]
            #[must_use]
            pub fn fe(&mut self) -> FE_W<ECR_SPEC, 0> {
                FE_W::new(self)
            }
            #[doc = "Bit 1 - PE"]
            #[inline(always)]
            #[must_use]
            pub fn pe(&mut self) -> PE_W<ECR_SPEC, 1> {
                PE_W::new(self)
            }
            #[doc = "Bit 2 - BE"]
            #[inline(always)]
            #[must_use]
            pub fn be(&mut self) -> BE_W<ECR_SPEC, 2> {
                BE_W::new(self)
            }
            #[doc = "Bit 3 - OE"]
            #[inline(always)]
            #[must_use]
            pub fn oe(&mut self) -> OE_W<ECR_SPEC, 3> {
                OE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Error Clear Register\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ecr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ECR_SPEC;
        impl crate::RegisterSpec for ECR_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`ecr::W`](W) writer structure"]
        impl crate::Writable for ECR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ECR to value 0"]
        impl crate::Resettable for ECR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "FR (rw) register accessor: Flag Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fr`]
module"]
    pub type FR = crate::Reg<fr::FR_SPEC>;
    #[doc = "Flag Register"]
    pub mod fr {
        #[doc = "Register `FR` reader"]
        pub type R = crate::R<FR_SPEC>;
        #[doc = "Register `FR` writer"]
        pub type W = crate::W<FR_SPEC>;
        #[doc = "Field `CTS` reader - CTS"]
        pub type CTS_R = crate::BitReader;
        #[doc = "Field `CTS` writer - CTS"]
        pub type CTS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DSR` reader - DSR"]
        pub type DSR_R = crate::BitReader;
        #[doc = "Field `DSR` writer - DSR"]
        pub type DSR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DCD` reader - DCD"]
        pub type DCD_R = crate::BitReader;
        #[doc = "Field `DCD` writer - DCD"]
        pub type DCD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BUSY` reader - BUSY"]
        pub type BUSY_R = crate::BitReader;
        #[doc = "Field `BUSY` writer - BUSY"]
        pub type BUSY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXFE` reader - RXFE"]
        pub type RXFE_R = crate::BitReader;
        #[doc = "Field `RXFE` writer - RXFE"]
        pub type RXFE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXFF` reader - TXFF"]
        pub type TXFF_R = crate::BitReader;
        #[doc = "Field `TXFF` writer - TXFF"]
        pub type TXFF_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXFF` reader - RXFF"]
        pub type RXFF_R = crate::BitReader;
        #[doc = "Field `RXFF` writer - RXFF"]
        pub type RXFF_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXFE` reader - TXFE"]
        pub type TXFE_R = crate::BitReader;
        #[doc = "Field `TXFE` writer - TXFE"]
        pub type TXFE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RI` reader - RI"]
        pub type RI_R = crate::BitReader;
        #[doc = "Field `RI` writer - RI"]
        pub type RI_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - CTS"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - DSR"]
            #[inline(always)]
            pub fn dsr(&self) -> DSR_R {
                DSR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - DCD"]
            #[inline(always)]
            pub fn dcd(&self) -> DCD_R {
                DCD_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - BUSY"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RXFE"]
            #[inline(always)]
            pub fn rxfe(&self) -> RXFE_R {
                RXFE_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TXFF"]
            #[inline(always)]
            pub fn txff(&self) -> TXFF_R {
                TXFF_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RXFF"]
            #[inline(always)]
            pub fn rxff(&self) -> RXFF_R {
                RXFF_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - TXFE"]
            #[inline(always)]
            pub fn txfe(&self) -> TXFE_R {
                TXFE_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - RI"]
            #[inline(always)]
            pub fn ri(&self) -> RI_R {
                RI_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FR")
                    .field("cts", &format_args!("{}", self.cts().bit()))
                    .field("dsr", &format_args!("{}", self.dsr().bit()))
                    .field("dcd", &format_args!("{}", self.dcd().bit()))
                    .field("busy", &format_args!("{}", self.busy().bit()))
                    .field("rxfe", &format_args!("{}", self.rxfe().bit()))
                    .field("txff", &format_args!("{}", self.txff().bit()))
                    .field("rxff", &format_args!("{}", self.rxff().bit()))
                    .field("txfe", &format_args!("{}", self.txfe().bit()))
                    .field("ri", &format_args!("{}", self.ri().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - CTS"]
            #[inline(always)]
            #[must_use]
            pub fn cts(&mut self) -> CTS_W<FR_SPEC, 0> {
                CTS_W::new(self)
            }
            #[doc = "Bit 1 - DSR"]
            #[inline(always)]
            #[must_use]
            pub fn dsr(&mut self) -> DSR_W<FR_SPEC, 1> {
                DSR_W::new(self)
            }
            #[doc = "Bit 2 - DCD"]
            #[inline(always)]
            #[must_use]
            pub fn dcd(&mut self) -> DCD_W<FR_SPEC, 2> {
                DCD_W::new(self)
            }
            #[doc = "Bit 3 - BUSY"]
            #[inline(always)]
            #[must_use]
            pub fn busy(&mut self) -> BUSY_W<FR_SPEC, 3> {
                BUSY_W::new(self)
            }
            #[doc = "Bit 4 - RXFE"]
            #[inline(always)]
            #[must_use]
            pub fn rxfe(&mut self) -> RXFE_W<FR_SPEC, 4> {
                RXFE_W::new(self)
            }
            #[doc = "Bit 5 - TXFF"]
            #[inline(always)]
            #[must_use]
            pub fn txff(&mut self) -> TXFF_W<FR_SPEC, 5> {
                TXFF_W::new(self)
            }
            #[doc = "Bit 6 - RXFF"]
            #[inline(always)]
            #[must_use]
            pub fn rxff(&mut self) -> RXFF_W<FR_SPEC, 6> {
                RXFF_W::new(self)
            }
            #[doc = "Bit 7 - TXFE"]
            #[inline(always)]
            #[must_use]
            pub fn txfe(&mut self) -> TXFE_W<FR_SPEC, 7> {
                TXFE_W::new(self)
            }
            #[doc = "Bit 8 - RI"]
            #[inline(always)]
            #[must_use]
            pub fn ri(&mut self) -> RI_W<FR_SPEC, 8> {
                RI_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Flag Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FR_SPEC;
        impl crate::RegisterSpec for FR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fr::R`](R) reader structure"]
        impl crate::Readable for FR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`fr::W`](W) writer structure"]
        impl crate::Writable for FR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets FR to value 0"]
        impl crate::Resettable for FR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IBRD (rw) register accessor: Integer Baud Rate Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ibrd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ibrd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ibrd`]
module"]
    pub type IBRD = crate::Reg<ibrd::IBRD_SPEC>;
    #[doc = "Integer Baud Rate Register"]
    pub mod ibrd {
        #[doc = "Register `IBRD` reader"]
        pub type R = crate::R<IBRD_SPEC>;
        #[doc = "Register `IBRD` writer"]
        pub type W = crate::W<IBRD_SPEC>;
        #[doc = "Field `BAUDDIVINT` reader - BAUDDIVINT"]
        pub type BAUDDIVINT_R = crate::FieldReader<u16>;
        #[doc = "Field `BAUDDIVINT` writer - BAUDDIVINT"]
        pub type BAUDDIVINT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - BAUDDIVINT"]
            #[inline(always)]
            pub fn bauddivint(&self) -> BAUDDIVINT_R {
                BAUDDIVINT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IBRD")
                    .field("bauddivint", &format_args!("{}", self.bauddivint().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IBRD_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - BAUDDIVINT"]
            #[inline(always)]
            #[must_use]
            pub fn bauddivint(&mut self) -> BAUDDIVINT_W<IBRD_SPEC, 0> {
                BAUDDIVINT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Integer Baud Rate Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ibrd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ibrd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IBRD_SPEC;
        impl crate::RegisterSpec for IBRD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ibrd::R`](R) reader structure"]
        impl crate::Readable for IBRD_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ibrd::W`](W) writer structure"]
        impl crate::Writable for IBRD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IBRD to value 0"]
        impl crate::Resettable for IBRD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "FBRD (rw) register accessor: Fractional Baud Rate Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fbrd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fbrd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fbrd`]
module"]
    pub type FBRD = crate::Reg<fbrd::FBRD_SPEC>;
    #[doc = "Fractional Baud Rate Register"]
    pub mod fbrd {
        #[doc = "Register `FBRD` reader"]
        pub type R = crate::R<FBRD_SPEC>;
        #[doc = "Register `FBRD` writer"]
        pub type W = crate::W<FBRD_SPEC>;
        #[doc = "Field `BAUDDIVFRAC` reader - BAUDDIVFRAC"]
        pub type BAUDDIVFRAC_R = crate::FieldReader;
        #[doc = "Field `BAUDDIVFRAC` writer - BAUDDIVFRAC"]
        pub type BAUDDIVFRAC_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 6, O>;
        impl R {
            #[doc = "Bits 0:5 - BAUDDIVFRAC"]
            #[inline(always)]
            pub fn bauddivfrac(&self) -> BAUDDIVFRAC_R {
                BAUDDIVFRAC_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FBRD")
                    .field(
                        "bauddivfrac",
                        &format_args!("{}", self.bauddivfrac().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FBRD_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:5 - BAUDDIVFRAC"]
            #[inline(always)]
            #[must_use]
            pub fn bauddivfrac(&mut self) -> BAUDDIVFRAC_W<FBRD_SPEC, 0> {
                BAUDDIVFRAC_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Fractional Baud Rate Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fbrd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fbrd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FBRD_SPEC;
        impl crate::RegisterSpec for FBRD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fbrd::R`](R) reader structure"]
        impl crate::Readable for FBRD_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`fbrd::W`](W) writer structure"]
        impl crate::Writable for FBRD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets FBRD to value 0"]
        impl crate::Resettable for FBRD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "LCR_H (rw) register accessor: Line Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lcr_h::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr_h::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr_h`]
module"]
    pub type LCR_H = crate::Reg<lcr_h::LCR_H_SPEC>;
    #[doc = "Line Control Register"]
    pub mod lcr_h {
        #[doc = "Register `LCR_H` reader"]
        pub type R = crate::R<LCR_H_SPEC>;
        #[doc = "Register `LCR_H` writer"]
        pub type W = crate::W<LCR_H_SPEC>;
        #[doc = "Field `BRK` reader - BRK"]
        pub type BRK_R = crate::BitReader;
        #[doc = "Field `BRK` writer - BRK"]
        pub type BRK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PEN` reader - PEN"]
        pub type PEN_R = crate::BitReader;
        #[doc = "Field `PEN` writer - PEN"]
        pub type PEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EPS` reader - EPS"]
        pub type EPS_R = crate::BitReader;
        #[doc = "Field `EPS` writer - EPS"]
        pub type EPS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `STP2` reader - STP2"]
        pub type STP2_R = crate::BitReader;
        #[doc = "Field `STP2` writer - STP2"]
        pub type STP2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEN` reader - FEN"]
        pub type FEN_R = crate::BitReader;
        #[doc = "Field `FEN` writer - FEN"]
        pub type FEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WLEN` reader - WLEN"]
        pub type WLEN_R = crate::FieldReader;
        #[doc = "Field `WLEN` writer - WLEN"]
        pub type WLEN_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        #[doc = "Field `SPS` reader - SPS"]
        pub type SPS_R = crate::BitReader;
        #[doc = "Field `SPS` writer - SPS"]
        pub type SPS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - BRK"]
            #[inline(always)]
            pub fn brk(&self) -> BRK_R {
                BRK_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - PEN"]
            #[inline(always)]
            pub fn pen(&self) -> PEN_R {
                PEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - EPS"]
            #[inline(always)]
            pub fn eps(&self) -> EPS_R {
                EPS_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - STP2"]
            #[inline(always)]
            pub fn stp2(&self) -> STP2_R {
                STP2_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - FEN"]
            #[inline(always)]
            pub fn fen(&self) -> FEN_R {
                FEN_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:6 - WLEN"]
            #[inline(always)]
            pub fn wlen(&self) -> WLEN_R {
                WLEN_R::new(((self.bits >> 5) & 3) as u8)
            }
            #[doc = "Bit 7 - SPS"]
            #[inline(always)]
            pub fn sps(&self) -> SPS_R {
                SPS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LCR_H")
                    .field("brk", &format_args!("{}", self.brk().bit()))
                    .field("pen", &format_args!("{}", self.pen().bit()))
                    .field("eps", &format_args!("{}", self.eps().bit()))
                    .field("stp2", &format_args!("{}", self.stp2().bit()))
                    .field("fen", &format_args!("{}", self.fen().bit()))
                    .field("wlen", &format_args!("{}", self.wlen().bits()))
                    .field("sps", &format_args!("{}", self.sps().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<LCR_H_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - BRK"]
            #[inline(always)]
            #[must_use]
            pub fn brk(&mut self) -> BRK_W<LCR_H_SPEC, 0> {
                BRK_W::new(self)
            }
            #[doc = "Bit 1 - PEN"]
            #[inline(always)]
            #[must_use]
            pub fn pen(&mut self) -> PEN_W<LCR_H_SPEC, 1> {
                PEN_W::new(self)
            }
            #[doc = "Bit 2 - EPS"]
            #[inline(always)]
            #[must_use]
            pub fn eps(&mut self) -> EPS_W<LCR_H_SPEC, 2> {
                EPS_W::new(self)
            }
            #[doc = "Bit 3 - STP2"]
            #[inline(always)]
            #[must_use]
            pub fn stp2(&mut self) -> STP2_W<LCR_H_SPEC, 3> {
                STP2_W::new(self)
            }
            #[doc = "Bit 4 - FEN"]
            #[inline(always)]
            #[must_use]
            pub fn fen(&mut self) -> FEN_W<LCR_H_SPEC, 4> {
                FEN_W::new(self)
            }
            #[doc = "Bits 5:6 - WLEN"]
            #[inline(always)]
            #[must_use]
            pub fn wlen(&mut self) -> WLEN_W<LCR_H_SPEC, 5> {
                WLEN_W::new(self)
            }
            #[doc = "Bit 7 - SPS"]
            #[inline(always)]
            #[must_use]
            pub fn sps(&mut self) -> SPS_W<LCR_H_SPEC, 7> {
                SPS_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Line Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lcr_h::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr_h::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LCR_H_SPEC;
        impl crate::RegisterSpec for LCR_H_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lcr_h::R`](R) reader structure"]
        impl crate::Readable for LCR_H_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`lcr_h::W`](W) writer structure"]
        impl crate::Writable for LCR_H_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets LCR_H to value 0"]
        impl crate::Resettable for LCR_H_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CR (rw) register accessor: Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`]
module"]
    pub type CR = crate::Reg<cr::CR_SPEC>;
    #[doc = "Control Register"]
    pub mod cr {
        #[doc = "Register `CR` reader"]
        pub type R = crate::R<CR_SPEC>;
        #[doc = "Register `CR` writer"]
        pub type W = crate::W<CR_SPEC>;
        #[doc = "Field `UARTEN` reader - UARTEN"]
        pub type UARTEN_R = crate::BitReader;
        #[doc = "Field `UARTEN` writer - UARTEN"]
        pub type UARTEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SIREN` reader - SIREN"]
        pub type SIREN_R = crate::BitReader;
        #[doc = "Field `SIREN` writer - SIREN"]
        pub type SIREN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SIRLP` reader - SIRLP"]
        pub type SIRLP_R = crate::BitReader;
        #[doc = "Field `SIRLP` writer - SIRLP"]
        pub type SIRLP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXE` reader - TXE"]
        pub type TXE_R = crate::BitReader;
        #[doc = "Field `TXE` writer - TXE"]
        pub type TXE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXE` reader - RXE"]
        pub type RXE_R = crate::BitReader;
        #[doc = "Field `RXE` writer - RXE"]
        pub type RXE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DTR` reader - DTR"]
        pub type DTR_R = crate::BitReader;
        #[doc = "Field `DTR` writer - DTR"]
        pub type DTR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RTS` reader - RTS"]
        pub type RTS_R = crate::BitReader;
        #[doc = "Field `RTS` writer - RTS"]
        pub type RTS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RTSEN` reader - RTSEN"]
        pub type RTSEN_R = crate::BitReader;
        #[doc = "Field `RTSEN` writer - RTSEN"]
        pub type RTSEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTSEN` reader - CTSEN"]
        pub type CTSEN_R = crate::BitReader;
        #[doc = "Field `CTSEN` writer - CTSEN"]
        pub type CTSEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - UARTEN"]
            #[inline(always)]
            pub fn uarten(&self) -> UARTEN_R {
                UARTEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - SIREN"]
            #[inline(always)]
            pub fn siren(&self) -> SIREN_R {
                SIREN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - SIRLP"]
            #[inline(always)]
            pub fn sirlp(&self) -> SIRLP_R {
                SIRLP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 8 - TXE"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - RXE"]
            #[inline(always)]
            pub fn rxe(&self) -> RXE_R {
                RXE_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - DTR"]
            #[inline(always)]
            pub fn dtr(&self) -> DTR_R {
                DTR_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - RTS"]
            #[inline(always)]
            pub fn rts(&self) -> RTS_R {
                RTS_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 14 - RTSEN"]
            #[inline(always)]
            pub fn rtsen(&self) -> RTSEN_R {
                RTSEN_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - CTSEN"]
            #[inline(always)]
            pub fn ctsen(&self) -> CTSEN_R {
                CTSEN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CR")
                    .field("uarten", &format_args!("{}", self.uarten().bit()))
                    .field("siren", &format_args!("{}", self.siren().bit()))
                    .field("sirlp", &format_args!("{}", self.sirlp().bit()))
                    .field("txe", &format_args!("{}", self.txe().bit()))
                    .field("rxe", &format_args!("{}", self.rxe().bit()))
                    .field("dtr", &format_args!("{}", self.dtr().bit()))
                    .field("rts", &format_args!("{}", self.rts().bit()))
                    .field("rtsen", &format_args!("{}", self.rtsen().bit()))
                    .field("ctsen", &format_args!("{}", self.ctsen().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - UARTEN"]
            #[inline(always)]
            #[must_use]
            pub fn uarten(&mut self) -> UARTEN_W<CR_SPEC, 0> {
                UARTEN_W::new(self)
            }
            #[doc = "Bit 1 - SIREN"]
            #[inline(always)]
            #[must_use]
            pub fn siren(&mut self) -> SIREN_W<CR_SPEC, 1> {
                SIREN_W::new(self)
            }
            #[doc = "Bit 2 - SIRLP"]
            #[inline(always)]
            #[must_use]
            pub fn sirlp(&mut self) -> SIRLP_W<CR_SPEC, 2> {
                SIRLP_W::new(self)
            }
            #[doc = "Bit 8 - TXE"]
            #[inline(always)]
            #[must_use]
            pub fn txe(&mut self) -> TXE_W<CR_SPEC, 8> {
                TXE_W::new(self)
            }
            #[doc = "Bit 9 - RXE"]
            #[inline(always)]
            #[must_use]
            pub fn rxe(&mut self) -> RXE_W<CR_SPEC, 9> {
                RXE_W::new(self)
            }
            #[doc = "Bit 10 - DTR"]
            #[inline(always)]
            #[must_use]
            pub fn dtr(&mut self) -> DTR_W<CR_SPEC, 10> {
                DTR_W::new(self)
            }
            #[doc = "Bit 11 - RTS"]
            #[inline(always)]
            #[must_use]
            pub fn rts(&mut self) -> RTS_W<CR_SPEC, 11> {
                RTS_W::new(self)
            }
            #[doc = "Bit 14 - RTSEN"]
            #[inline(always)]
            #[must_use]
            pub fn rtsen(&mut self) -> RTSEN_W<CR_SPEC, 14> {
                RTSEN_W::new(self)
            }
            #[doc = "Bit 15 - CTSEN"]
            #[inline(always)]
            #[must_use]
            pub fn ctsen(&mut self) -> CTSEN_W<CR_SPEC, 15> {
                CTSEN_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cr::R`](R) reader structure"]
        impl crate::Readable for CR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"]
        impl crate::Writable for CR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CR to value 0"]
        impl crate::Resettable for CR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IFLS (rw) register accessor: Interrupt FIFO Level Select Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ifls::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ifls::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ifls`]
module"]
    pub type IFLS = crate::Reg<ifls::IFLS_SPEC>;
    #[doc = "Interrupt FIFO Level Select Register"]
    pub mod ifls {
        #[doc = "Register `IFLS` reader"]
        pub type R = crate::R<IFLS_SPEC>;
        #[doc = "Register `IFLS` writer"]
        pub type W = crate::W<IFLS_SPEC>;
        #[doc = "Field `TXIFLSEL` reader - TXIFLSEL"]
        pub type TXIFLSEL_R = crate::FieldReader;
        #[doc = "Field `TXIFLSEL` writer - TXIFLSEL"]
        pub type TXIFLSEL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O>;
        #[doc = "Field `RXIFLSEL` reader - RXIFLSEL"]
        pub type RXIFLSEL_R = crate::FieldReader;
        #[doc = "Field `RXIFLSEL` writer - RXIFLSEL"]
        pub type RXIFLSEL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O>;
        impl R {
            #[doc = "Bits 0:2 - TXIFLSEL"]
            #[inline(always)]
            pub fn txiflsel(&self) -> TXIFLSEL_R {
                TXIFLSEL_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:5 - RXIFLSEL"]
            #[inline(always)]
            pub fn rxiflsel(&self) -> RXIFLSEL_R {
                RXIFLSEL_R::new(((self.bits >> 3) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IFLS")
                    .field("txiflsel", &format_args!("{}", self.txiflsel().bits()))
                    .field("rxiflsel", &format_args!("{}", self.rxiflsel().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IFLS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - TXIFLSEL"]
            #[inline(always)]
            #[must_use]
            pub fn txiflsel(&mut self) -> TXIFLSEL_W<IFLS_SPEC, 0> {
                TXIFLSEL_W::new(self)
            }
            #[doc = "Bits 3:5 - RXIFLSEL"]
            #[inline(always)]
            #[must_use]
            pub fn rxiflsel(&mut self) -> RXIFLSEL_W<IFLS_SPEC, 3> {
                RXIFLSEL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt FIFO Level Select Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ifls::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ifls::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IFLS_SPEC;
        impl crate::RegisterSpec for IFLS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ifls::R`](R) reader structure"]
        impl crate::Readable for IFLS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ifls::W`](W) writer structure"]
        impl crate::Writable for IFLS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IFLS to value 0"]
        impl crate::Resettable for IFLS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IMSC (rw) register accessor: Interrupt Mask set_Clear Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`imsc::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`imsc::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@imsc`]
module"]
    pub type IMSC = crate::Reg<imsc::IMSC_SPEC>;
    #[doc = "Interrupt Mask set_Clear Register"]
    pub mod imsc {
        #[doc = "Register `IMSC` reader"]
        pub type R = crate::R<IMSC_SPEC>;
        #[doc = "Register `IMSC` writer"]
        pub type W = crate::W<IMSC_SPEC>;
        #[doc = "Field `RIMIM` reader - RIMIM"]
        pub type RIMIM_R = crate::BitReader;
        #[doc = "Field `RIMIM` writer - RIMIM"]
        pub type RIMIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTSMIM` reader - CTSMIM"]
        pub type CTSMIM_R = crate::BitReader;
        #[doc = "Field `CTSMIM` writer - CTSMIM"]
        pub type CTSMIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DCDMIM` reader - DCDMIM"]
        pub type DCDMIM_R = crate::BitReader;
        #[doc = "Field `DCDMIM` writer - DCDMIM"]
        pub type DCDMIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DSRMIM` reader - DSRMIM"]
        pub type DSRMIM_R = crate::BitReader;
        #[doc = "Field `DSRMIM` writer - DSRMIM"]
        pub type DSRMIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXIM` reader - RXIM"]
        pub type RXIM_R = crate::BitReader;
        #[doc = "Field `RXIM` writer - RXIM"]
        pub type RXIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXIM` reader - TXIM"]
        pub type TXIM_R = crate::BitReader;
        #[doc = "Field `TXIM` writer - TXIM"]
        pub type TXIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RTIM` reader - RTIM"]
        pub type RTIM_R = crate::BitReader;
        #[doc = "Field `RTIM` writer - RTIM"]
        pub type RTIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEIM` reader - FEIM"]
        pub type FEIM_R = crate::BitReader;
        #[doc = "Field `FEIM` writer - FEIM"]
        pub type FEIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PEIM` reader - PEIM"]
        pub type PEIM_R = crate::BitReader;
        #[doc = "Field `PEIM` writer - PEIM"]
        pub type PEIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BEIM` reader - BEIM"]
        pub type BEIM_R = crate::BitReader;
        #[doc = "Field `BEIM` writer - BEIM"]
        pub type BEIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OEIM` reader - OEIM"]
        pub type OEIM_R = crate::BitReader;
        #[doc = "Field `OEIM` writer - OEIM"]
        pub type OEIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - RIMIM"]
            #[inline(always)]
            pub fn rimim(&self) -> RIMIM_R {
                RIMIM_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - CTSMIM"]
            #[inline(always)]
            pub fn ctsmim(&self) -> CTSMIM_R {
                CTSMIM_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - DCDMIM"]
            #[inline(always)]
            pub fn dcdmim(&self) -> DCDMIM_R {
                DCDMIM_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - DSRMIM"]
            #[inline(always)]
            pub fn dsrmim(&self) -> DSRMIM_R {
                DSRMIM_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RXIM"]
            #[inline(always)]
            pub fn rxim(&self) -> RXIM_R {
                RXIM_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TXIM"]
            #[inline(always)]
            pub fn txim(&self) -> TXIM_R {
                TXIM_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RTIM"]
            #[inline(always)]
            pub fn rtim(&self) -> RTIM_R {
                RTIM_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - FEIM"]
            #[inline(always)]
            pub fn feim(&self) -> FEIM_R {
                FEIM_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - PEIM"]
            #[inline(always)]
            pub fn peim(&self) -> PEIM_R {
                PEIM_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - BEIM"]
            #[inline(always)]
            pub fn beim(&self) -> BEIM_R {
                BEIM_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - OEIM"]
            #[inline(always)]
            pub fn oeim(&self) -> OEIM_R {
                OEIM_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IMSC")
                    .field("rimim", &format_args!("{}", self.rimim().bit()))
                    .field("ctsmim", &format_args!("{}", self.ctsmim().bit()))
                    .field("dcdmim", &format_args!("{}", self.dcdmim().bit()))
                    .field("dsrmim", &format_args!("{}", self.dsrmim().bit()))
                    .field("rxim", &format_args!("{}", self.rxim().bit()))
                    .field("txim", &format_args!("{}", self.txim().bit()))
                    .field("rtim", &format_args!("{}", self.rtim().bit()))
                    .field("feim", &format_args!("{}", self.feim().bit()))
                    .field("peim", &format_args!("{}", self.peim().bit()))
                    .field("beim", &format_args!("{}", self.beim().bit()))
                    .field("oeim", &format_args!("{}", self.oeim().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IMSC_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - RIMIM"]
            #[inline(always)]
            #[must_use]
            pub fn rimim(&mut self) -> RIMIM_W<IMSC_SPEC, 0> {
                RIMIM_W::new(self)
            }
            #[doc = "Bit 1 - CTSMIM"]
            #[inline(always)]
            #[must_use]
            pub fn ctsmim(&mut self) -> CTSMIM_W<IMSC_SPEC, 1> {
                CTSMIM_W::new(self)
            }
            #[doc = "Bit 2 - DCDMIM"]
            #[inline(always)]
            #[must_use]
            pub fn dcdmim(&mut self) -> DCDMIM_W<IMSC_SPEC, 2> {
                DCDMIM_W::new(self)
            }
            #[doc = "Bit 3 - DSRMIM"]
            #[inline(always)]
            #[must_use]
            pub fn dsrmim(&mut self) -> DSRMIM_W<IMSC_SPEC, 3> {
                DSRMIM_W::new(self)
            }
            #[doc = "Bit 4 - RXIM"]
            #[inline(always)]
            #[must_use]
            pub fn rxim(&mut self) -> RXIM_W<IMSC_SPEC, 4> {
                RXIM_W::new(self)
            }
            #[doc = "Bit 5 - TXIM"]
            #[inline(always)]
            #[must_use]
            pub fn txim(&mut self) -> TXIM_W<IMSC_SPEC, 5> {
                TXIM_W::new(self)
            }
            #[doc = "Bit 6 - RTIM"]
            #[inline(always)]
            #[must_use]
            pub fn rtim(&mut self) -> RTIM_W<IMSC_SPEC, 6> {
                RTIM_W::new(self)
            }
            #[doc = "Bit 7 - FEIM"]
            #[inline(always)]
            #[must_use]
            pub fn feim(&mut self) -> FEIM_W<IMSC_SPEC, 7> {
                FEIM_W::new(self)
            }
            #[doc = "Bit 8 - PEIM"]
            #[inline(always)]
            #[must_use]
            pub fn peim(&mut self) -> PEIM_W<IMSC_SPEC, 8> {
                PEIM_W::new(self)
            }
            #[doc = "Bit 9 - BEIM"]
            #[inline(always)]
            #[must_use]
            pub fn beim(&mut self) -> BEIM_W<IMSC_SPEC, 9> {
                BEIM_W::new(self)
            }
            #[doc = "Bit 10 - OEIM"]
            #[inline(always)]
            #[must_use]
            pub fn oeim(&mut self) -> OEIM_W<IMSC_SPEC, 10> {
                OEIM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt Mask set_Clear Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`imsc::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`imsc::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IMSC_SPEC;
        impl crate::RegisterSpec for IMSC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`imsc::R`](R) reader structure"]
        impl crate::Readable for IMSC_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`imsc::W`](W) writer structure"]
        impl crate::Writable for IMSC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IMSC to value 0"]
        impl crate::Resettable for IMSC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RIS (r) register accessor: Raw Interrupt Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ris::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ris`]
module"]
    pub type RIS = crate::Reg<ris::RIS_SPEC>;
    #[doc = "Raw Interrupt Status Register"]
    pub mod ris {
        #[doc = "Register `RIS` reader"]
        pub type R = crate::R<RIS_SPEC>;
        #[doc = "Field `RIRMIS` reader - RIRMIS"]
        pub type RIRMIS_R = crate::BitReader;
        #[doc = "Field `CTSRMIS` reader - CTSRMIS"]
        pub type CTSRMIS_R = crate::BitReader;
        #[doc = "Field `DCDRMIS` reader - DCDRMIS"]
        pub type DCDRMIS_R = crate::BitReader;
        #[doc = "Field `DSRRMIS` reader - DSRRMIS"]
        pub type DSRRMIS_R = crate::BitReader;
        #[doc = "Field `RXRIS` reader - RXRIS"]
        pub type RXRIS_R = crate::BitReader;
        #[doc = "Field `TXRIS` reader - TXRIS"]
        pub type TXRIS_R = crate::BitReader;
        #[doc = "Field `RTRIS` reader - RTRIS"]
        pub type RTRIS_R = crate::BitReader;
        #[doc = "Field `FERIS` reader - FERIS"]
        pub type FERIS_R = crate::BitReader;
        #[doc = "Field `PERIS` reader - PERIS"]
        pub type PERIS_R = crate::BitReader;
        #[doc = "Field `BERIS` reader - BERIS"]
        pub type BERIS_R = crate::BitReader;
        #[doc = "Field `OERIS` reader - OERIS"]
        pub type OERIS_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RIRMIS"]
            #[inline(always)]
            pub fn rirmis(&self) -> RIRMIS_R {
                RIRMIS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - CTSRMIS"]
            #[inline(always)]
            pub fn ctsrmis(&self) -> CTSRMIS_R {
                CTSRMIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - DCDRMIS"]
            #[inline(always)]
            pub fn dcdrmis(&self) -> DCDRMIS_R {
                DCDRMIS_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - DSRRMIS"]
            #[inline(always)]
            pub fn dsrrmis(&self) -> DSRRMIS_R {
                DSRRMIS_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RXRIS"]
            #[inline(always)]
            pub fn rxris(&self) -> RXRIS_R {
                RXRIS_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TXRIS"]
            #[inline(always)]
            pub fn txris(&self) -> TXRIS_R {
                TXRIS_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RTRIS"]
            #[inline(always)]
            pub fn rtris(&self) -> RTRIS_R {
                RTRIS_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - FERIS"]
            #[inline(always)]
            pub fn feris(&self) -> FERIS_R {
                FERIS_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - PERIS"]
            #[inline(always)]
            pub fn peris(&self) -> PERIS_R {
                PERIS_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - BERIS"]
            #[inline(always)]
            pub fn beris(&self) -> BERIS_R {
                BERIS_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - OERIS"]
            #[inline(always)]
            pub fn oeris(&self) -> OERIS_R {
                OERIS_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RIS")
                    .field("rirmis", &format_args!("{}", self.rirmis().bit()))
                    .field("ctsrmis", &format_args!("{}", self.ctsrmis().bit()))
                    .field("dcdrmis", &format_args!("{}", self.dcdrmis().bit()))
                    .field("dsrrmis", &format_args!("{}", self.dsrrmis().bit()))
                    .field("rxris", &format_args!("{}", self.rxris().bit()))
                    .field("txris", &format_args!("{}", self.txris().bit()))
                    .field("rtris", &format_args!("{}", self.rtris().bit()))
                    .field("feris", &format_args!("{}", self.feris().bit()))
                    .field("peris", &format_args!("{}", self.peris().bit()))
                    .field("beris", &format_args!("{}", self.beris().bit()))
                    .field("oeris", &format_args!("{}", self.oeris().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RIS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Raw Interrupt Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ris::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RIS_SPEC;
        impl crate::RegisterSpec for RIS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ris::R`](R) reader structure"]
        impl crate::Readable for RIS_SPEC {}
        #[doc = "`reset()` method sets RIS to value 0"]
        impl crate::Resettable for RIS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "MIS (r) register accessor: Masked Interrupt Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mis::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mis`]
module"]
    pub type MIS = crate::Reg<mis::MIS_SPEC>;
    #[doc = "Masked Interrupt Status Register"]
    pub mod mis {
        #[doc = "Register `MIS` reader"]
        pub type R = crate::R<MIS_SPEC>;
        #[doc = "Field `RIMMIS` reader - RIMMIS"]
        pub type RIMMIS_R = crate::BitReader;
        #[doc = "Field `CTSMMIS` reader - CTSMMIS"]
        pub type CTSMMIS_R = crate::BitReader;
        #[doc = "Field `DCDMMIS` reader - DCDMMIS"]
        pub type DCDMMIS_R = crate::BitReader;
        #[doc = "Field `DSRMMIS` reader - DSRMMIS"]
        pub type DSRMMIS_R = crate::BitReader;
        #[doc = "Field `RXMIS` reader - RXMIS"]
        pub type RXMIS_R = crate::BitReader;
        #[doc = "Field `TXMIS` reader - TXMIS"]
        pub type TXMIS_R = crate::BitReader;
        #[doc = "Field `RTMIS` reader - RTMIS"]
        pub type RTMIS_R = crate::BitReader;
        #[doc = "Field `FEMIS` reader - FEMIS"]
        pub type FEMIS_R = crate::BitReader;
        #[doc = "Field `PEMIS` reader - PEMIS"]
        pub type PEMIS_R = crate::BitReader;
        #[doc = "Field `BEMIS` reader - BEMIS"]
        pub type BEMIS_R = crate::BitReader;
        #[doc = "Field `OEMIS` reader - OEMIS"]
        pub type OEMIS_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RIMMIS"]
            #[inline(always)]
            pub fn rimmis(&self) -> RIMMIS_R {
                RIMMIS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - CTSMMIS"]
            #[inline(always)]
            pub fn ctsmmis(&self) -> CTSMMIS_R {
                CTSMMIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - DCDMMIS"]
            #[inline(always)]
            pub fn dcdmmis(&self) -> DCDMMIS_R {
                DCDMMIS_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - DSRMMIS"]
            #[inline(always)]
            pub fn dsrmmis(&self) -> DSRMMIS_R {
                DSRMMIS_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RXMIS"]
            #[inline(always)]
            pub fn rxmis(&self) -> RXMIS_R {
                RXMIS_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TXMIS"]
            #[inline(always)]
            pub fn txmis(&self) -> TXMIS_R {
                TXMIS_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RTMIS"]
            #[inline(always)]
            pub fn rtmis(&self) -> RTMIS_R {
                RTMIS_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - FEMIS"]
            #[inline(always)]
            pub fn femis(&self) -> FEMIS_R {
                FEMIS_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - PEMIS"]
            #[inline(always)]
            pub fn pemis(&self) -> PEMIS_R {
                PEMIS_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - BEMIS"]
            #[inline(always)]
            pub fn bemis(&self) -> BEMIS_R {
                BEMIS_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - OEMIS"]
            #[inline(always)]
            pub fn oemis(&self) -> OEMIS_R {
                OEMIS_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MIS")
                    .field("rimmis", &format_args!("{}", self.rimmis().bit()))
                    .field("ctsmmis", &format_args!("{}", self.ctsmmis().bit()))
                    .field("dcdmmis", &format_args!("{}", self.dcdmmis().bit()))
                    .field("dsrmmis", &format_args!("{}", self.dsrmmis().bit()))
                    .field("rxmis", &format_args!("{}", self.rxmis().bit()))
                    .field("txmis", &format_args!("{}", self.txmis().bit()))
                    .field("rtmis", &format_args!("{}", self.rtmis().bit()))
                    .field("femis", &format_args!("{}", self.femis().bit()))
                    .field("pemis", &format_args!("{}", self.pemis().bit()))
                    .field("bemis", &format_args!("{}", self.bemis().bit()))
                    .field("oemis", &format_args!("{}", self.oemis().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<MIS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Masked Interrupt Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mis::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MIS_SPEC;
        impl crate::RegisterSpec for MIS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mis::R`](R) reader structure"]
        impl crate::Readable for MIS_SPEC {}
        #[doc = "`reset()` method sets MIS to value 0"]
        impl crate::Resettable for MIS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ICR (w) register accessor: Interrupt Clear Register\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`]
module"]
    pub type ICR = crate::Reg<icr::ICR_SPEC>;
    #[doc = "Interrupt Clear Register"]
    pub mod icr {
        #[doc = "Register `ICR` writer"]
        pub type W = crate::W<ICR_SPEC>;
        #[doc = "Field `RIMIC` writer - RIMIC"]
        pub type RIMIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTSMIC` writer - CTSMIC"]
        pub type CTSMIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DCDMIC` writer - DCDMIC"]
        pub type DCDMIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DSRMIC` writer - DSRMIC"]
        pub type DSRMIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXIC` writer - RXIC"]
        pub type RXIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXIC` writer - TXIC"]
        pub type TXIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RTIC` writer - RTIC"]
        pub type RTIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FEIC` writer - FEIC"]
        pub type FEIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PEIC` writer - PEIC"]
        pub type PEIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BEIC` writer - BEIC"]
        pub type BEIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OEIC` writer - OEIC"]
        pub type OEIC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl core::fmt::Debug for crate::generic::Reg<ICR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {
            #[doc = "Bit 0 - RIMIC"]
            #[inline(always)]
            #[must_use]
            pub fn rimic(&mut self) -> RIMIC_W<ICR_SPEC, 0> {
                RIMIC_W::new(self)
            }
            #[doc = "Bit 1 - CTSMIC"]
            #[inline(always)]
            #[must_use]
            pub fn ctsmic(&mut self) -> CTSMIC_W<ICR_SPEC, 1> {
                CTSMIC_W::new(self)
            }
            #[doc = "Bit 2 - DCDMIC"]
            #[inline(always)]
            #[must_use]
            pub fn dcdmic(&mut self) -> DCDMIC_W<ICR_SPEC, 2> {
                DCDMIC_W::new(self)
            }
            #[doc = "Bit 3 - DSRMIC"]
            #[inline(always)]
            #[must_use]
            pub fn dsrmic(&mut self) -> DSRMIC_W<ICR_SPEC, 3> {
                DSRMIC_W::new(self)
            }
            #[doc = "Bit 4 - RXIC"]
            #[inline(always)]
            #[must_use]
            pub fn rxic(&mut self) -> RXIC_W<ICR_SPEC, 4> {
                RXIC_W::new(self)
            }
            #[doc = "Bit 5 - TXIC"]
            #[inline(always)]
            #[must_use]
            pub fn txic(&mut self) -> TXIC_W<ICR_SPEC, 5> {
                TXIC_W::new(self)
            }
            #[doc = "Bit 6 - RTIC"]
            #[inline(always)]
            #[must_use]
            pub fn rtic(&mut self) -> RTIC_W<ICR_SPEC, 6> {
                RTIC_W::new(self)
            }
            #[doc = "Bit 7 - FEIC"]
            #[inline(always)]
            #[must_use]
            pub fn feic(&mut self) -> FEIC_W<ICR_SPEC, 7> {
                FEIC_W::new(self)
            }
            #[doc = "Bit 8 - PEIC"]
            #[inline(always)]
            #[must_use]
            pub fn peic(&mut self) -> PEIC_W<ICR_SPEC, 8> {
                PEIC_W::new(self)
            }
            #[doc = "Bit 9 - BEIC"]
            #[inline(always)]
            #[must_use]
            pub fn beic(&mut self) -> BEIC_W<ICR_SPEC, 9> {
                BEIC_W::new(self)
            }
            #[doc = "Bit 10 - OEIC"]
            #[inline(always)]
            #[must_use]
            pub fn oeic(&mut self) -> OEIC_W<ICR_SPEC, 10> {
                OEIC_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt Clear Register\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ICR_SPEC;
        impl crate::RegisterSpec for ICR_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"]
        impl crate::Writable for ICR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ICR to value 0"]
        impl crate::Resettable for ICR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DMACR (rw) register accessor: DMA Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dmacr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmacr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmacr`]
module"]
    pub type DMACR = crate::Reg<dmacr::DMACR_SPEC>;
    #[doc = "DMA Control Register"]
    pub mod dmacr {
        #[doc = "Register `DMACR` reader"]
        pub type R = crate::R<DMACR_SPEC>;
        #[doc = "Register `DMACR` writer"]
        pub type W = crate::W<DMACR_SPEC>;
        #[doc = "Field `RXDMAE` reader - RXDMAE"]
        pub type RXDMAE_R = crate::BitReader;
        #[doc = "Field `RXDMAE` writer - RXDMAE"]
        pub type RXDMAE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXDMAE` reader - TXDMAE"]
        pub type TXDMAE_R = crate::BitReader;
        #[doc = "Field `TXDMAE` writer - TXDMAE"]
        pub type TXDMAE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DMAONERR` reader - DMAONERR"]
        pub type DMAONERR_R = crate::BitReader;
        #[doc = "Field `DMAONERR` writer - DMAONERR"]
        pub type DMAONERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - RXDMAE"]
            #[inline(always)]
            pub fn rxdmae(&self) -> RXDMAE_R {
                RXDMAE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - TXDMAE"]
            #[inline(always)]
            pub fn txdmae(&self) -> TXDMAE_R {
                TXDMAE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - DMAONERR"]
            #[inline(always)]
            pub fn dmaonerr(&self) -> DMAONERR_R {
                DMAONERR_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DMACR")
                    .field("rxdmae", &format_args!("{}", self.rxdmae().bit()))
                    .field("txdmae", &format_args!("{}", self.txdmae().bit()))
                    .field("dmaonerr", &format_args!("{}", self.dmaonerr().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DMACR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - RXDMAE"]
            #[inline(always)]
            #[must_use]
            pub fn rxdmae(&mut self) -> RXDMAE_W<DMACR_SPEC, 0> {
                RXDMAE_W::new(self)
            }
            #[doc = "Bit 1 - TXDMAE"]
            #[inline(always)]
            #[must_use]
            pub fn txdmae(&mut self) -> TXDMAE_W<DMACR_SPEC, 1> {
                TXDMAE_W::new(self)
            }
            #[doc = "Bit 2 - DMAONERR"]
            #[inline(always)]
            #[must_use]
            pub fn dmaonerr(&mut self) -> DMAONERR_W<DMACR_SPEC, 2> {
                DMAONERR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "DMA Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dmacr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmacr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DMACR_SPEC;
        impl crate::RegisterSpec for DMACR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dmacr::R`](R) reader structure"]
        impl crate::Readable for DMACR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dmacr::W`](W) writer structure"]
        impl crate::Writable for DMACR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DMACR to value 0"]
        impl crate::Resettable for DMACR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Broadcom SPI Controller"]
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x2020_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
#[doc = "Broadcom SPI Controller"]
pub mod spi0 {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control and Status"]
        pub cs: CS,
        #[doc = "0x04 - FIFO access"]
        pub fifo: FIFO,
        #[doc = "0x08 - Clock divider"]
        pub clk: CLK,
        #[doc = "0x0c - Data length"]
        pub dlen: DLEN,
        #[doc = "0x10 - LoSSI output hold delay"]
        pub ltoh: LTOH,
        #[doc = "0x14 - "]
        pub dc: DC,
    }
    #[doc = "CS (rw) register accessor: Control and Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cs::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cs::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cs`]
module"]
    pub type CS = crate::Reg<cs::CS_SPEC>;
    #[doc = "Control and Status"]
    pub mod cs {
        #[doc = "Register `CS` reader"]
        pub type R = crate::R<CS_SPEC>;
        #[doc = "Register `CS` writer"]
        pub type W = crate::W<CS_SPEC>;
        #[doc = "Field `CS` reader - Chip select"]
        pub type CS_R = crate::FieldReader;
        #[doc = "Field `CS` writer - Chip select"]
        pub type CS_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        #[doc = "Field `CPHA` reader - Clock phase"]
        pub type CPHA_R = crate::BitReader;
        #[doc = "Field `CPHA` writer - Clock phase"]
        pub type CPHA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CPOL` reader - Clock polarity"]
        pub type CPOL_R = crate::BitReader;
        #[doc = "Field `CPOL` writer - Clock polarity"]
        pub type CPOL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CLEAR` reader - Clear the FIFO(s)"]
        pub type CLEAR_R = crate::FieldReader<CLEAR_A>;
        #[doc = "Clear the FIFO(s)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CLEAR_A {
            #[doc = "1: `1`"]
            TX = 1,
            #[doc = "2: `10`"]
            RX = 2,
            #[doc = "3: `11`"]
            BOTH = 3,
        }
        impl From<CLEAR_A> for u8 {
            #[inline(always)]
            fn from(variant: CLEAR_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CLEAR_A {
            type Ux = u8;
        }
        impl CLEAR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CLEAR_A> {
                match self.bits {
                    1 => Some(CLEAR_A::TX),
                    2 => Some(CLEAR_A::RX),
                    3 => Some(CLEAR_A::BOTH),
                    _ => None,
                }
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_tx(&self) -> bool {
                *self == CLEAR_A::TX
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_rx(&self) -> bool {
                *self == CLEAR_A::RX
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == CLEAR_A::BOTH
            }
        }
        #[doc = "Field `CLEAR` writer - Clear the FIFO(s)"]
        pub type CLEAR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O, CLEAR_A>;
        impl<'a, REG, const O: u8> CLEAR_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn tx(self) -> &'a mut crate::W<REG> {
                self.variant(CLEAR_A::TX)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn rx(self) -> &'a mut crate::W<REG> {
                self.variant(CLEAR_A::RX)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn both(self) -> &'a mut crate::W<REG> {
                self.variant(CLEAR_A::BOTH)
            }
        }
        #[doc = "Field `CSPOL` reader - Chip select polarity"]
        pub type CSPOL_R = crate::BitReader;
        #[doc = "Field `CSPOL` writer - Chip select polarity"]
        pub type CSPOL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TA` reader - Transfer active"]
        pub type TA_R = crate::BitReader;
        #[doc = "Field `TA` writer - Transfer active"]
        pub type TA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DMAEN` reader - Enable DMA"]
        pub type DMAEN_R = crate::BitReader;
        #[doc = "Field `DMAEN` writer - Enable DMA"]
        pub type DMAEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INTD` reader - Interrupt on done"]
        pub type INTD_R = crate::BitReader;
        #[doc = "Field `INTD` writer - Interrupt on done"]
        pub type INTD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INTR` reader - Interrupt on RX"]
        pub type INTR_R = crate::BitReader;
        #[doc = "Field `INTR` writer - Interrupt on RX"]
        pub type INTR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ADCS` reader - Automatically deassert chip select"]
        pub type ADCS_R = crate::BitReader;
        #[doc = "Field `ADCS` writer - Automatically deassert chip select"]
        pub type ADCS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `REN` reader - Read enable"]
        pub type REN_R = crate::BitReader;
        #[doc = "Field `REN` writer - Read enable"]
        pub type REN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN` reader - LoSSI enable"]
        pub type LEN_R = crate::BitReader;
        #[doc = "Field `LEN` writer - LoSSI enable"]
        pub type LEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LMONO` reader - "]
        pub type LMONO_R = crate::BitReader;
        #[doc = "Field `LMONO` writer - "]
        pub type LMONO_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TE_EN` reader - "]
        pub type TE_EN_R = crate::BitReader;
        #[doc = "Field `TE_EN` writer - "]
        pub type TE_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DONE` reader - Transfer is done"]
        pub type DONE_R = crate::BitReader;
        #[doc = "Field `RXD` reader - RX FIFO contains data"]
        pub type RXD_R = crate::BitReader;
        #[doc = "Field `TXD` reader - TX FIFO can accept data"]
        pub type TXD_R = crate::BitReader;
        #[doc = "Field `RXR` reader - RX FIFO has data to be read"]
        pub type RXR_R = crate::BitReader;
        #[doc = "Field `RXF` reader - RX FIFO full"]
        pub type RXF_R = crate::BitReader;
        #[doc = "Field `CSPOL0` reader - Chip select 0 polarity"]
        pub type CSPOL0_R = crate::BitReader;
        #[doc = "Field `CSPOL0` writer - Chip select 0 polarity"]
        pub type CSPOL0_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CSPOL1` reader - Chip select 1 polarity"]
        pub type CSPOL1_R = crate::BitReader;
        #[doc = "Field `CSPOL1` writer - Chip select 1 polarity"]
        pub type CSPOL1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CSPOL2` reader - Chip select 2 polarity"]
        pub type CSPOL2_R = crate::BitReader;
        #[doc = "Field `CSPOL2` writer - Chip select 2 polarity"]
        pub type CSPOL2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DMA_LEN` reader - Enable DMA in LoSSI mode"]
        pub type DMA_LEN_R = crate::BitReader;
        #[doc = "Field `DMA_LEN` writer - Enable DMA in LoSSI mode"]
        pub type DMA_LEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `LEN_LONG` reader - Enable long data word in LoSSI mode"]
        pub type LEN_LONG_R = crate::BitReader;
        #[doc = "Field `LEN_LONG` writer - Enable long data word in LoSSI mode"]
        pub type LEN_LONG_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bits 0:1 - Chip select"]
            #[inline(always)]
            pub fn cs(&self) -> CS_R {
                CS_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - Clear the FIFO(s)"]
            #[inline(always)]
            pub fn clear(&self) -> CLEAR_R {
                CLEAR_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bit 6 - Chip select polarity"]
            #[inline(always)]
            pub fn cspol(&self) -> CSPOL_R {
                CSPOL_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Transfer active"]
            #[inline(always)]
            pub fn ta(&self) -> TA_R {
                TA_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Enable DMA"]
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Interrupt on done"]
            #[inline(always)]
            pub fn intd(&self) -> INTD_R {
                INTD_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Interrupt on RX"]
            #[inline(always)]
            pub fn intr(&self) -> INTR_R {
                INTR_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Automatically deassert chip select"]
            #[inline(always)]
            pub fn adcs(&self) -> ADCS_R {
                ADCS_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Read enable"]
            #[inline(always)]
            pub fn ren(&self) -> REN_R {
                REN_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - LoSSI enable"]
            #[inline(always)]
            pub fn len(&self) -> LEN_R {
                LEN_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn lmono(&self) -> LMONO_R {
                LMONO_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn te_en(&self) -> TE_EN_R {
                TE_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Transfer is done"]
            #[inline(always)]
            pub fn done(&self) -> DONE_R {
                DONE_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - RX FIFO contains data"]
            #[inline(always)]
            pub fn rxd(&self) -> RXD_R {
                RXD_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - TX FIFO can accept data"]
            #[inline(always)]
            pub fn txd(&self) -> TXD_R {
                TXD_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - RX FIFO has data to be read"]
            #[inline(always)]
            pub fn rxr(&self) -> RXR_R {
                RXR_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - RX FIFO full"]
            #[inline(always)]
            pub fn rxf(&self) -> RXF_R {
                RXF_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Chip select 0 polarity"]
            #[inline(always)]
            pub fn cspol0(&self) -> CSPOL0_R {
                CSPOL0_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Chip select 1 polarity"]
            #[inline(always)]
            pub fn cspol1(&self) -> CSPOL1_R {
                CSPOL1_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Chip select 2 polarity"]
            #[inline(always)]
            pub fn cspol2(&self) -> CSPOL2_R {
                CSPOL2_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Enable DMA in LoSSI mode"]
            #[inline(always)]
            pub fn dma_len(&self) -> DMA_LEN_R {
                DMA_LEN_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Enable long data word in LoSSI mode"]
            #[inline(always)]
            pub fn len_long(&self) -> LEN_LONG_R {
                LEN_LONG_R::new(((self.bits >> 25) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CS")
                    .field("len_long", &format_args!("{}", self.len_long().bit()))
                    .field("dma_len", &format_args!("{}", self.dma_len().bit()))
                    .field("cspol2", &format_args!("{}", self.cspol2().bit()))
                    .field("cspol1", &format_args!("{}", self.cspol1().bit()))
                    .field("cspol0", &format_args!("{}", self.cspol0().bit()))
                    .field("rxf", &format_args!("{}", self.rxf().bit()))
                    .field("rxr", &format_args!("{}", self.rxr().bit()))
                    .field("txd", &format_args!("{}", self.txd().bit()))
                    .field("rxd", &format_args!("{}", self.rxd().bit()))
                    .field("done", &format_args!("{}", self.done().bit()))
                    .field("te_en", &format_args!("{}", self.te_en().bit()))
                    .field("lmono", &format_args!("{}", self.lmono().bit()))
                    .field("len", &format_args!("{}", self.len().bit()))
                    .field("ren", &format_args!("{}", self.ren().bit()))
                    .field("adcs", &format_args!("{}", self.adcs().bit()))
                    .field("intr", &format_args!("{}", self.intr().bit()))
                    .field("intd", &format_args!("{}", self.intd().bit()))
                    .field("dmaen", &format_args!("{}", self.dmaen().bit()))
                    .field("ta", &format_args!("{}", self.ta().bit()))
                    .field("cspol", &format_args!("{}", self.cspol().bit()))
                    .field("clear", &format_args!("{}", self.clear().bits()))
                    .field("cpol", &format_args!("{}", self.cpol().bit()))
                    .field("cpha", &format_args!("{}", self.cpha().bit()))
                    .field("cs", &format_args!("{}", self.cs().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Chip select"]
            #[inline(always)]
            #[must_use]
            pub fn cs(&mut self) -> CS_W<CS_SPEC, 0> {
                CS_W::new(self)
            }
            #[doc = "Bit 2 - Clock phase"]
            #[inline(always)]
            #[must_use]
            pub fn cpha(&mut self) -> CPHA_W<CS_SPEC, 2> {
                CPHA_W::new(self)
            }
            #[doc = "Bit 3 - Clock polarity"]
            #[inline(always)]
            #[must_use]
            pub fn cpol(&mut self) -> CPOL_W<CS_SPEC, 3> {
                CPOL_W::new(self)
            }
            #[doc = "Bits 4:5 - Clear the FIFO(s)"]
            #[inline(always)]
            #[must_use]
            pub fn clear(&mut self) -> CLEAR_W<CS_SPEC, 4> {
                CLEAR_W::new(self)
            }
            #[doc = "Bit 6 - Chip select polarity"]
            #[inline(always)]
            #[must_use]
            pub fn cspol(&mut self) -> CSPOL_W<CS_SPEC, 6> {
                CSPOL_W::new(self)
            }
            #[doc = "Bit 7 - Transfer active"]
            #[inline(always)]
            #[must_use]
            pub fn ta(&mut self) -> TA_W<CS_SPEC, 7> {
                TA_W::new(self)
            }
            #[doc = "Bit 8 - Enable DMA"]
            #[inline(always)]
            #[must_use]
            pub fn dmaen(&mut self) -> DMAEN_W<CS_SPEC, 8> {
                DMAEN_W::new(self)
            }
            #[doc = "Bit 9 - Interrupt on done"]
            #[inline(always)]
            #[must_use]
            pub fn intd(&mut self) -> INTD_W<CS_SPEC, 9> {
                INTD_W::new(self)
            }
            #[doc = "Bit 10 - Interrupt on RX"]
            #[inline(always)]
            #[must_use]
            pub fn intr(&mut self) -> INTR_W<CS_SPEC, 10> {
                INTR_W::new(self)
            }
            #[doc = "Bit 11 - Automatically deassert chip select"]
            #[inline(always)]
            #[must_use]
            pub fn adcs(&mut self) -> ADCS_W<CS_SPEC, 11> {
                ADCS_W::new(self)
            }
            #[doc = "Bit 12 - Read enable"]
            #[inline(always)]
            #[must_use]
            pub fn ren(&mut self) -> REN_W<CS_SPEC, 12> {
                REN_W::new(self)
            }
            #[doc = "Bit 13 - LoSSI enable"]
            #[inline(always)]
            #[must_use]
            pub fn len(&mut self) -> LEN_W<CS_SPEC, 13> {
                LEN_W::new(self)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            #[must_use]
            pub fn lmono(&mut self) -> LMONO_W<CS_SPEC, 14> {
                LMONO_W::new(self)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            #[must_use]
            pub fn te_en(&mut self) -> TE_EN_W<CS_SPEC, 15> {
                TE_EN_W::new(self)
            }
            #[doc = "Bit 21 - Chip select 0 polarity"]
            #[inline(always)]
            #[must_use]
            pub fn cspol0(&mut self) -> CSPOL0_W<CS_SPEC, 21> {
                CSPOL0_W::new(self)
            }
            #[doc = "Bit 22 - Chip select 1 polarity"]
            #[inline(always)]
            #[must_use]
            pub fn cspol1(&mut self) -> CSPOL1_W<CS_SPEC, 22> {
                CSPOL1_W::new(self)
            }
            #[doc = "Bit 23 - Chip select 2 polarity"]
            #[inline(always)]
            #[must_use]
            pub fn cspol2(&mut self) -> CSPOL2_W<CS_SPEC, 23> {
                CSPOL2_W::new(self)
            }
            #[doc = "Bit 24 - Enable DMA in LoSSI mode"]
            #[inline(always)]
            #[must_use]
            pub fn dma_len(&mut self) -> DMA_LEN_W<CS_SPEC, 24> {
                DMA_LEN_W::new(self)
            }
            #[doc = "Bit 25 - Enable long data word in LoSSI mode"]
            #[inline(always)]
            #[must_use]
            pub fn len_long(&mut self) -> LEN_LONG_W<CS_SPEC, 25> {
                LEN_LONG_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control and Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cs::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cs::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CS_SPEC;
        impl crate::RegisterSpec for CS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cs::R`](R) reader structure"]
        impl crate::Readable for CS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cs::W`](W) writer structure"]
        impl crate::Writable for CS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CS to value 0x0004_1000"]
        impl crate::Resettable for CS_SPEC {
            const RESET_VALUE: Self::Ux = 0x0004_1000;
        }
    }
    #[doc = "FIFO (rw) register accessor: FIFO access\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`]
module"]
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    #[doc = "FIFO access"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FIFO_SPEC>;
        #[doc = "Register `FIFO` writer"]
        pub type W = crate::W<FIFO_SPEC>;
        #[doc = "Field `DATA` reader - Data"]
        pub type DATA_R = crate::FieldReader<u32>;
        #[doc = "Field `DATA` writer - Data"]
        pub type DATA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 32, O, u32>;
        impl R {
            #[doc = "Bits 0:31 - Data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FIFO")
                    .field("data", &format_args!("{}", self.data().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FIFO_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Data"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<FIFO_SPEC, 0> {
                DATA_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "FIFO access\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FIFO_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"]
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CLK (rw) register accessor: Clock divider\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`clk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk`]
module"]
    pub type CLK = crate::Reg<clk::CLK_SPEC>;
    #[doc = "Clock divider"]
    pub mod clk {
        #[doc = "Register `CLK` reader"]
        pub type R = crate::R<CLK_SPEC>;
        #[doc = "Register `CLK` writer"]
        pub type W = crate::W<CLK_SPEC>;
        #[doc = "Field `CDIV` reader - Clock divider"]
        pub type CDIV_R = crate::FieldReader<u16>;
        #[doc = "Field `CDIV` writer - Clock divider"]
        pub type CDIV_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Clock divider"]
            #[inline(always)]
            pub fn cdiv(&self) -> CDIV_R {
                CDIV_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CLK")
                    .field("cdiv", &format_args!("{}", self.cdiv().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CLK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Clock divider"]
            #[inline(always)]
            #[must_use]
            pub fn cdiv(&mut self) -> CDIV_W<CLK_SPEC, 0> {
                CDIV_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Clock divider\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`clk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CLK_SPEC;
        impl crate::RegisterSpec for CLK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clk::R`](R) reader structure"]
        impl crate::Readable for CLK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`clk::W`](W) writer structure"]
        impl crate::Writable for CLK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CLK to value 0"]
        impl crate::Resettable for CLK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DLEN (rw) register accessor: Data length\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dlen::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dlen::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dlen`]
module"]
    pub type DLEN = crate::Reg<dlen::DLEN_SPEC>;
    #[doc = "Data length"]
    pub mod dlen {
        #[doc = "Register `DLEN` reader"]
        pub type R = crate::R<DLEN_SPEC>;
        #[doc = "Register `DLEN` writer"]
        pub type W = crate::W<DLEN_SPEC>;
        #[doc = "Field `DLEN` reader - Data length"]
        pub type DLEN_R = crate::FieldReader<u16>;
        #[doc = "Field `DLEN` writer - Data length"]
        pub type DLEN_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Data length"]
            #[inline(always)]
            pub fn dlen(&self) -> DLEN_R {
                DLEN_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DLEN")
                    .field("dlen", &format_args!("{}", self.dlen().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DLEN_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Data length"]
            #[inline(always)]
            #[must_use]
            pub fn dlen(&mut self) -> DLEN_W<DLEN_SPEC, 0> {
                DLEN_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Data length\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dlen::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dlen::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DLEN_SPEC;
        impl crate::RegisterSpec for DLEN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dlen::R`](R) reader structure"]
        impl crate::Readable for DLEN_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dlen::W`](W) writer structure"]
        impl crate::Writable for DLEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DLEN to value 0"]
        impl crate::Resettable for DLEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "LTOH (rw) register accessor: LoSSI output hold delay\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ltoh::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ltoh::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ltoh`]
module"]
    pub type LTOH = crate::Reg<ltoh::LTOH_SPEC>;
    #[doc = "LoSSI output hold delay"]
    pub mod ltoh {
        #[doc = "Register `LTOH` reader"]
        pub type R = crate::R<LTOH_SPEC>;
        #[doc = "Register `LTOH` writer"]
        pub type W = crate::W<LTOH_SPEC>;
        #[doc = "Field `TOH` reader - Output hold delay"]
        pub type TOH_R = crate::FieldReader;
        #[doc = "Field `TOH` writer - Output hold delay"]
        pub type TOH_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        impl R {
            #[doc = "Bits 0:3 - Output hold delay"]
            #[inline(always)]
            pub fn toh(&self) -> TOH_R {
                TOH_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LTOH")
                    .field("toh", &format_args!("{}", self.toh().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<LTOH_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Output hold delay"]
            #[inline(always)]
            #[must_use]
            pub fn toh(&mut self) -> TOH_W<LTOH_SPEC, 0> {
                TOH_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "LoSSI output hold delay\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ltoh::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ltoh::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LTOH_SPEC;
        impl crate::RegisterSpec for LTOH_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ltoh::R`](R) reader structure"]
        impl crate::Readable for LTOH_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ltoh::W`](W) writer structure"]
        impl crate::Writable for LTOH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets LTOH to value 0x01"]
        impl crate::Resettable for LTOH_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    #[doc = "DC (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dc::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dc::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dc`]
module"]
    pub type DC = crate::Reg<dc::DC_SPEC>;
    #[doc = ""]
    pub mod dc {
        #[doc = "Register `DC` reader"]
        pub type R = crate::R<DC_SPEC>;
        #[doc = "Register `DC` writer"]
        pub type W = crate::W<DC_SPEC>;
        #[doc = "Field `TDREQ` reader - DMA Write request threshold"]
        pub type TDREQ_R = crate::FieldReader;
        #[doc = "Field `TDREQ` writer - DMA Write request threshold"]
        pub type TDREQ_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `TPANIC` reader - DMA write panic threshold"]
        pub type TPANIC_R = crate::FieldReader;
        #[doc = "Field `TPANIC` writer - DMA write panic threshold"]
        pub type TPANIC_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `RDREQ` reader - DMA read request threshold"]
        pub type RDREQ_R = crate::FieldReader;
        #[doc = "Field `RDREQ` writer - DMA read request threshold"]
        pub type RDREQ_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `RPANIC` reader - DMA read panic threshold"]
        pub type RPANIC_R = crate::FieldReader;
        #[doc = "Field `RPANIC` writer - DMA read panic threshold"]
        pub type RPANIC_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        impl R {
            #[doc = "Bits 0:7 - DMA Write request threshold"]
            #[inline(always)]
            pub fn tdreq(&self) -> TDREQ_R {
                TDREQ_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - DMA write panic threshold"]
            #[inline(always)]
            pub fn tpanic(&self) -> TPANIC_R {
                TPANIC_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - DMA read request threshold"]
            #[inline(always)]
            pub fn rdreq(&self) -> RDREQ_R {
                RDREQ_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - DMA read panic threshold"]
            #[inline(always)]
            pub fn rpanic(&self) -> RPANIC_R {
                RPANIC_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DC")
                    .field("rpanic", &format_args!("{}", self.rpanic().bits()))
                    .field("rdreq", &format_args!("{}", self.rdreq().bits()))
                    .field("tpanic", &format_args!("{}", self.tpanic().bits()))
                    .field("tdreq", &format_args!("{}", self.tdreq().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DC_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DMA Write request threshold"]
            #[inline(always)]
            #[must_use]
            pub fn tdreq(&mut self) -> TDREQ_W<DC_SPEC, 0> {
                TDREQ_W::new(self)
            }
            #[doc = "Bits 8:15 - DMA write panic threshold"]
            #[inline(always)]
            #[must_use]
            pub fn tpanic(&mut self) -> TPANIC_W<DC_SPEC, 8> {
                TPANIC_W::new(self)
            }
            #[doc = "Bits 16:23 - DMA read request threshold"]
            #[inline(always)]
            #[must_use]
            pub fn rdreq(&mut self) -> RDREQ_W<DC_SPEC, 16> {
                RDREQ_W::new(self)
            }
            #[doc = "Bits 24:31 - DMA read panic threshold"]
            #[inline(always)]
            #[must_use]
            pub fn rpanic(&mut self) -> RPANIC_W<DC_SPEC, 24> {
                RPANIC_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dc::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dc::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DC_SPEC;
        impl crate::RegisterSpec for DC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dc::R`](R) reader structure"]
        impl crate::Readable for DC_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dc::W`](W) writer structure"]
        impl crate::Writable for DC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DC to value 0x3020_1050"]
        impl crate::Resettable for DC_SPEC {
            const RESET_VALUE: Self::Ux = 0x3020_1050;
        }
    }
}
#[doc = "Broadcom Serial Controller (I2C compatible)"]
pub struct BSC0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BSC0 {}
impl BSC0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bsc0::RegisterBlock = 0x2020_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bsc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BSC0 {
    type Target = bsc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BSC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BSC0").finish()
    }
}
#[doc = "Broadcom Serial Controller (I2C compatible)"]
pub mod bsc0 {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub c: C,
        #[doc = "0x04 - Status"]
        pub s: S,
        #[doc = "0x08 - Data length"]
        pub dlen: DLEN,
        #[doc = "0x0c - Slave address"]
        pub a: A,
        #[doc = "0x10 - Data FIFO"]
        pub fifo: FIFO,
        #[doc = "0x14 - Clock divider"]
        pub div: DIV,
        #[doc = "0x18 - Data delay (Values must be under CDIV / 2)"]
        pub del: DEL,
        #[doc = "0x1c - Clock stretch timeout (broken on 283x)"]
        pub clkt: CLKT,
    }
    #[doc = "C (rw) register accessor: Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c`]
module"]
    pub type C = crate::Reg<c::C_SPEC>;
    #[doc = "Control"]
    pub mod c {
        #[doc = "Register `C` reader"]
        pub type R = crate::R<C_SPEC>;
        #[doc = "Register `C` writer"]
        pub type W = crate::W<C_SPEC>;
        #[doc = "Field `READ` reader - Transfer is read"]
        pub type READ_R = crate::BitReader;
        #[doc = "Field `READ` writer - Transfer is read"]
        pub type READ_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CLEAR` reader - Clear the FIFO"]
        pub type CLEAR_R = crate::FieldReader;
        #[doc = "Field `CLEAR` writer - Clear the FIFO"]
        pub type CLEAR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        #[doc = "Field `ST` reader - Start transfer"]
        pub type ST_R = crate::BitReader;
        #[doc = "Field `ST` writer - Start transfer"]
        pub type ST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INTD` reader - Interrupt on done"]
        pub type INTD_R = crate::BitReader;
        #[doc = "Field `INTD` writer - Interrupt on done"]
        pub type INTD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INTT` reader - Interrupt on TX"]
        pub type INTT_R = crate::BitReader;
        #[doc = "Field `INTT` writer - Interrupt on TX"]
        pub type INTT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INTR` reader - Interrupt on RX"]
        pub type INTR_R = crate::BitReader;
        #[doc = "Field `INTR` writer - Interrupt on RX"]
        pub type INTR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `I2CEN` reader - I2C Enable"]
        pub type I2CEN_R = crate::BitReader;
        #[doc = "Field `I2CEN` writer - I2C Enable"]
        pub type I2CEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Transfer is read"]
            #[inline(always)]
            pub fn read(&self) -> READ_R {
                READ_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 4:5 - Clear the FIFO"]
            #[inline(always)]
            pub fn clear(&self) -> CLEAR_R {
                CLEAR_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bit 7 - Start transfer"]
            #[inline(always)]
            pub fn st(&self) -> ST_R {
                ST_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Interrupt on done"]
            #[inline(always)]
            pub fn intd(&self) -> INTD_R {
                INTD_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Interrupt on TX"]
            #[inline(always)]
            pub fn intt(&self) -> INTT_R {
                INTT_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Interrupt on RX"]
            #[inline(always)]
            pub fn intr(&self) -> INTR_R {
                INTR_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 15 - I2C Enable"]
            #[inline(always)]
            pub fn i2cen(&self) -> I2CEN_R {
                I2CEN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("C")
                    .field("i2cen", &format_args!("{}", self.i2cen().bit()))
                    .field("intr", &format_args!("{}", self.intr().bit()))
                    .field("intt", &format_args!("{}", self.intt().bit()))
                    .field("intd", &format_args!("{}", self.intd().bit()))
                    .field("st", &format_args!("{}", self.st().bit()))
                    .field("clear", &format_args!("{}", self.clear().bits()))
                    .field("read", &format_args!("{}", self.read().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<C_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transfer is read"]
            #[inline(always)]
            #[must_use]
            pub fn read(&mut self) -> READ_W<C_SPEC, 0> {
                READ_W::new(self)
            }
            #[doc = "Bits 4:5 - Clear the FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn clear(&mut self) -> CLEAR_W<C_SPEC, 4> {
                CLEAR_W::new(self)
            }
            #[doc = "Bit 7 - Start transfer"]
            #[inline(always)]
            #[must_use]
            pub fn st(&mut self) -> ST_W<C_SPEC, 7> {
                ST_W::new(self)
            }
            #[doc = "Bit 8 - Interrupt on done"]
            #[inline(always)]
            #[must_use]
            pub fn intd(&mut self) -> INTD_W<C_SPEC, 8> {
                INTD_W::new(self)
            }
            #[doc = "Bit 9 - Interrupt on TX"]
            #[inline(always)]
            #[must_use]
            pub fn intt(&mut self) -> INTT_W<C_SPEC, 9> {
                INTT_W::new(self)
            }
            #[doc = "Bit 10 - Interrupt on RX"]
            #[inline(always)]
            #[must_use]
            pub fn intr(&mut self) -> INTR_W<C_SPEC, 10> {
                INTR_W::new(self)
            }
            #[doc = "Bit 15 - I2C Enable"]
            #[inline(always)]
            #[must_use]
            pub fn i2cen(&mut self) -> I2CEN_W<C_SPEC, 15> {
                I2CEN_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`c::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`c::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct C_SPEC;
        impl crate::RegisterSpec for C_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`c::R`](R) reader structure"]
        impl crate::Readable for C_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`c::W`](W) writer structure"]
        impl crate::Writable for C_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets C to value 0"]
        impl crate::Resettable for C_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "S (rw) register accessor: Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`s::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`s::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@s`]
module"]
    pub type S = crate::Reg<s::S_SPEC>;
    #[doc = "Status"]
    pub mod s {
        #[doc = "Register `S` reader"]
        pub type R = crate::R<S_SPEC>;
        #[doc = "Register `S` writer"]
        pub type W = crate::W<S_SPEC>;
        #[doc = "Field `TA` reader - Transfer active"]
        pub type TA_R = crate::BitReader;
        #[doc = "Field `DONE` reader - Transfer done"]
        pub type DONE_R = crate::BitReader;
        #[doc = "Field `DONE` writer - Transfer done"]
        pub type DONE_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `TXW` reader - FIFO needs to be written"]
        pub type TXW_R = crate::BitReader;
        #[doc = "Field `RXR` reader - FIFO needs to be read"]
        pub type RXR_R = crate::BitReader;
        #[doc = "Field `TXD` reader - FIFO has space for at least one byte"]
        pub type TXD_R = crate::BitReader;
        #[doc = "Field `RXD` reader - FIFO contains at least one byte"]
        pub type RXD_R = crate::BitReader;
        #[doc = "Field `TXE` reader - FIFO is empty. Nothing to transmit"]
        pub type TXE_R = crate::BitReader;
        #[doc = "Field `RXF` reader - FIFO is full. Can't receive anything else"]
        pub type RXF_R = crate::BitReader;
        #[doc = "Field `ERR` reader - Error: No ack"]
        pub type ERR_R = crate::BitReader;
        #[doc = "Field `ERR` writer - Error: No ack"]
        pub type ERR_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CLKT` reader - Clock stretch timeout"]
        pub type CLKT_R = crate::BitReader;
        #[doc = "Field `CLKT` writer - Clock stretch timeout"]
        pub type CLKT_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Transfer active"]
            #[inline(always)]
            pub fn ta(&self) -> TA_R {
                TA_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Transfer done"]
            #[inline(always)]
            pub fn done(&self) -> DONE_R {
                DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - FIFO needs to be written"]
            #[inline(always)]
            pub fn txw(&self) -> TXW_R {
                TXW_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - FIFO needs to be read"]
            #[inline(always)]
            pub fn rxr(&self) -> RXR_R {
                RXR_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - FIFO has space for at least one byte"]
            #[inline(always)]
            pub fn txd(&self) -> TXD_R {
                TXD_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - FIFO contains at least one byte"]
            #[inline(always)]
            pub fn rxd(&self) -> RXD_R {
                RXD_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - FIFO is empty. Nothing to transmit"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - FIFO is full. Can't receive anything else"]
            #[inline(always)]
            pub fn rxf(&self) -> RXF_R {
                RXF_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Error: No ack"]
            #[inline(always)]
            pub fn err(&self) -> ERR_R {
                ERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Clock stretch timeout"]
            #[inline(always)]
            pub fn clkt(&self) -> CLKT_R {
                CLKT_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("S")
                    .field("clkt", &format_args!("{}", self.clkt().bit()))
                    .field("err", &format_args!("{}", self.err().bit()))
                    .field("rxf", &format_args!("{}", self.rxf().bit()))
                    .field("txe", &format_args!("{}", self.txe().bit()))
                    .field("rxd", &format_args!("{}", self.rxd().bit()))
                    .field("txd", &format_args!("{}", self.txd().bit()))
                    .field("rxr", &format_args!("{}", self.rxr().bit()))
                    .field("txw", &format_args!("{}", self.txw().bit()))
                    .field("done", &format_args!("{}", self.done().bit()))
                    .field("ta", &format_args!("{}", self.ta().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<S_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - Transfer done"]
            #[inline(always)]
            #[must_use]
            pub fn done(&mut self) -> DONE_W<S_SPEC, 1> {
                DONE_W::new(self)
            }
            #[doc = "Bit 8 - Error: No ack"]
            #[inline(always)]
            #[must_use]
            pub fn err(&mut self) -> ERR_W<S_SPEC, 8> {
                ERR_W::new(self)
            }
            #[doc = "Bit 9 - Clock stretch timeout"]
            #[inline(always)]
            #[must_use]
            pub fn clkt(&mut self) -> CLKT_W<S_SPEC, 9> {
                CLKT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`s::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`s::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct S_SPEC;
        impl crate::RegisterSpec for S_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`s::R`](R) reader structure"]
        impl crate::Readable for S_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`s::W`](W) writer structure"]
        impl crate::Writable for S_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0302;
        }
        #[doc = "`reset()` method sets S to value 0x50"]
        impl crate::Resettable for S_SPEC {
            const RESET_VALUE: Self::Ux = 0x50;
        }
    }
    #[doc = "DLEN (rw) register accessor: Data length\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dlen::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dlen::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dlen`]
module"]
    pub type DLEN = crate::Reg<dlen::DLEN_SPEC>;
    #[doc = "Data length"]
    pub mod dlen {
        #[doc = "Register `DLEN` reader"]
        pub type R = crate::R<DLEN_SPEC>;
        #[doc = "Register `DLEN` writer"]
        pub type W = crate::W<DLEN_SPEC>;
        #[doc = "Field `DLEN` reader - Data length"]
        pub type DLEN_R = crate::FieldReader<u16>;
        #[doc = "Field `DLEN` writer - Data length"]
        pub type DLEN_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Data length"]
            #[inline(always)]
            pub fn dlen(&self) -> DLEN_R {
                DLEN_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DLEN")
                    .field("dlen", &format_args!("{}", self.dlen().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DLEN_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Data length"]
            #[inline(always)]
            #[must_use]
            pub fn dlen(&mut self) -> DLEN_W<DLEN_SPEC, 0> {
                DLEN_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Data length\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dlen::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dlen::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DLEN_SPEC;
        impl crate::RegisterSpec for DLEN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dlen::R`](R) reader structure"]
        impl crate::Readable for DLEN_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dlen::W`](W) writer structure"]
        impl crate::Writable for DLEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DLEN to value 0"]
        impl crate::Resettable for DLEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "A (rw) register accessor: Slave address\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`a::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`a::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@a`]
module"]
    pub type A = crate::Reg<a::A_SPEC>;
    #[doc = "Slave address"]
    pub mod a {
        #[doc = "Register `A` reader"]
        pub type R = crate::R<A_SPEC>;
        #[doc = "Register `A` writer"]
        pub type W = crate::W<A_SPEC>;
        #[doc = "Field `ADDR` reader - Slave address"]
        pub type ADDR_R = crate::FieldReader;
        #[doc = "Field `ADDR` writer - Slave address"]
        pub type ADDR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 7, O>;
        impl R {
            #[doc = "Bits 0:6 - Slave address"]
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("A")
                    .field("addr", &format_args!("{}", self.addr().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<A_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - Slave address"]
            #[inline(always)]
            #[must_use]
            pub fn addr(&mut self) -> ADDR_W<A_SPEC, 0> {
                ADDR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Slave address\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`a::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`a::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct A_SPEC;
        impl crate::RegisterSpec for A_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`a::R`](R) reader structure"]
        impl crate::Readable for A_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`a::W`](W) writer structure"]
        impl crate::Writable for A_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets A to value 0"]
        impl crate::Resettable for A_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "FIFO (rw) register accessor: Data FIFO\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`]
module"]
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    #[doc = "Data FIFO"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FIFO_SPEC>;
        #[doc = "Register `FIFO` writer"]
        pub type W = crate::W<FIFO_SPEC>;
        #[doc = "Field `DATA` reader - Access the FIFO"]
        pub type DATA_R = crate::FieldReader;
        #[doc = "Field `DATA` writer - Access the FIFO"]
        pub type DATA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        impl R {
            #[doc = "Bits 0:7 - Access the FIFO"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FIFO")
                    .field("data", &format_args!("{}", self.data().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FIFO_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Access the FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<FIFO_SPEC, 0> {
                DATA_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Data FIFO\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FIFO_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"]
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DIV (rw) register accessor: Clock divider\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`]
module"]
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    #[doc = "Clock divider"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DIV_SPEC>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DIV_SPEC>;
        #[doc = "Field `CDIV` reader - Divide the source clock"]
        pub type CDIV_R = crate::FieldReader<u16>;
        #[doc = "Field `CDIV` writer - Divide the source clock"]
        pub type CDIV_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Divide the source clock"]
            #[inline(always)]
            pub fn cdiv(&self) -> CDIV_R {
                CDIV_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIV")
                    .field("cdiv", &format_args!("{}", self.cdiv().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIV_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Divide the source clock"]
            #[inline(always)]
            #[must_use]
            pub fn cdiv(&mut self) -> CDIV_W<DIV_SPEC, 0> {
                CDIV_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Clock divider\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DIV_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIV to value 0x05dc"]
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0x05dc;
        }
    }
    #[doc = "DEL (rw) register accessor: Data delay (Values must be under CDIV / 2)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`del::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`del::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@del`]
module"]
    pub type DEL = crate::Reg<del::DEL_SPEC>;
    #[doc = "Data delay (Values must be under CDIV / 2)"]
    pub mod del {
        #[doc = "Register `DEL` reader"]
        pub type R = crate::R<DEL_SPEC>;
        #[doc = "Register `DEL` writer"]
        pub type W = crate::W<DEL_SPEC>;
        #[doc = "Field `REDL` reader - Delay before reading after a rising edge"]
        pub type REDL_R = crate::FieldReader<u16>;
        #[doc = "Field `REDL` writer - Delay before reading after a rising edge"]
        pub type REDL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `FEDL` reader - Delay before reading after a falling edge"]
        pub type FEDL_R = crate::FieldReader<u16>;
        #[doc = "Field `FEDL` writer - Delay before reading after a falling edge"]
        pub type FEDL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Delay before reading after a rising edge"]
            #[inline(always)]
            pub fn redl(&self) -> REDL_R {
                REDL_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Delay before reading after a falling edge"]
            #[inline(always)]
            pub fn fedl(&self) -> FEDL_R {
                FEDL_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DEL")
                    .field("fedl", &format_args!("{}", self.fedl().bits()))
                    .field("redl", &format_args!("{}", self.redl().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DEL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Delay before reading after a rising edge"]
            #[inline(always)]
            #[must_use]
            pub fn redl(&mut self) -> REDL_W<DEL_SPEC, 0> {
                REDL_W::new(self)
            }
            #[doc = "Bits 16:31 - Delay before reading after a falling edge"]
            #[inline(always)]
            #[must_use]
            pub fn fedl(&mut self) -> FEDL_W<DEL_SPEC, 16> {
                FEDL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Data delay (Values must be under CDIV / 2)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`del::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`del::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DEL_SPEC;
        impl crate::RegisterSpec for DEL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`del::R`](R) reader structure"]
        impl crate::Readable for DEL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`del::W`](W) writer structure"]
        impl crate::Writable for DEL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DEL to value 0x0030_0030"]
        impl crate::Resettable for DEL_SPEC {
            const RESET_VALUE: Self::Ux = 0x0030_0030;
        }
    }
    #[doc = "CLKT (rw) register accessor: Clock stretch timeout (broken on 283x)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`clkt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clkt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clkt`]
module"]
    pub type CLKT = crate::Reg<clkt::CLKT_SPEC>;
    #[doc = "Clock stretch timeout (broken on 283x)"]
    pub mod clkt {
        #[doc = "Register `CLKT` reader"]
        pub type R = crate::R<CLKT_SPEC>;
        #[doc = "Register `CLKT` writer"]
        pub type W = crate::W<CLKT_SPEC>;
        #[doc = "Field `TOUT` reader - Number of SCL clock cycles to wait"]
        pub type TOUT_R = crate::FieldReader<u16>;
        #[doc = "Field `TOUT` writer - Number of SCL clock cycles to wait"]
        pub type TOUT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Number of SCL clock cycles to wait"]
            #[inline(always)]
            pub fn tout(&self) -> TOUT_R {
                TOUT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CLKT")
                    .field("tout", &format_args!("{}", self.tout().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CLKT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Number of SCL clock cycles to wait"]
            #[inline(always)]
            #[must_use]
            pub fn tout(&mut self) -> TOUT_W<CLKT_SPEC, 0> {
                TOUT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Clock stretch timeout (broken on 283x)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`clkt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clkt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CLKT_SPEC;
        impl crate::RegisterSpec for CLKT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clkt::R`](R) reader structure"]
        impl crate::Readable for CLKT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`clkt::W`](W) writer structure"]
        impl crate::Writable for CLKT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CLKT to value 0"]
        impl crate::Resettable for CLKT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Broadcom PWM"]
pub struct PWM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM0 {}
impl PWM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x2020_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PWM0 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM0").finish()
    }
}
#[doc = "Broadcom PWM"]
pub mod pwm0 {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctl: CTL,
        #[doc = "0x04 - Status"]
        pub sta: STA,
        #[doc = "0x08 - DMA control"]
        pub dmac: DMAC,
        _reserved3: [u8; 0x04],
        #[doc = "0x10 - Range for channel 1"]
        pub rng1: RNG1,
        #[doc = "0x14 - Channel 1 data"]
        pub dat1: DAT1,
        #[doc = "0x18 - FIFO input"]
        pub fif1: FIF1,
        _reserved6: [u8; 0x04],
        #[doc = "0x20 - Range for channel 2"]
        pub rng2: RNG2,
        #[doc = "0x24 - Channel 2 data"]
        pub dat2: DAT2,
    }
    #[doc = "CTL (rw) register accessor: Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctl`]
module"]
    pub type CTL = crate::Reg<ctl::CTL_SPEC>;
    #[doc = "Control"]
    pub mod ctl {
        #[doc = "Register `CTL` reader"]
        pub type R = crate::R<CTL_SPEC>;
        #[doc = "Register `CTL` writer"]
        pub type W = crate::W<CTL_SPEC>;
        #[doc = "Field `PWEN1` reader - Enable channel 1"]
        pub type PWEN1_R = crate::BitReader;
        #[doc = "Field `PWEN1` writer - Enable channel 1"]
        pub type PWEN1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `MODE1` reader - Channel 1 mode"]
        pub type MODE1_R = crate::BitReader<MODE1_A>;
        #[doc = "Channel 1 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE1_A {
            #[doc = "0: `0`"]
            PWM = 0,
            #[doc = "1: `1`"]
            SERIAL = 1,
        }
        impl From<MODE1_A> for bool {
            #[inline(always)]
            fn from(variant: MODE1_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MODE1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MODE1_A {
                match self.bits {
                    false => MODE1_A::PWM,
                    true => MODE1_A::SERIAL,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_pwm(&self) -> bool {
                *self == MODE1_A::PWM
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_serial(&self) -> bool {
                *self == MODE1_A::SERIAL
            }
        }
        #[doc = "Field `MODE1` writer - Channel 1 mode"]
        pub type MODE1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, MODE1_A>;
        impl<'a, REG, const O: u8> MODE1_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn pwm(self) -> &'a mut crate::W<REG> {
                self.variant(MODE1_A::PWM)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn serial(self) -> &'a mut crate::W<REG> {
                self.variant(MODE1_A::SERIAL)
            }
        }
        #[doc = "Field `RPTL1` reader - Repeat last value from FIFO for channel 1"]
        pub type RPTL1_R = crate::BitReader;
        #[doc = "Field `RPTL1` writer - Repeat last value from FIFO for channel 1"]
        pub type RPTL1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SBIT1` reader - State when not transmitting on channel 1"]
        pub type SBIT1_R = crate::BitReader;
        #[doc = "Field `SBIT1` writer - State when not transmitting on channel 1"]
        pub type SBIT1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `POLA1` reader - Channel 1 polarity inverted"]
        pub type POLA1_R = crate::BitReader;
        #[doc = "Field `POLA1` writer - Channel 1 polarity inverted"]
        pub type POLA1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `USEF1` reader - Use FIFO for channel 1"]
        pub type USEF1_R = crate::BitReader;
        #[doc = "Field `USEF1` writer - Use FIFO for channel 1"]
        pub type USEF1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CLRF1` reader - Clear FIFO"]
        pub type CLRF1_R = crate::BitReader;
        #[doc = "Field `CLRF1` writer - Clear FIFO"]
        pub type CLRF1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `MSEN1` reader - M/S mode for channel 1"]
        pub type MSEN1_R = crate::BitReader;
        #[doc = "Field `MSEN1` writer - M/S mode for channel 1"]
        pub type MSEN1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PWEN2` reader - Enable channel 2"]
        pub type PWEN2_R = crate::BitReader;
        #[doc = "Field `PWEN2` writer - Enable channel 2"]
        pub type PWEN2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `MODE2` reader - Channel 2 mode"]
        pub type MODE2_R = crate::BitReader<MODE2_A>;
        #[doc = "Channel 2 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE2_A {
            #[doc = "0: `0`"]
            PWM = 0,
            #[doc = "1: `1`"]
            SERIAL = 1,
        }
        impl From<MODE2_A> for bool {
            #[inline(always)]
            fn from(variant: MODE2_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MODE2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MODE2_A {
                match self.bits {
                    false => MODE2_A::PWM,
                    true => MODE2_A::SERIAL,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_pwm(&self) -> bool {
                *self == MODE2_A::PWM
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_serial(&self) -> bool {
                *self == MODE2_A::SERIAL
            }
        }
        #[doc = "Field `MODE2` writer - Channel 2 mode"]
        pub type MODE2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, MODE2_A>;
        impl<'a, REG, const O: u8> MODE2_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn pwm(self) -> &'a mut crate::W<REG> {
                self.variant(MODE2_A::PWM)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn serial(self) -> &'a mut crate::W<REG> {
                self.variant(MODE2_A::SERIAL)
            }
        }
        #[doc = "Field `RPTL2` reader - Repeat last value from FIFO for channel 2"]
        pub type RPTL2_R = crate::BitReader;
        #[doc = "Field `RPTL2` writer - Repeat last value from FIFO for channel 2"]
        pub type RPTL2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SBIT2` reader - State when not transmitting on channel 2"]
        pub type SBIT2_R = crate::BitReader;
        #[doc = "Field `SBIT2` writer - State when not transmitting on channel 2"]
        pub type SBIT2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `POLA2` reader - Channel 2 polarity inverted"]
        pub type POLA2_R = crate::BitReader;
        #[doc = "Field `POLA2` writer - Channel 2 polarity inverted"]
        pub type POLA2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `USEF2` reader - Use FIFO for channel 2"]
        pub type USEF2_R = crate::BitReader;
        #[doc = "Field `USEF2` writer - Use FIFO for channel 2"]
        pub type USEF2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `MSEN2` reader - M/S mode for channel 2"]
        pub type MSEN2_R = crate::BitReader;
        #[doc = "Field `MSEN2` writer - M/S mode for channel 2"]
        pub type MSEN2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Enable channel 1"]
            #[inline(always)]
            pub fn pwen1(&self) -> PWEN1_R {
                PWEN1_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Channel 1 mode"]
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Repeat last value from FIFO for channel 1"]
            #[inline(always)]
            pub fn rptl1(&self) -> RPTL1_R {
                RPTL1_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - State when not transmitting on channel 1"]
            #[inline(always)]
            pub fn sbit1(&self) -> SBIT1_R {
                SBIT1_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Channel 1 polarity inverted"]
            #[inline(always)]
            pub fn pola1(&self) -> POLA1_R {
                POLA1_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Use FIFO for channel 1"]
            #[inline(always)]
            pub fn usef1(&self) -> USEF1_R {
                USEF1_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Clear FIFO"]
            #[inline(always)]
            pub fn clrf1(&self) -> CLRF1_R {
                CLRF1_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - M/S mode for channel 1"]
            #[inline(always)]
            pub fn msen1(&self) -> MSEN1_R {
                MSEN1_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Enable channel 2"]
            #[inline(always)]
            pub fn pwen2(&self) -> PWEN2_R {
                PWEN2_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Channel 2 mode"]
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Repeat last value from FIFO for channel 2"]
            #[inline(always)]
            pub fn rptl2(&self) -> RPTL2_R {
                RPTL2_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - State when not transmitting on channel 2"]
            #[inline(always)]
            pub fn sbit2(&self) -> SBIT2_R {
                SBIT2_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Channel 2 polarity inverted"]
            #[inline(always)]
            pub fn pola2(&self) -> POLA2_R {
                POLA2_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Use FIFO for channel 2"]
            #[inline(always)]
            pub fn usef2(&self) -> USEF2_R {
                USEF2_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 15 - M/S mode for channel 2"]
            #[inline(always)]
            pub fn msen2(&self) -> MSEN2_R {
                MSEN2_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CTL")
                    .field("msen2", &format_args!("{}", self.msen2().bit()))
                    .field("usef2", &format_args!("{}", self.usef2().bit()))
                    .field("pola2", &format_args!("{}", self.pola2().bit()))
                    .field("sbit2", &format_args!("{}", self.sbit2().bit()))
                    .field("rptl2", &format_args!("{}", self.rptl2().bit()))
                    .field("mode2", &format_args!("{}", self.mode2().bit()))
                    .field("pwen2", &format_args!("{}", self.pwen2().bit()))
                    .field("msen1", &format_args!("{}", self.msen1().bit()))
                    .field("clrf1", &format_args!("{}", self.clrf1().bit()))
                    .field("usef1", &format_args!("{}", self.usef1().bit()))
                    .field("pola1", &format_args!("{}", self.pola1().bit()))
                    .field("sbit1", &format_args!("{}", self.sbit1().bit()))
                    .field("rptl1", &format_args!("{}", self.rptl1().bit()))
                    .field("mode1", &format_args!("{}", self.mode1().bit()))
                    .field("pwen1", &format_args!("{}", self.pwen1().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable channel 1"]
            #[inline(always)]
            #[must_use]
            pub fn pwen1(&mut self) -> PWEN1_W<CTL_SPEC, 0> {
                PWEN1_W::new(self)
            }
            #[doc = "Bit 1 - Channel 1 mode"]
            #[inline(always)]
            #[must_use]
            pub fn mode1(&mut self) -> MODE1_W<CTL_SPEC, 1> {
                MODE1_W::new(self)
            }
            #[doc = "Bit 2 - Repeat last value from FIFO for channel 1"]
            #[inline(always)]
            #[must_use]
            pub fn rptl1(&mut self) -> RPTL1_W<CTL_SPEC, 2> {
                RPTL1_W::new(self)
            }
            #[doc = "Bit 3 - State when not transmitting on channel 1"]
            #[inline(always)]
            #[must_use]
            pub fn sbit1(&mut self) -> SBIT1_W<CTL_SPEC, 3> {
                SBIT1_W::new(self)
            }
            #[doc = "Bit 4 - Channel 1 polarity inverted"]
            #[inline(always)]
            #[must_use]
            pub fn pola1(&mut self) -> POLA1_W<CTL_SPEC, 4> {
                POLA1_W::new(self)
            }
            #[doc = "Bit 5 - Use FIFO for channel 1"]
            #[inline(always)]
            #[must_use]
            pub fn usef1(&mut self) -> USEF1_W<CTL_SPEC, 5> {
                USEF1_W::new(self)
            }
            #[doc = "Bit 6 - Clear FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn clrf1(&mut self) -> CLRF1_W<CTL_SPEC, 6> {
                CLRF1_W::new(self)
            }
            #[doc = "Bit 7 - M/S mode for channel 1"]
            #[inline(always)]
            #[must_use]
            pub fn msen1(&mut self) -> MSEN1_W<CTL_SPEC, 7> {
                MSEN1_W::new(self)
            }
            #[doc = "Bit 8 - Enable channel 2"]
            #[inline(always)]
            #[must_use]
            pub fn pwen2(&mut self) -> PWEN2_W<CTL_SPEC, 8> {
                PWEN2_W::new(self)
            }
            #[doc = "Bit 9 - Channel 2 mode"]
            #[inline(always)]
            #[must_use]
            pub fn mode2(&mut self) -> MODE2_W<CTL_SPEC, 9> {
                MODE2_W::new(self)
            }
            #[doc = "Bit 10 - Repeat last value from FIFO for channel 2"]
            #[inline(always)]
            #[must_use]
            pub fn rptl2(&mut self) -> RPTL2_W<CTL_SPEC, 10> {
                RPTL2_W::new(self)
            }
            #[doc = "Bit 11 - State when not transmitting on channel 2"]
            #[inline(always)]
            #[must_use]
            pub fn sbit2(&mut self) -> SBIT2_W<CTL_SPEC, 11> {
                SBIT2_W::new(self)
            }
            #[doc = "Bit 12 - Channel 2 polarity inverted"]
            #[inline(always)]
            #[must_use]
            pub fn pola2(&mut self) -> POLA2_W<CTL_SPEC, 12> {
                POLA2_W::new(self)
            }
            #[doc = "Bit 13 - Use FIFO for channel 2"]
            #[inline(always)]
            #[must_use]
            pub fn usef2(&mut self) -> USEF2_W<CTL_SPEC, 13> {
                USEF2_W::new(self)
            }
            #[doc = "Bit 15 - M/S mode for channel 2"]
            #[inline(always)]
            #[must_use]
            pub fn msen2(&mut self) -> MSEN2_W<CTL_SPEC, 15> {
                MSEN2_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CTL_SPEC;
        impl crate::RegisterSpec for CTL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctl::R`](R) reader structure"]
        impl crate::Readable for CTL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ctl::W`](W) writer structure"]
        impl crate::Writable for CTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CTL to value 0"]
        impl crate::Resettable for CTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "STA (rw) register accessor: Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sta::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sta::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sta`]
module"]
    pub type STA = crate::Reg<sta::STA_SPEC>;
    #[doc = "Status"]
    pub mod sta {
        #[doc = "Register `STA` reader"]
        pub type R = crate::R<STA_SPEC>;
        #[doc = "Register `STA` writer"]
        pub type W = crate::W<STA_SPEC>;
        #[doc = "Field `FULL1` reader - FIFO full"]
        pub type FULL1_R = crate::BitReader;
        #[doc = "Field `FULL1` writer - FIFO full"]
        pub type FULL1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EMPT1` reader - FIFO empty"]
        pub type EMPT1_R = crate::BitReader;
        #[doc = "Field `EMPT1` writer - FIFO empty"]
        pub type EMPT1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WERR1` reader - FIFO write error"]
        pub type WERR1_R = crate::BitReader;
        #[doc = "Field `WERR1` writer - FIFO write error"]
        pub type WERR1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RERR1` reader - FIFO read error"]
        pub type RERR1_R = crate::BitReader;
        #[doc = "Field `RERR1` writer - FIFO read error"]
        pub type RERR1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GAPO1` reader - Channel 1 gap occurred"]
        pub type GAPO1_R = crate::BitReader;
        #[doc = "Field `GAPO1` writer - Channel 1 gap occurred"]
        pub type GAPO1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GAPO2` reader - Channel 2 gap occurred"]
        pub type GAPO2_R = crate::BitReader;
        #[doc = "Field `GAPO2` writer - Channel 2 gap occurred"]
        pub type GAPO2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GAPO3` reader - Channel 3 gap occurred"]
        pub type GAPO3_R = crate::BitReader;
        #[doc = "Field `GAPO3` writer - Channel 3 gap occurred"]
        pub type GAPO3_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GAPO4` reader - Channel 4 gap occurred"]
        pub type GAPO4_R = crate::BitReader;
        #[doc = "Field `GAPO4` writer - Channel 4 gap occurred"]
        pub type GAPO4_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BERR` reader - Bus error"]
        pub type BERR_R = crate::BitReader;
        #[doc = "Field `BERR` writer - Bus error"]
        pub type BERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `STA1` reader - Channel 1 state"]
        pub type STA1_R = crate::BitReader;
        #[doc = "Field `STA1` writer - Channel 1 state"]
        pub type STA1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `STA2` reader - Channel 2 state"]
        pub type STA2_R = crate::BitReader;
        #[doc = "Field `STA2` writer - Channel 2 state"]
        pub type STA2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `STA3` reader - Channel 3 state"]
        pub type STA3_R = crate::BitReader;
        #[doc = "Field `STA3` writer - Channel 3 state"]
        pub type STA3_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `STA4` reader - Channel 4 state"]
        pub type STA4_R = crate::BitReader;
        #[doc = "Field `STA4` writer - Channel 4 state"]
        pub type STA4_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - FIFO full"]
            #[inline(always)]
            pub fn full1(&self) -> FULL1_R {
                FULL1_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - FIFO empty"]
            #[inline(always)]
            pub fn empt1(&self) -> EMPT1_R {
                EMPT1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - FIFO write error"]
            #[inline(always)]
            pub fn werr1(&self) -> WERR1_R {
                WERR1_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - FIFO read error"]
            #[inline(always)]
            pub fn rerr1(&self) -> RERR1_R {
                RERR1_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Channel 1 gap occurred"]
            #[inline(always)]
            pub fn gapo1(&self) -> GAPO1_R {
                GAPO1_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Channel 2 gap occurred"]
            #[inline(always)]
            pub fn gapo2(&self) -> GAPO2_R {
                GAPO2_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Channel 3 gap occurred"]
            #[inline(always)]
            pub fn gapo3(&self) -> GAPO3_R {
                GAPO3_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Channel 4 gap occurred"]
            #[inline(always)]
            pub fn gapo4(&self) -> GAPO4_R {
                GAPO4_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Bus error"]
            #[inline(always)]
            pub fn berr(&self) -> BERR_R {
                BERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Channel 1 state"]
            #[inline(always)]
            pub fn sta1(&self) -> STA1_R {
                STA1_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Channel 2 state"]
            #[inline(always)]
            pub fn sta2(&self) -> STA2_R {
                STA2_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Channel 3 state"]
            #[inline(always)]
            pub fn sta3(&self) -> STA3_R {
                STA3_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Channel 4 state"]
            #[inline(always)]
            pub fn sta4(&self) -> STA4_R {
                STA4_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STA")
                    .field("sta4", &format_args!("{}", self.sta4().bit()))
                    .field("sta3", &format_args!("{}", self.sta3().bit()))
                    .field("sta2", &format_args!("{}", self.sta2().bit()))
                    .field("sta1", &format_args!("{}", self.sta1().bit()))
                    .field("berr", &format_args!("{}", self.berr().bit()))
                    .field("gapo4", &format_args!("{}", self.gapo4().bit()))
                    .field("gapo3", &format_args!("{}", self.gapo3().bit()))
                    .field("gapo2", &format_args!("{}", self.gapo2().bit()))
                    .field("gapo1", &format_args!("{}", self.gapo1().bit()))
                    .field("rerr1", &format_args!("{}", self.rerr1().bit()))
                    .field("werr1", &format_args!("{}", self.werr1().bit()))
                    .field("empt1", &format_args!("{}", self.empt1().bit()))
                    .field("full1", &format_args!("{}", self.full1().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<STA_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - FIFO full"]
            #[inline(always)]
            #[must_use]
            pub fn full1(&mut self) -> FULL1_W<STA_SPEC, 0> {
                FULL1_W::new(self)
            }
            #[doc = "Bit 1 - FIFO empty"]
            #[inline(always)]
            #[must_use]
            pub fn empt1(&mut self) -> EMPT1_W<STA_SPEC, 1> {
                EMPT1_W::new(self)
            }
            #[doc = "Bit 2 - FIFO write error"]
            #[inline(always)]
            #[must_use]
            pub fn werr1(&mut self) -> WERR1_W<STA_SPEC, 2> {
                WERR1_W::new(self)
            }
            #[doc = "Bit 3 - FIFO read error"]
            #[inline(always)]
            #[must_use]
            pub fn rerr1(&mut self) -> RERR1_W<STA_SPEC, 3> {
                RERR1_W::new(self)
            }
            #[doc = "Bit 4 - Channel 1 gap occurred"]
            #[inline(always)]
            #[must_use]
            pub fn gapo1(&mut self) -> GAPO1_W<STA_SPEC, 4> {
                GAPO1_W::new(self)
            }
            #[doc = "Bit 5 - Channel 2 gap occurred"]
            #[inline(always)]
            #[must_use]
            pub fn gapo2(&mut self) -> GAPO2_W<STA_SPEC, 5> {
                GAPO2_W::new(self)
            }
            #[doc = "Bit 6 - Channel 3 gap occurred"]
            #[inline(always)]
            #[must_use]
            pub fn gapo3(&mut self) -> GAPO3_W<STA_SPEC, 6> {
                GAPO3_W::new(self)
            }
            #[doc = "Bit 7 - Channel 4 gap occurred"]
            #[inline(always)]
            #[must_use]
            pub fn gapo4(&mut self) -> GAPO4_W<STA_SPEC, 7> {
                GAPO4_W::new(self)
            }
            #[doc = "Bit 8 - Bus error"]
            #[inline(always)]
            #[must_use]
            pub fn berr(&mut self) -> BERR_W<STA_SPEC, 8> {
                BERR_W::new(self)
            }
            #[doc = "Bit 9 - Channel 1 state"]
            #[inline(always)]
            #[must_use]
            pub fn sta1(&mut self) -> STA1_W<STA_SPEC, 9> {
                STA1_W::new(self)
            }
            #[doc = "Bit 10 - Channel 2 state"]
            #[inline(always)]
            #[must_use]
            pub fn sta2(&mut self) -> STA2_W<STA_SPEC, 10> {
                STA2_W::new(self)
            }
            #[doc = "Bit 11 - Channel 3 state"]
            #[inline(always)]
            #[must_use]
            pub fn sta3(&mut self) -> STA3_W<STA_SPEC, 11> {
                STA3_W::new(self)
            }
            #[doc = "Bit 12 - Channel 4 state"]
            #[inline(always)]
            #[must_use]
            pub fn sta4(&mut self) -> STA4_W<STA_SPEC, 12> {
                STA4_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sta::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sta::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STA_SPEC;
        impl crate::RegisterSpec for STA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sta::R`](R) reader structure"]
        impl crate::Readable for STA_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`sta::W`](W) writer structure"]
        impl crate::Writable for STA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets STA to value 0"]
        impl crate::Resettable for STA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DMAC (rw) register accessor: DMA control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dmac::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmac::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmac`]
module"]
    pub type DMAC = crate::Reg<dmac::DMAC_SPEC>;
    #[doc = "DMA control"]
    pub mod dmac {
        #[doc = "Register `DMAC` reader"]
        pub type R = crate::R<DMAC_SPEC>;
        #[doc = "Register `DMAC` writer"]
        pub type W = crate::W<DMAC_SPEC>;
        #[doc = "Field `DREQ` reader - DMA threshold for DREQ signal"]
        pub type DREQ_R = crate::FieldReader;
        #[doc = "Field `DREQ` writer - DMA threshold for DREQ signal"]
        pub type DREQ_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `PANIC` reader - DMA threshold for panic signal"]
        pub type PANIC_R = crate::FieldReader;
        #[doc = "Field `PANIC` writer - DMA threshold for panic signal"]
        pub type PANIC_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `ENAB` reader - DMA enabled"]
        pub type ENAB_R = crate::BitReader;
        #[doc = "Field `ENAB` writer - DMA enabled"]
        pub type ENAB_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bits 0:7 - DMA threshold for DREQ signal"]
            #[inline(always)]
            pub fn dreq(&self) -> DREQ_R {
                DREQ_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - DMA threshold for panic signal"]
            #[inline(always)]
            pub fn panic(&self) -> PANIC_R {
                PANIC_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bit 31 - DMA enabled"]
            #[inline(always)]
            pub fn enab(&self) -> ENAB_R {
                ENAB_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DMAC")
                    .field("enab", &format_args!("{}", self.enab().bit()))
                    .field("panic", &format_args!("{}", self.panic().bits()))
                    .field("dreq", &format_args!("{}", self.dreq().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DMAC_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DMA threshold for DREQ signal"]
            #[inline(always)]
            #[must_use]
            pub fn dreq(&mut self) -> DREQ_W<DMAC_SPEC, 0> {
                DREQ_W::new(self)
            }
            #[doc = "Bits 8:15 - DMA threshold for panic signal"]
            #[inline(always)]
            #[must_use]
            pub fn panic(&mut self) -> PANIC_W<DMAC_SPEC, 8> {
                PANIC_W::new(self)
            }
            #[doc = "Bit 31 - DMA enabled"]
            #[inline(always)]
            #[must_use]
            pub fn enab(&mut self) -> ENAB_W<DMAC_SPEC, 31> {
                ENAB_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "DMA control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dmac::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmac::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DMAC_SPEC;
        impl crate::RegisterSpec for DMAC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dmac::R`](R) reader structure"]
        impl crate::Readable for DMAC_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dmac::W`](W) writer structure"]
        impl crate::Writable for DMAC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DMAC to value 0"]
        impl crate::Resettable for DMAC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RNG1 (rw) register accessor: Range for channel 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rng1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rng1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rng1`]
module"]
    pub type RNG1 = crate::Reg<rng1::RNG1_SPEC>;
    #[doc = "Range for channel 1"]
    pub mod rng1 {
        #[doc = "Register `RNG1` reader"]
        pub type R = crate::R<RNG1_SPEC>;
        #[doc = "Register `RNG1` writer"]
        pub type W = crate::W<RNG1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RNG1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Range for channel 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rng1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rng1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RNG1_SPEC;
        impl crate::RegisterSpec for RNG1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rng1::R`](R) reader structure"]
        impl crate::Readable for RNG1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`rng1::W`](W) writer structure"]
        impl crate::Writable for RNG1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets RNG1 to value 0x20"]
        impl crate::Resettable for RNG1_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    #[doc = "DAT1 (rw) register accessor: Channel 1 data\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dat1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dat1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat1`]
module"]
    pub type DAT1 = crate::Reg<dat1::DAT1_SPEC>;
    #[doc = "Channel 1 data"]
    pub mod dat1 {
        #[doc = "Register `DAT1` reader"]
        pub type R = crate::R<DAT1_SPEC>;
        #[doc = "Register `DAT1` writer"]
        pub type W = crate::W<DAT1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DAT1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Channel 1 data\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dat1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dat1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DAT1_SPEC;
        impl crate::RegisterSpec for DAT1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat1::R`](R) reader structure"]
        impl crate::Readable for DAT1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dat1::W`](W) writer structure"]
        impl crate::Writable for DAT1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DAT1 to value 0"]
        impl crate::Resettable for DAT1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "FIF1 (w) register accessor: FIFO input\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fif1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fif1`]
module"]
    pub type FIF1 = crate::Reg<fif1::FIF1_SPEC>;
    #[doc = "FIFO input"]
    pub mod fif1 {
        #[doc = "Register `FIF1` writer"]
        pub type W = crate::W<FIF1_SPEC>;
        impl core::fmt::Debug for crate::generic::Reg<FIF1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "(not readable)")
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "FIFO input\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fif1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FIF1_SPEC;
        impl crate::RegisterSpec for FIF1_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`fif1::W`](W) writer structure"]
        impl crate::Writable for FIF1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets FIF1 to value 0"]
        impl crate::Resettable for FIF1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RNG2 (rw) register accessor: Range for channel 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rng2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rng2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rng2`]
module"]
    pub type RNG2 = crate::Reg<rng2::RNG2_SPEC>;
    #[doc = "Range for channel 2"]
    pub mod rng2 {
        #[doc = "Register `RNG2` reader"]
        pub type R = crate::R<RNG2_SPEC>;
        #[doc = "Register `RNG2` writer"]
        pub type W = crate::W<RNG2_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RNG2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Range for channel 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rng2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rng2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RNG2_SPEC;
        impl crate::RegisterSpec for RNG2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rng2::R`](R) reader structure"]
        impl crate::Readable for RNG2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`rng2::W`](W) writer structure"]
        impl crate::Writable for RNG2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets RNG2 to value 0x20"]
        impl crate::Resettable for RNG2_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    #[doc = "DAT2 (rw) register accessor: Channel 2 data\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dat2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dat2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dat2`]
module"]
    pub type DAT2 = crate::Reg<dat2::DAT2_SPEC>;
    #[doc = "Channel 2 data"]
    pub mod dat2 {
        #[doc = "Register `DAT2` reader"]
        pub type R = crate::R<DAT2_SPEC>;
        #[doc = "Register `DAT2` writer"]
        pub type W = crate::W<DAT2_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DAT2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Channel 2 data\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dat2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dat2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DAT2_SPEC;
        impl crate::RegisterSpec for DAT2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dat2::R`](R) reader structure"]
        impl crate::Readable for DAT2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dat2::W`](W) writer structure"]
        impl crate::Writable for DAT2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DAT2 to value 0"]
        impl crate::Resettable for DAT2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Broadcom Serial Controller (I2C compatible)"]
pub struct BSC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BSC1 {}
impl BSC1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bsc0::RegisterBlock = 0x2080_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bsc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BSC1 {
    type Target = bsc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BSC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BSC1").finish()
    }
}
#[doc = "Broadcom Serial Controller (I2C compatible)"]
pub use self::bsc0 as bsc1;
#[doc = "Broadcom Serial Controller (I2C compatible)"]
pub struct BSC2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BSC2 {}
impl BSC2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bsc0::RegisterBlock = 0x2080_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bsc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BSC2 {
    type Target = bsc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BSC2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BSC2").finish()
    }
}
#[doc = "Broadcom Serial Controller (I2C compatible)"]
pub use self::bsc0 as bsc2;
#[doc = "Three auxiliary peripherals"]
pub struct AUX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX {}
impl AUX {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux::RegisterBlock = 0x2021_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AUX {
    type Target = aux::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX").finish()
    }
}
#[doc = "Three auxiliary peripherals"]
pub mod aux {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt status"]
        pub irq: IRQ,
        #[doc = "0x04 - Enable sub-peripherals"]
        pub enables: ENABLES,
    }
    #[doc = "IRQ (rw) register accessor: Interrupt status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`irq::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irq::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irq`]
module"]
    pub type IRQ = crate::Reg<irq::IRQ_SPEC>;
    #[doc = "Interrupt status"]
    pub mod irq {
        #[doc = "Register `IRQ` reader"]
        pub type R = crate::R<IRQ_SPEC>;
        #[doc = "Register `IRQ` writer"]
        pub type W = crate::W<IRQ_SPEC>;
        #[doc = "Field `UART_1` reader - UART1 interrupt active"]
        pub type UART_1_R = crate::BitReader;
        #[doc = "Field `UART_1` writer - UART1 interrupt active"]
        pub type UART_1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SPI_1` reader - SPI1 interrupt active"]
        pub type SPI_1_R = crate::BitReader;
        #[doc = "Field `SPI_1` writer - SPI1 interrupt active"]
        pub type SPI_1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SPI_2` reader - SPI2 interrupt active"]
        pub type SPI_2_R = crate::BitReader;
        #[doc = "Field `SPI_2` writer - SPI2 interrupt active"]
        pub type SPI_2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - UART1 interrupt active"]
            #[inline(always)]
            pub fn uart_1(&self) -> UART_1_R {
                UART_1_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - SPI1 interrupt active"]
            #[inline(always)]
            pub fn spi_1(&self) -> SPI_1_R {
                SPI_1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - SPI2 interrupt active"]
            #[inline(always)]
            pub fn spi_2(&self) -> SPI_2_R {
                SPI_2_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IRQ")
                    .field("spi_2", &format_args!("{}", self.spi_2().bit()))
                    .field("spi_1", &format_args!("{}", self.spi_1().bit()))
                    .field("uart_1", &format_args!("{}", self.uart_1().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IRQ_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - UART1 interrupt active"]
            #[inline(always)]
            #[must_use]
            pub fn uart_1(&mut self) -> UART_1_W<IRQ_SPEC, 0> {
                UART_1_W::new(self)
            }
            #[doc = "Bit 1 - SPI1 interrupt active"]
            #[inline(always)]
            #[must_use]
            pub fn spi_1(&mut self) -> SPI_1_W<IRQ_SPEC, 1> {
                SPI_1_W::new(self)
            }
            #[doc = "Bit 2 - SPI2 interrupt active"]
            #[inline(always)]
            #[must_use]
            pub fn spi_2(&mut self) -> SPI_2_W<IRQ_SPEC, 2> {
                SPI_2_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`irq::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irq::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IRQ_SPEC;
        impl crate::RegisterSpec for IRQ_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`irq::R`](R) reader structure"]
        impl crate::Readable for IRQ_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`irq::W`](W) writer structure"]
        impl crate::Writable for IRQ_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IRQ to value 0"]
        impl crate::Resettable for IRQ_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ENABLES (rw) register accessor: Enable sub-peripherals\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enables::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enables::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enables`]
module"]
    pub type ENABLES = crate::Reg<enables::ENABLES_SPEC>;
    #[doc = "Enable sub-peripherals"]
    pub mod enables {
        #[doc = "Register `ENABLES` reader"]
        pub type R = crate::R<ENABLES_SPEC>;
        #[doc = "Register `ENABLES` writer"]
        pub type W = crate::W<ENABLES_SPEC>;
        #[doc = "Field `UART_1` reader - UART1 enabled"]
        pub type UART_1_R = crate::BitReader;
        #[doc = "Field `UART_1` writer - UART1 enabled"]
        pub type UART_1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SPI_1` reader - SPI1 enabled"]
        pub type SPI_1_R = crate::BitReader;
        #[doc = "Field `SPI_1` writer - SPI1 enabled"]
        pub type SPI_1_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SPI_2` reader - SPI2 enabled"]
        pub type SPI_2_R = crate::BitReader;
        #[doc = "Field `SPI_2` writer - SPI2 enabled"]
        pub type SPI_2_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - UART1 enabled"]
            #[inline(always)]
            pub fn uart_1(&self) -> UART_1_R {
                UART_1_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - SPI1 enabled"]
            #[inline(always)]
            pub fn spi_1(&self) -> SPI_1_R {
                SPI_1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - SPI2 enabled"]
            #[inline(always)]
            pub fn spi_2(&self) -> SPI_2_R {
                SPI_2_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ENABLES")
                    .field("spi_2", &format_args!("{}", self.spi_2().bit()))
                    .field("spi_1", &format_args!("{}", self.spi_1().bit()))
                    .field("uart_1", &format_args!("{}", self.uart_1().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<ENABLES_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - UART1 enabled"]
            #[inline(always)]
            #[must_use]
            pub fn uart_1(&mut self) -> UART_1_W<ENABLES_SPEC, 0> {
                UART_1_W::new(self)
            }
            #[doc = "Bit 1 - SPI1 enabled"]
            #[inline(always)]
            #[must_use]
            pub fn spi_1(&mut self) -> SPI_1_W<ENABLES_SPEC, 1> {
                SPI_1_W::new(self)
            }
            #[doc = "Bit 2 - SPI2 enabled"]
            #[inline(always)]
            #[must_use]
            pub fn spi_2(&mut self) -> SPI_2_W<ENABLES_SPEC, 2> {
                SPI_2_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Enable sub-peripherals\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enables::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enables::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ENABLES_SPEC;
        impl crate::RegisterSpec for ENABLES_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`enables::R`](R) reader structure"]
        impl crate::Readable for ENABLES_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`enables::W`](W) writer structure"]
        impl crate::Writable for ENABLES_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ENABLES to value 0"]
        impl crate::Resettable for ENABLES_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Mini UART"]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart1::RegisterBlock = 0x2021_5040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
#[doc = "Mini UART"]
pub mod uart1 {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        _reserved_0_io: [u8; 0x04],
        _reserved_1_ier: [u8; 0x04],
        #[doc = "0x08 - Interrupt Identify"]
        pub iir: IIR,
        #[doc = "0x0c - Line control"]
        pub lcr: LCR,
        #[doc = "0x10 - Modem Control"]
        pub mcr: MCR,
        #[doc = "0x14 - Line Status"]
        pub lsr: LSR,
        #[doc = "0x18 - Modem Status"]
        pub msr: MSR,
        #[doc = "0x1c - Scratch"]
        pub scratch: SCRATCH,
        _reserved8: [u8; 0x03],
        #[doc = "0x20 - Control"]
        pub cntl: CNTL,
        #[doc = "0x24 - Status"]
        pub stat: STAT,
        #[doc = "0x28 - Baudrate"]
        pub baud: BAUD,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Lower bits of baudrate when DLAB is set"]
        #[inline(always)]
        pub const fn baudl(&self) -> &BAUDL {
            unsafe { &*(self as *const Self).cast::<u8>().add(0usize).cast() }
        }
        #[doc = "0x00 - I/O Data"]
        #[inline(always)]
        pub const fn io(&self) -> &IO {
            unsafe { &*(self as *const Self).cast::<u8>().add(0usize).cast() }
        }
        #[doc = "0x04 - High bits of baudrate when DLAB is set"]
        #[inline(always)]
        pub const fn baudh(&self) -> &BAUDH {
            unsafe { &*(self as *const Self).cast::<u8>().add(4usize).cast() }
        }
        #[doc = "0x04 - Interrupt Enable"]
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            unsafe { &*(self as *const Self).cast::<u8>().add(4usize).cast() }
        }
    }
    #[doc = "IO (rw) register accessor: I/O Data\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`io::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`io::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@io`]
module"]
    pub type IO = crate::Reg<io::IO_SPEC>;
    #[doc = "I/O Data"]
    pub mod io {
        #[doc = "Register `IO` reader"]
        pub type R = crate::R<IO_SPEC>;
        #[doc = "Register `IO` writer"]
        pub type W = crate::W<IO_SPEC>;
        #[doc = "Field `DATA` reader - FIFO access"]
        pub type DATA_R = crate::FieldReader;
        #[doc = "Field `DATA` writer - FIFO access"]
        pub type DATA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        impl R {
            #[doc = "Bits 0:7 - FIFO access"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IO")
                    .field("data", &format_args!("{}", self.data().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IO_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - FIFO access"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<IO_SPEC, 0> {
                DATA_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "I/O Data\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`io::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`io::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IO_SPEC;
        impl crate::RegisterSpec for IO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`io::R`](R) reader structure"]
        impl crate::Readable for IO_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`io::W`](W) writer structure"]
        impl crate::Writable for IO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IO to value 0"]
        impl crate::Resettable for IO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "BAUDL (rw) register accessor: Lower bits of baudrate when DLAB is set\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`baudl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`baudl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@baudl`]
module"]
    pub type BAUDL = crate::Reg<baudl::BAUDL_SPEC>;
    #[doc = "Lower bits of baudrate when DLAB is set"]
    pub mod baudl {
        #[doc = "Register `BAUDL` reader"]
        pub type R = crate::R<BAUDL_SPEC>;
        #[doc = "Register `BAUDL` writer"]
        pub type W = crate::W<BAUDL_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<BAUDL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Lower bits of baudrate when DLAB is set\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`baudl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`baudl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BAUDL_SPEC;
        impl crate::RegisterSpec for BAUDL_SPEC {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`baudl::R`](R) reader structure"]
        impl crate::Readable for BAUDL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`baudl::W`](W) writer structure"]
        impl crate::Writable for BAUDL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets BAUDL to value 0"]
        impl crate::Resettable for BAUDL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IER (rw) register accessor: Interrupt Enable\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`]
module"]
    pub type IER = crate::Reg<ier::IER_SPEC>;
    #[doc = "Interrupt Enable"]
    pub mod ier {
        #[doc = "Register `IER` reader"]
        pub type R = crate::R<IER_SPEC>;
        #[doc = "Register `IER` writer"]
        pub type W = crate::W<IER_SPEC>;
        #[doc = "Field `DATA_READY` reader - Receive FIFO has at least 1 byte"]
        pub type DATA_READY_R = crate::BitReader;
        #[doc = "Field `DATA_READY` writer - Receive FIFO has at least 1 byte"]
        pub type DATA_READY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_READY` reader - Transmit FIFO is empty"]
        pub type TX_READY_R = crate::BitReader;
        #[doc = "Field `TX_READY` writer - Transmit FIFO is empty"]
        pub type TX_READY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Receive FIFO has at least 1 byte"]
            #[inline(always)]
            pub fn data_ready(&self) -> DATA_READY_R {
                DATA_READY_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Transmit FIFO is empty"]
            #[inline(always)]
            pub fn tx_ready(&self) -> TX_READY_R {
                TX_READY_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IER")
                    .field("tx_ready", &format_args!("{}", self.tx_ready().bit()))
                    .field("data_ready", &format_args!("{}", self.data_ready().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IER_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Receive FIFO has at least 1 byte"]
            #[inline(always)]
            #[must_use]
            pub fn data_ready(&mut self) -> DATA_READY_W<IER_SPEC, 0> {
                DATA_READY_W::new(self)
            }
            #[doc = "Bit 1 - Transmit FIFO is empty"]
            #[inline(always)]
            #[must_use]
            pub fn tx_ready(&mut self) -> TX_READY_W<IER_SPEC, 1> {
                TX_READY_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt Enable\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ier::R`](R) reader structure"]
        impl crate::Readable for IER_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IER to value 0"]
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "BAUDH (rw) register accessor: High bits of baudrate when DLAB is set\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`baudh::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`baudh::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@baudh`]
module"]
    pub type BAUDH = crate::Reg<baudh::BAUDH_SPEC>;
    #[doc = "High bits of baudrate when DLAB is set"]
    pub mod baudh {
        #[doc = "Register `BAUDH` reader"]
        pub type R = crate::R<BAUDH_SPEC>;
        #[doc = "Register `BAUDH` writer"]
        pub type W = crate::W<BAUDH_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<BAUDH_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "High bits of baudrate when DLAB is set\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`baudh::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`baudh::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BAUDH_SPEC;
        impl crate::RegisterSpec for BAUDH_SPEC {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`baudh::R`](R) reader structure"]
        impl crate::Readable for BAUDH_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`baudh::W`](W) writer structure"]
        impl crate::Writable for BAUDH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets BAUDH to value 0"]
        impl crate::Resettable for BAUDH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IIR (rw) register accessor: Interrupt Identify\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`]
module"]
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    #[doc = "Interrupt Identify"]
    pub mod iir {
        #[doc = "Register `IIR` reader"]
        pub type R = crate::R<IIR_SPEC>;
        #[doc = "Register `IIR` writer"]
        pub type W = crate::W<IIR_SPEC>;
        #[doc = "Field `nPENDING` reader - No pending interrupt"]
        pub type N_PENDING_R = crate::BitReader;
        #[doc = "Field `nPENDING` writer - No pending interrupt"]
        pub type N_PENDING_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DATA_READY` reader - Receive FIFO has at least 1 byte"]
        pub type DATA_READY_R = crate::BitReader;
        #[doc = "Field `DATA_READY` writer - Receive FIFO has at least 1 byte"]
        pub type DATA_READY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_READY` reader - Transmit FIFO is empty"]
        pub type TX_READY_R = crate::BitReader;
        #[doc = "Field `TX_READY` writer - Transmit FIFO is empty"]
        pub type TX_READY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - No pending interrupt"]
            #[inline(always)]
            pub fn n_pending(&self) -> N_PENDING_R {
                N_PENDING_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Receive FIFO has at least 1 byte"]
            #[inline(always)]
            pub fn data_ready(&self) -> DATA_READY_R {
                DATA_READY_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Transmit FIFO is empty"]
            #[inline(always)]
            pub fn tx_ready(&self) -> TX_READY_R {
                TX_READY_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IIR")
                    .field("tx_ready", &format_args!("{}", self.tx_ready().bit()))
                    .field("data_ready", &format_args!("{}", self.data_ready().bit()))
                    .field("n_pending", &format_args!("{}", self.n_pending().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IIR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - No pending interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn n_pending(&mut self) -> N_PENDING_W<IIR_SPEC, 0> {
                N_PENDING_W::new(self)
            }
            #[doc = "Bit 1 - Receive FIFO has at least 1 byte"]
            #[inline(always)]
            #[must_use]
            pub fn data_ready(&mut self) -> DATA_READY_W<IIR_SPEC, 1> {
                DATA_READY_W::new(self)
            }
            #[doc = "Bit 2 - Transmit FIFO is empty"]
            #[inline(always)]
            #[must_use]
            pub fn tx_ready(&mut self) -> TX_READY_W<IIR_SPEC, 2> {
                TX_READY_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt Identify\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iir::R`](R) reader structure"]
        impl crate::Readable for IIR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`iir::W`](W) writer structure"]
        impl crate::Writable for IIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IIR to value 0xb001"]
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0xb001;
        }
    }
    #[doc = "LCR (rw) register accessor: Line control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`]
module"]
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    #[doc = "Line control"]
    pub mod lcr {
        #[doc = "Register `LCR` reader"]
        pub type R = crate::R<LCR_SPEC>;
        #[doc = "Register `LCR` writer"]
        pub type W = crate::W<LCR_SPEC>;
        #[doc = "Field `DATA_SIZE` reader - UART word size"]
        pub type DATA_SIZE_R = crate::FieldReader<MODE_A>;
        #[doc = "UART word size\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MODE_A {
            #[doc = "0: 7 bit"]
            _7BIT = 0,
            #[doc = "3: 8 bit"]
            _8BIT = 3,
        }
        impl From<MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for MODE_A {
            type Ux = u8;
        }
        impl DATA_SIZE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<MODE_A> {
                match self.bits {
                    0 => Some(MODE_A::_7BIT),
                    3 => Some(MODE_A::_8BIT),
                    _ => None,
                }
            }
            #[doc = "7 bit"]
            #[inline(always)]
            pub fn is_7bit(&self) -> bool {
                *self == MODE_A::_7BIT
            }
            #[doc = "8 bit"]
            #[inline(always)]
            pub fn is_8bit(&self) -> bool {
                *self == MODE_A::_8BIT
            }
        }
        #[doc = "Field `DATA_SIZE` writer - UART word size"]
        pub type DATA_SIZE_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O, MODE_A>;
        impl<'a, REG, const O: u8> DATA_SIZE_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "7 bit"]
            #[inline(always)]
            pub fn _7bit(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A::_7BIT)
            }
            #[doc = "8 bit"]
            #[inline(always)]
            pub fn _8bit(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A::_8BIT)
            }
        }
        #[doc = "Field `BREAK` reader - Pull TX low continuously to send break"]
        pub type BREAK_R = crate::BitReader;
        #[doc = "Field `BREAK` writer - Pull TX low continuously to send break"]
        pub type BREAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DLAB` reader - First two registers are baudrate"]
        pub type DLAB_R = crate::BitReader;
        #[doc = "Field `DLAB` writer - First two registers are baudrate"]
        pub type DLAB_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bits 0:1 - UART word size"]
            #[inline(always)]
            pub fn data_size(&self) -> DATA_SIZE_R {
                DATA_SIZE_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 6 - Pull TX low continuously to send break"]
            #[inline(always)]
            pub fn break_(&self) -> BREAK_R {
                BREAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - First two registers are baudrate"]
            #[inline(always)]
            pub fn dlab(&self) -> DLAB_R {
                DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LCR")
                    .field("dlab", &format_args!("{}", self.dlab().bit()))
                    .field("break_", &format_args!("{}", self.break_().bit()))
                    .field("data_size", &format_args!("{}", self.data_size().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<LCR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - UART word size"]
            #[inline(always)]
            #[must_use]
            pub fn data_size(&mut self) -> DATA_SIZE_W<LCR_SPEC, 0> {
                DATA_SIZE_W::new(self)
            }
            #[doc = "Bit 6 - Pull TX low continuously to send break"]
            #[inline(always)]
            #[must_use]
            pub fn break_(&mut self) -> BREAK_W<LCR_SPEC, 6> {
                BREAK_W::new(self)
            }
            #[doc = "Bit 7 - First two registers are baudrate"]
            #[inline(always)]
            #[must_use]
            pub fn dlab(&mut self) -> DLAB_W<LCR_SPEC, 7> {
                DLAB_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Line control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lcr::R`](R) reader structure"]
        impl crate::Readable for LCR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"]
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets LCR to value 0"]
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "MCR (rw) register accessor: Modem Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`]
module"]
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    #[doc = "Modem Control"]
    pub mod mcr {
        #[doc = "Register `MCR` reader"]
        pub type R = crate::R<MCR_SPEC>;
        #[doc = "Register `MCR` writer"]
        pub type W = crate::W<MCR_SPEC>;
        #[doc = "Field `RTS` reader - RTS is low"]
        pub type RTS_R = crate::BitReader;
        #[doc = "Field `RTS` writer - RTS is low"]
        pub type RTS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 1 - RTS is low"]
            #[inline(always)]
            pub fn rts(&self) -> RTS_R {
                RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MCR")
                    .field("rts", &format_args!("{}", self.rts().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<MCR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - RTS is low"]
            #[inline(always)]
            #[must_use]
            pub fn rts(&mut self) -> RTS_W<MCR_SPEC, 1> {
                RTS_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Modem Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mcr::R`](R) reader structure"]
        impl crate::Readable for MCR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"]
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets MCR to value 0"]
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "LSR (rw) register accessor: Line Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lsr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`]
module"]
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    #[doc = "Line Status"]
    pub mod lsr {
        #[doc = "Register `LSR` reader"]
        pub type R = crate::R<LSR_SPEC>;
        #[doc = "Register `LSR` writer"]
        pub type W = crate::W<LSR_SPEC>;
        #[doc = "Field `DATA_READY` reader - Receive FIFO has at least one byte"]
        pub type DATA_READY_R = crate::BitReader;
        #[doc = "Field `DATA_READY` writer - Receive FIFO has at least one byte"]
        pub type DATA_READY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RX_OVERRUN` reader - Receive FIFO overrun"]
        pub type RX_OVERRUN_R = crate::BitReader;
        #[doc = "Field `RX_OVERRUN` writer - Receive FIFO overrun"]
        pub type RX_OVERRUN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_EMPTY` reader - Transmit FIFO has room for at least one byte"]
        pub type TX_EMPTY_R = crate::BitReader;
        #[doc = "Field `TX_EMPTY` writer - Transmit FIFO has room for at least one byte"]
        pub type TX_EMPTY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_IDLE` reader - Transmit FIFO empty and all bits shifted out"]
        pub type TX_IDLE_R = crate::BitReader;
        #[doc = "Field `TX_IDLE` writer - Transmit FIFO empty and all bits shifted out"]
        pub type TX_IDLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Receive FIFO has at least one byte"]
            #[inline(always)]
            pub fn data_ready(&self) -> DATA_READY_R {
                DATA_READY_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Receive FIFO overrun"]
            #[inline(always)]
            pub fn rx_overrun(&self) -> RX_OVERRUN_R {
                RX_OVERRUN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 5 - Transmit FIFO has room for at least one byte"]
            #[inline(always)]
            pub fn tx_empty(&self) -> TX_EMPTY_R {
                TX_EMPTY_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Transmit FIFO empty and all bits shifted out"]
            #[inline(always)]
            pub fn tx_idle(&self) -> TX_IDLE_R {
                TX_IDLE_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LSR")
                    .field("tx_idle", &format_args!("{}", self.tx_idle().bit()))
                    .field("tx_empty", &format_args!("{}", self.tx_empty().bit()))
                    .field("rx_overrun", &format_args!("{}", self.rx_overrun().bit()))
                    .field("data_ready", &format_args!("{}", self.data_ready().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<LSR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Receive FIFO has at least one byte"]
            #[inline(always)]
            #[must_use]
            pub fn data_ready(&mut self) -> DATA_READY_W<LSR_SPEC, 0> {
                DATA_READY_W::new(self)
            }
            #[doc = "Bit 1 - Receive FIFO overrun"]
            #[inline(always)]
            #[must_use]
            pub fn rx_overrun(&mut self) -> RX_OVERRUN_W<LSR_SPEC, 1> {
                RX_OVERRUN_W::new(self)
            }
            #[doc = "Bit 5 - Transmit FIFO has room for at least one byte"]
            #[inline(always)]
            #[must_use]
            pub fn tx_empty(&mut self) -> TX_EMPTY_W<LSR_SPEC, 5> {
                TX_EMPTY_W::new(self)
            }
            #[doc = "Bit 6 - Transmit FIFO empty and all bits shifted out"]
            #[inline(always)]
            #[must_use]
            pub fn tx_idle(&mut self) -> TX_IDLE_W<LSR_SPEC, 6> {
                TX_IDLE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Line Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lsr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lsr::R`](R) reader structure"]
        impl crate::Readable for LSR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`lsr::W`](W) writer structure"]
        impl crate::Writable for LSR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets LSR to value 0"]
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "MSR (rw) register accessor: Modem Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`msr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`msr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@msr`]
module"]
    pub type MSR = crate::Reg<msr::MSR_SPEC>;
    #[doc = "Modem Status"]
    pub mod msr {
        #[doc = "Register `MSR` reader"]
        pub type R = crate::R<MSR_SPEC>;
        #[doc = "Register `MSR` writer"]
        pub type W = crate::W<MSR_SPEC>;
        #[doc = "Field `CTS` reader - CTS is low"]
        pub type CTS_R = crate::BitReader;
        #[doc = "Field `CTS` writer - CTS is low"]
        pub type CTS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 4 - CTS is low"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MSR")
                    .field("cts", &format_args!("{}", self.cts().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<MSR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 4 - CTS is low"]
            #[inline(always)]
            #[must_use]
            pub fn cts(&mut self) -> CTS_W<MSR_SPEC, 4> {
                CTS_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Modem Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`msr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`msr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MSR_SPEC;
        impl crate::RegisterSpec for MSR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`msr::R`](R) reader structure"]
        impl crate::Readable for MSR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`msr::W`](W) writer structure"]
        impl crate::Writable for MSR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets MSR to value 0"]
        impl crate::Resettable for MSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "SCRATCH (rw) register accessor: Scratch\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`scratch::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`scratch::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@scratch`]
module"]
    pub type SCRATCH = crate::Reg<scratch::SCRATCH_SPEC>;
    #[doc = "Scratch"]
    pub mod scratch {
        #[doc = "Register `SCRATCH` reader"]
        pub type R = crate::R<SCRATCH_SPEC>;
        #[doc = "Register `SCRATCH` writer"]
        pub type W = crate::W<SCRATCH_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<SCRATCH_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Scratch\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`scratch::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`scratch::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SCRATCH_SPEC;
        impl crate::RegisterSpec for SCRATCH_SPEC {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`scratch::R`](R) reader structure"]
        impl crate::Readable for SCRATCH_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`scratch::W`](W) writer structure"]
        impl crate::Writable for SCRATCH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets SCRATCH to value 0"]
        impl crate::Resettable for SCRATCH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CNTL (rw) register accessor: Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cntl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cntl`]
module"]
    pub type CNTL = crate::Reg<cntl::CNTL_SPEC>;
    #[doc = "Control"]
    pub mod cntl {
        #[doc = "Register `CNTL` reader"]
        pub type R = crate::R<CNTL_SPEC>;
        #[doc = "Register `CNTL` writer"]
        pub type W = crate::W<CNTL_SPEC>;
        #[doc = "Field `RX_ENABLE` reader - Enable receive"]
        pub type RX_ENABLE_R = crate::BitReader;
        #[doc = "Field `RX_ENABLE` writer - Enable receive"]
        pub type RX_ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_ENABLE` reader - Enable transmit"]
        pub type TX_ENABLE_R = crate::BitReader;
        #[doc = "Field `TX_ENABLE` writer - Enable transmit"]
        pub type TX_ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RTS_ENABLE` reader - Enable auto receive flow control with RTS"]
        pub type RTS_ENABLE_R = crate::BitReader;
        #[doc = "Field `RTS_ENABLE` writer - Enable auto receive flow control with RTS"]
        pub type RTS_ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTS_ENABLE` reader - Enable auto transmit flow control with CTS"]
        pub type CTS_ENABLE_R = crate::BitReader;
        #[doc = "Field `CTS_ENABLE` writer - Enable auto transmit flow control with CTS"]
        pub type CTS_ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RTS_FIFO_LEVEL` reader - FIFO level to de-assert RTS"]
        pub type RTS_FIFO_LEVEL_R = crate::FieldReader<FIFO_LEVEL_A>;
        #[doc = "FIFO level to de-assert RTS\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FIFO_LEVEL_A {
            #[doc = "0: 3 empty spaces"]
            _3EMPTY = 0,
            #[doc = "1: 2 empty spaces"]
            _2EMPTY = 1,
            #[doc = "2: 1 empty spaces"]
            _1EMPTY = 2,
            #[doc = "3: 4 empty spaces"]
            _4EMPTY = 3,
        }
        impl From<FIFO_LEVEL_A> for u8 {
            #[inline(always)]
            fn from(variant: FIFO_LEVEL_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FIFO_LEVEL_A {
            type Ux = u8;
        }
        impl RTS_FIFO_LEVEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FIFO_LEVEL_A {
                match self.bits {
                    0 => FIFO_LEVEL_A::_3EMPTY,
                    1 => FIFO_LEVEL_A::_2EMPTY,
                    2 => FIFO_LEVEL_A::_1EMPTY,
                    3 => FIFO_LEVEL_A::_4EMPTY,
                    _ => unreachable!(),
                }
            }
            #[doc = "3 empty spaces"]
            #[inline(always)]
            pub fn is_3empty(&self) -> bool {
                *self == FIFO_LEVEL_A::_3EMPTY
            }
            #[doc = "2 empty spaces"]
            #[inline(always)]
            pub fn is_2empty(&self) -> bool {
                *self == FIFO_LEVEL_A::_2EMPTY
            }
            #[doc = "1 empty spaces"]
            #[inline(always)]
            pub fn is_1empty(&self) -> bool {
                *self == FIFO_LEVEL_A::_1EMPTY
            }
            #[doc = "4 empty spaces"]
            #[inline(always)]
            pub fn is_4empty(&self) -> bool {
                *self == FIFO_LEVEL_A::_4EMPTY
            }
        }
        #[doc = "Field `RTS_FIFO_LEVEL` writer - FIFO level to de-assert RTS"]
        pub type RTS_FIFO_LEVEL_W<'a, REG, const O: u8> =
            crate::FieldWriterSafe<'a, REG, 2, O, FIFO_LEVEL_A>;
        impl<'a, REG, const O: u8> RTS_FIFO_LEVEL_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "3 empty spaces"]
            #[inline(always)]
            pub fn _3empty(self) -> &'a mut crate::W<REG> {
                self.variant(FIFO_LEVEL_A::_3EMPTY)
            }
            #[doc = "2 empty spaces"]
            #[inline(always)]
            pub fn _2empty(self) -> &'a mut crate::W<REG> {
                self.variant(FIFO_LEVEL_A::_2EMPTY)
            }
            #[doc = "1 empty spaces"]
            #[inline(always)]
            pub fn _1empty(self) -> &'a mut crate::W<REG> {
                self.variant(FIFO_LEVEL_A::_1EMPTY)
            }
            #[doc = "4 empty spaces"]
            #[inline(always)]
            pub fn _4empty(self) -> &'a mut crate::W<REG> {
                self.variant(FIFO_LEVEL_A::_4EMPTY)
            }
        }
        #[doc = "Field `RTS_ASSERT` reader - RTS assert level"]
        pub use CTS_ASSERT_R as RTS_ASSERT_R;
        #[doc = "Field `RTS_ASSERT` writer - RTS assert level"]
        pub use CTS_ASSERT_W as RTS_ASSERT_W;
        #[doc = "Field `CTS_ASSERT` reader - CTS assert level"]
        pub type CTS_ASSERT_R = crate::BitReader<ASSERT_LEVEL_A>;
        #[doc = "CTS assert level\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ASSERT_LEVEL_A {
            #[doc = "0: Assert high"]
            HIGH = 0,
            #[doc = "1: Assert low"]
            LOW = 1,
        }
        impl From<ASSERT_LEVEL_A> for bool {
            #[inline(always)]
            fn from(variant: ASSERT_LEVEL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CTS_ASSERT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ASSERT_LEVEL_A {
                match self.bits {
                    false => ASSERT_LEVEL_A::HIGH,
                    true => ASSERT_LEVEL_A::LOW,
                }
            }
            #[doc = "Assert high"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == ASSERT_LEVEL_A::HIGH
            }
            #[doc = "Assert low"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == ASSERT_LEVEL_A::LOW
            }
        }
        #[doc = "Field `CTS_ASSERT` writer - CTS assert level"]
        pub type CTS_ASSERT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, ASSERT_LEVEL_A>;
        impl<'a, REG, const O: u8> CTS_ASSERT_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Assert high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut crate::W<REG> {
                self.variant(ASSERT_LEVEL_A::HIGH)
            }
            #[doc = "Assert low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut crate::W<REG> {
                self.variant(ASSERT_LEVEL_A::LOW)
            }
        }
        impl R {
            #[doc = "Bit 0 - Enable receive"]
            #[inline(always)]
            pub fn rx_enable(&self) -> RX_ENABLE_R {
                RX_ENABLE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Enable transmit"]
            #[inline(always)]
            pub fn tx_enable(&self) -> TX_ENABLE_R {
                TX_ENABLE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable auto receive flow control with RTS"]
            #[inline(always)]
            pub fn rts_enable(&self) -> RTS_ENABLE_R {
                RTS_ENABLE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Enable auto transmit flow control with CTS"]
            #[inline(always)]
            pub fn cts_enable(&self) -> CTS_ENABLE_R {
                CTS_ENABLE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - FIFO level to de-assert RTS"]
            #[inline(always)]
            pub fn rts_fifo_level(&self) -> RTS_FIFO_LEVEL_R {
                RTS_FIFO_LEVEL_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bit 6 - RTS assert level"]
            #[inline(always)]
            pub fn rts_assert(&self) -> RTS_ASSERT_R {
                RTS_ASSERT_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - CTS assert level"]
            #[inline(always)]
            pub fn cts_assert(&self) -> CTS_ASSERT_R {
                CTS_ASSERT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CNTL")
                    .field("cts_assert", &format_args!("{}", self.cts_assert().bit()))
                    .field("rts_assert", &format_args!("{}", self.rts_assert().bit()))
                    .field(
                        "rts_fifo_level",
                        &format_args!("{}", self.rts_fifo_level().bits()),
                    )
                    .field("cts_enable", &format_args!("{}", self.cts_enable().bit()))
                    .field("rts_enable", &format_args!("{}", self.rts_enable().bit()))
                    .field("tx_enable", &format_args!("{}", self.tx_enable().bit()))
                    .field("rx_enable", &format_args!("{}", self.rx_enable().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable receive"]
            #[inline(always)]
            #[must_use]
            pub fn rx_enable(&mut self) -> RX_ENABLE_W<CNTL_SPEC, 0> {
                RX_ENABLE_W::new(self)
            }
            #[doc = "Bit 1 - Enable transmit"]
            #[inline(always)]
            #[must_use]
            pub fn tx_enable(&mut self) -> TX_ENABLE_W<CNTL_SPEC, 1> {
                TX_ENABLE_W::new(self)
            }
            #[doc = "Bit 2 - Enable auto receive flow control with RTS"]
            #[inline(always)]
            #[must_use]
            pub fn rts_enable(&mut self) -> RTS_ENABLE_W<CNTL_SPEC, 2> {
                RTS_ENABLE_W::new(self)
            }
            #[doc = "Bit 3 - Enable auto transmit flow control with CTS"]
            #[inline(always)]
            #[must_use]
            pub fn cts_enable(&mut self) -> CTS_ENABLE_W<CNTL_SPEC, 3> {
                CTS_ENABLE_W::new(self)
            }
            #[doc = "Bits 4:5 - FIFO level to de-assert RTS"]
            #[inline(always)]
            #[must_use]
            pub fn rts_fifo_level(&mut self) -> RTS_FIFO_LEVEL_W<CNTL_SPEC, 4> {
                RTS_FIFO_LEVEL_W::new(self)
            }
            #[doc = "Bit 6 - RTS assert level"]
            #[inline(always)]
            #[must_use]
            pub fn rts_assert(&mut self) -> RTS_ASSERT_W<CNTL_SPEC, 6> {
                RTS_ASSERT_W::new(self)
            }
            #[doc = "Bit 7 - CTS assert level"]
            #[inline(always)]
            #[must_use]
            pub fn cts_assert(&mut self) -> CTS_ASSERT_W<CNTL_SPEC, 7> {
                CTS_ASSERT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cntl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CNTL_SPEC;
        impl crate::RegisterSpec for CNTL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cntl::R`](R) reader structure"]
        impl crate::Readable for CNTL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cntl::W`](W) writer structure"]
        impl crate::Writable for CNTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CNTL to value 0"]
        impl crate::Resettable for CNTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "STAT (rw) register accessor: Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`stat::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stat::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stat`]
module"]
    pub type STAT = crate::Reg<stat::STAT_SPEC>;
    #[doc = "Status"]
    pub mod stat {
        #[doc = "Register `STAT` reader"]
        pub type R = crate::R<STAT_SPEC>;
        #[doc = "Register `STAT` writer"]
        pub type W = crate::W<STAT_SPEC>;
        #[doc = "Field `DATA_READY` reader - Receive FIFO has at least one symbol"]
        pub type DATA_READY_R = crate::BitReader;
        #[doc = "Field `DATA_READY` writer - Receive FIFO has at least one symbol"]
        pub type DATA_READY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_READY` reader - Transmit FIFO has space for at least one symbol"]
        pub type TX_READY_R = crate::BitReader;
        #[doc = "Field `TX_READY` writer - Transmit FIFO has space for at least one symbol"]
        pub type TX_READY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RX_IDLE` reader - Receiver is idle"]
        pub type RX_IDLE_R = crate::BitReader;
        #[doc = "Field `RX_IDLE` writer - Receiver is idle"]
        pub type RX_IDLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_IDLE` reader - Transmitter is idle"]
        pub type TX_IDLE_R = crate::BitReader;
        #[doc = "Field `TX_IDLE` writer - Transmitter is idle"]
        pub type TX_IDLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RX_OVERRUN` reader - Receive FIFO overrun"]
        pub type RX_OVERRUN_R = crate::BitReader;
        #[doc = "Field `RX_OVERRUN` writer - Receive FIFO overrun"]
        pub type RX_OVERRUN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_FULL` reader - Transmit FIFO is full"]
        pub type TX_FULL_R = crate::BitReader;
        #[doc = "Field `TX_FULL` writer - Transmit FIFO is full"]
        pub type TX_FULL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RTS_STATUS` reader - RTS state"]
        pub type RTS_STATUS_R = crate::BitReader;
        #[doc = "Field `RTS_STATUS` writer - RTS state"]
        pub type RTS_STATUS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTS_STATUS` reader - CTS state"]
        pub type CTS_STATUS_R = crate::BitReader;
        #[doc = "Field `CTS_STATUS` writer - CTS state"]
        pub type CTS_STATUS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_EMPTY` reader - Transmit FIFO is completely empty"]
        pub type TX_EMPTY_R = crate::BitReader;
        #[doc = "Field `TX_EMPTY` writer - Transmit FIFO is completely empty"]
        pub type TX_EMPTY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_DONE` reader - Transmit FIFO is empty and transmitter is idle"]
        pub type TX_DONE_R = crate::BitReader;
        #[doc = "Field `TX_DONE` writer - Transmit FIFO is empty and transmitter is idle"]
        pub type TX_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RX_FIFO_LEVEL` reader - How many entries are filled in the RX FIFO"]
        pub type RX_FIFO_LEVEL_R = crate::FieldReader;
        #[doc = "Field `RX_FIFO_LEVEL` writer - How many entries are filled in the RX FIFO"]
        pub type RX_FIFO_LEVEL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        #[doc = "Field `TX_FIFO_LEVEL` reader - How many entries are filled in the TX FIFO"]
        pub type TX_FIFO_LEVEL_R = crate::FieldReader;
        #[doc = "Field `TX_FIFO_LEVEL` writer - How many entries are filled in the TX FIFO"]
        pub type TX_FIFO_LEVEL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        impl R {
            #[doc = "Bit 0 - Receive FIFO has at least one symbol"]
            #[inline(always)]
            pub fn data_ready(&self) -> DATA_READY_R {
                DATA_READY_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Transmit FIFO has space for at least one symbol"]
            #[inline(always)]
            pub fn tx_ready(&self) -> TX_READY_R {
                TX_READY_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Receiver is idle"]
            #[inline(always)]
            pub fn rx_idle(&self) -> RX_IDLE_R {
                RX_IDLE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Transmitter is idle"]
            #[inline(always)]
            pub fn tx_idle(&self) -> TX_IDLE_R {
                TX_IDLE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Receive FIFO overrun"]
            #[inline(always)]
            pub fn rx_overrun(&self) -> RX_OVERRUN_R {
                RX_OVERRUN_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Transmit FIFO is full"]
            #[inline(always)]
            pub fn tx_full(&self) -> TX_FULL_R {
                TX_FULL_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RTS state"]
            #[inline(always)]
            pub fn rts_status(&self) -> RTS_STATUS_R {
                RTS_STATUS_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - CTS state"]
            #[inline(always)]
            pub fn cts_status(&self) -> CTS_STATUS_R {
                CTS_STATUS_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Transmit FIFO is completely empty"]
            #[inline(always)]
            pub fn tx_empty(&self) -> TX_EMPTY_R {
                TX_EMPTY_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Transmit FIFO is empty and transmitter is idle"]
            #[inline(always)]
            pub fn tx_done(&self) -> TX_DONE_R {
                TX_DONE_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bits 16:19 - How many entries are filled in the RX FIFO"]
            #[inline(always)]
            pub fn rx_fifo_level(&self) -> RX_FIFO_LEVEL_R {
                RX_FIFO_LEVEL_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 24:27 - How many entries are filled in the TX FIFO"]
            #[inline(always)]
            pub fn tx_fifo_level(&self) -> TX_FIFO_LEVEL_R {
                TX_FIFO_LEVEL_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STAT")
                    .field(
                        "tx_fifo_level",
                        &format_args!("{}", self.tx_fifo_level().bits()),
                    )
                    .field(
                        "rx_fifo_level",
                        &format_args!("{}", self.rx_fifo_level().bits()),
                    )
                    .field("tx_done", &format_args!("{}", self.tx_done().bit()))
                    .field("tx_empty", &format_args!("{}", self.tx_empty().bit()))
                    .field("cts_status", &format_args!("{}", self.cts_status().bit()))
                    .field("rts_status", &format_args!("{}", self.rts_status().bit()))
                    .field("tx_full", &format_args!("{}", self.tx_full().bit()))
                    .field("rx_overrun", &format_args!("{}", self.rx_overrun().bit()))
                    .field("tx_idle", &format_args!("{}", self.tx_idle().bit()))
                    .field("rx_idle", &format_args!("{}", self.rx_idle().bit()))
                    .field("tx_ready", &format_args!("{}", self.tx_ready().bit()))
                    .field("data_ready", &format_args!("{}", self.data_ready().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<STAT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Receive FIFO has at least one symbol"]
            #[inline(always)]
            #[must_use]
            pub fn data_ready(&mut self) -> DATA_READY_W<STAT_SPEC, 0> {
                DATA_READY_W::new(self)
            }
            #[doc = "Bit 1 - Transmit FIFO has space for at least one symbol"]
            #[inline(always)]
            #[must_use]
            pub fn tx_ready(&mut self) -> TX_READY_W<STAT_SPEC, 1> {
                TX_READY_W::new(self)
            }
            #[doc = "Bit 2 - Receiver is idle"]
            #[inline(always)]
            #[must_use]
            pub fn rx_idle(&mut self) -> RX_IDLE_W<STAT_SPEC, 2> {
                RX_IDLE_W::new(self)
            }
            #[doc = "Bit 3 - Transmitter is idle"]
            #[inline(always)]
            #[must_use]
            pub fn tx_idle(&mut self) -> TX_IDLE_W<STAT_SPEC, 3> {
                TX_IDLE_W::new(self)
            }
            #[doc = "Bit 4 - Receive FIFO overrun"]
            #[inline(always)]
            #[must_use]
            pub fn rx_overrun(&mut self) -> RX_OVERRUN_W<STAT_SPEC, 4> {
                RX_OVERRUN_W::new(self)
            }
            #[doc = "Bit 5 - Transmit FIFO is full"]
            #[inline(always)]
            #[must_use]
            pub fn tx_full(&mut self) -> TX_FULL_W<STAT_SPEC, 5> {
                TX_FULL_W::new(self)
            }
            #[doc = "Bit 6 - RTS state"]
            #[inline(always)]
            #[must_use]
            pub fn rts_status(&mut self) -> RTS_STATUS_W<STAT_SPEC, 6> {
                RTS_STATUS_W::new(self)
            }
            #[doc = "Bit 7 - CTS state"]
            #[inline(always)]
            #[must_use]
            pub fn cts_status(&mut self) -> CTS_STATUS_W<STAT_SPEC, 7> {
                CTS_STATUS_W::new(self)
            }
            #[doc = "Bit 8 - Transmit FIFO is completely empty"]
            #[inline(always)]
            #[must_use]
            pub fn tx_empty(&mut self) -> TX_EMPTY_W<STAT_SPEC, 8> {
                TX_EMPTY_W::new(self)
            }
            #[doc = "Bit 9 - Transmit FIFO is empty and transmitter is idle"]
            #[inline(always)]
            #[must_use]
            pub fn tx_done(&mut self) -> TX_DONE_W<STAT_SPEC, 9> {
                TX_DONE_W::new(self)
            }
            #[doc = "Bits 16:19 - How many entries are filled in the RX FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn rx_fifo_level(&mut self) -> RX_FIFO_LEVEL_W<STAT_SPEC, 16> {
                RX_FIFO_LEVEL_W::new(self)
            }
            #[doc = "Bits 24:27 - How many entries are filled in the TX FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn tx_fifo_level(&mut self) -> TX_FIFO_LEVEL_W<STAT_SPEC, 24> {
                TX_FIFO_LEVEL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`stat::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stat::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STAT_SPEC;
        impl crate::RegisterSpec for STAT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stat::R`](R) reader structure"]
        impl crate::Readable for STAT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`stat::W`](W) writer structure"]
        impl crate::Writable for STAT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets STAT to value 0"]
        impl crate::Resettable for STAT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "BAUD (rw) register accessor: Baudrate\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`baud::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`baud::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@baud`]
module"]
    pub type BAUD = crate::Reg<baud::BAUD_SPEC>;
    #[doc = "Baudrate"]
    pub mod baud {
        #[doc = "Register `BAUD` reader"]
        pub type R = crate::R<BAUD_SPEC>;
        #[doc = "Register `BAUD` writer"]
        pub type W = crate::W<BAUD_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<BAUD_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Baudrate\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`baud::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`baud::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BAUD_SPEC;
        impl crate::RegisterSpec for BAUD_SPEC {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`baud::R`](R) reader structure"]
        impl crate::Readable for BAUD_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`baud::W`](W) writer structure"]
        impl crate::Writable for BAUD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets BAUD to value 0"]
        impl crate::Resettable for BAUD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Aux SPI"]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi1::RegisterBlock = 0x2021_5080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
#[doc = "Aux SPI"]
pub mod spi1 {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control 0"]
        pub cntl0: CNTL0,
        #[doc = "0x04 - Control 1"]
        pub cntl1: CNTL1,
        #[doc = "0x08 - Status"]
        pub stat: STAT,
        #[doc = "0x0c - Read the RXFIFO without removing an entry"]
        pub peek: PEEK,
        #[doc = "0x10..0x20 - Writing to the FIFO will deassert CS at the end of the access"]
        pub io: [IO; 4],
        #[doc = "0x20..0x30 - Writing to the FIFO will maintain CS at the end of the access"]
        pub txhold: [TXHOLD; 4],
    }
    #[doc = "CNTL0 (rw) register accessor: Control 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cntl0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cntl0`]
module"]
    pub type CNTL0 = crate::Reg<cntl0::CNTL0_SPEC>;
    #[doc = "Control 0"]
    pub mod cntl0 {
        #[doc = "Register `CNTL0` reader"]
        pub type R = crate::R<CNTL0_SPEC>;
        #[doc = "Register `CNTL0` writer"]
        pub type W = crate::W<CNTL0_SPEC>;
        #[doc = "Field `SHIFT_LENGTH` reader - Number of bits to shift"]
        pub type SHIFT_LENGTH_R = crate::FieldReader;
        #[doc = "Field `SHIFT_LENGTH` writer - Number of bits to shift"]
        pub type SHIFT_LENGTH_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 6, O>;
        #[doc = "Field `MSB_FIRST` reader - Shift out the most significant bit (MSB) first"]
        pub type MSB_FIRST_R = crate::BitReader;
        #[doc = "Field `MSB_FIRST` writer - Shift out the most significant bit (MSB) first"]
        pub type MSB_FIRST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INVERT_CLK` reader - Idle clock high"]
        pub type INVERT_CLK_R = crate::BitReader;
        #[doc = "Field `INVERT_CLK` writer - Idle clock high"]
        pub type INVERT_CLK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OUT_RISING` reader - Data is clocked out on rising edge of CLK"]
        pub type OUT_RISING_R = crate::BitReader;
        #[doc = "Field `OUT_RISING` writer - Data is clocked out on rising edge of CLK"]
        pub type OUT_RISING_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CLEAR_FIFOS` reader - Clear FIFOs"]
        pub type CLEAR_FIFOS_R = crate::BitReader;
        #[doc = "Field `CLEAR_FIFOS` writer - Clear FIFOs"]
        pub type CLEAR_FIFOS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `IN_RISING` reader - Data is clocked in on rising edge of CLK"]
        pub type IN_RISING_R = crate::BitReader;
        #[doc = "Field `IN_RISING` writer - Data is clocked in on rising edge of CLK"]
        pub type IN_RISING_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENABLE` reader - Enable the interface"]
        pub type ENABLE_R = crate::BitReader;
        #[doc = "Field `ENABLE` writer - Enable the interface"]
        pub type ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DOUT_HOLD_TIME` reader - Controls extra DOUT hold time in system clock cycles"]
        pub type DOUT_HOLD_TIME_R = crate::FieldReader<DOUT_HOLD_TIME_A>;
        #[doc = "Controls extra DOUT hold time in system clock cycles\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DOUT_HOLD_TIME_A {
            #[doc = "0: `0`"]
            _0 = 0,
            #[doc = "1: `1`"]
            _1 = 1,
            #[doc = "2: `10`"]
            _4 = 2,
            #[doc = "3: `11`"]
            _7 = 3,
        }
        impl From<DOUT_HOLD_TIME_A> for u8 {
            #[inline(always)]
            fn from(variant: DOUT_HOLD_TIME_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DOUT_HOLD_TIME_A {
            type Ux = u8;
        }
        impl DOUT_HOLD_TIME_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DOUT_HOLD_TIME_A {
                match self.bits {
                    0 => DOUT_HOLD_TIME_A::_0,
                    1 => DOUT_HOLD_TIME_A::_1,
                    2 => DOUT_HOLD_TIME_A::_4,
                    3 => DOUT_HOLD_TIME_A::_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_0(&self) -> bool {
                *self == DOUT_HOLD_TIME_A::_0
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_1(&self) -> bool {
                *self == DOUT_HOLD_TIME_A::_1
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_4(&self) -> bool {
                *self == DOUT_HOLD_TIME_A::_4
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_7(&self) -> bool {
                *self == DOUT_HOLD_TIME_A::_7
            }
        }
        #[doc = "Field `DOUT_HOLD_TIME` writer - Controls extra DOUT hold time in system clock cycles"]
        pub type DOUT_HOLD_TIME_W<'a, REG, const O: u8> =
            crate::FieldWriterSafe<'a, REG, 2, O, DOUT_HOLD_TIME_A>;
        impl<'a, REG, const O: u8> DOUT_HOLD_TIME_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn _0(self) -> &'a mut crate::W<REG> {
                self.variant(DOUT_HOLD_TIME_A::_0)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn _1(self) -> &'a mut crate::W<REG> {
                self.variant(DOUT_HOLD_TIME_A::_1)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn _4(self) -> &'a mut crate::W<REG> {
                self.variant(DOUT_HOLD_TIME_A::_4)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn _7(self) -> &'a mut crate::W<REG> {
                self.variant(DOUT_HOLD_TIME_A::_7)
            }
        }
        #[doc = "Field `VARIABLE_WIDTH` reader - Take shift length and data from FIFO"]
        pub type VARIABLE_WIDTH_R = crate::BitReader;
        #[doc = "Field `VARIABLE_WIDTH` writer - Take shift length and data from FIFO"]
        pub type VARIABLE_WIDTH_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `VARIABLE_CS` reader - Take CS pattern and data from TX FIFO (along with VARIABLE_WIDTH)"]
        pub type VARIABLE_CS_R = crate::BitReader;
        #[doc = "Field `VARIABLE_CS` writer - Take CS pattern and data from TX FIFO (along with VARIABLE_WIDTH)"]
        pub type VARIABLE_CS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `POST_INPUT` reader - Post input mode"]
        pub type POST_INPUT_R = crate::BitReader;
        #[doc = "Field `POST_INPUT` writer - Post input mode"]
        pub type POST_INPUT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CHIP_SELECTS` reader - The CS pattern when active"]
        pub type CHIP_SELECTS_R = crate::FieldReader;
        #[doc = "Field `CHIP_SELECTS` writer - The CS pattern when active"]
        pub type CHIP_SELECTS_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O>;
        #[doc = "Field `SPEED` reader - SPI clock speed. clk = sys / 2 * (SPEED + 1)"]
        pub type SPEED_R = crate::FieldReader<u16>;
        #[doc = "Field `SPEED` writer - SPI clock speed. clk = sys / 2 * (SPEED + 1)"]
        pub type SPEED_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 12, O, u16>;
        impl R {
            #[doc = "Bits 0:5 - Number of bits to shift"]
            #[inline(always)]
            pub fn shift_length(&self) -> SHIFT_LENGTH_R {
                SHIFT_LENGTH_R::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bit 6 - Shift out the most significant bit (MSB) first"]
            #[inline(always)]
            pub fn msb_first(&self) -> MSB_FIRST_R {
                MSB_FIRST_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Idle clock high"]
            #[inline(always)]
            pub fn invert_clk(&self) -> INVERT_CLK_R {
                INVERT_CLK_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Data is clocked out on rising edge of CLK"]
            #[inline(always)]
            pub fn out_rising(&self) -> OUT_RISING_R {
                OUT_RISING_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Clear FIFOs"]
            #[inline(always)]
            pub fn clear_fifos(&self) -> CLEAR_FIFOS_R {
                CLEAR_FIFOS_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Data is clocked in on rising edge of CLK"]
            #[inline(always)]
            pub fn in_rising(&self) -> IN_RISING_R {
                IN_RISING_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Enable the interface"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 12:13 - Controls extra DOUT hold time in system clock cycles"]
            #[inline(always)]
            pub fn dout_hold_time(&self) -> DOUT_HOLD_TIME_R {
                DOUT_HOLD_TIME_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bit 14 - Take shift length and data from FIFO"]
            #[inline(always)]
            pub fn variable_width(&self) -> VARIABLE_WIDTH_R {
                VARIABLE_WIDTH_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Take CS pattern and data from TX FIFO (along with VARIABLE_WIDTH)"]
            #[inline(always)]
            pub fn variable_cs(&self) -> VARIABLE_CS_R {
                VARIABLE_CS_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Post input mode"]
            #[inline(always)]
            pub fn post_input(&self) -> POST_INPUT_R {
                POST_INPUT_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bits 17:19 - The CS pattern when active"]
            #[inline(always)]
            pub fn chip_selects(&self) -> CHIP_SELECTS_R {
                CHIP_SELECTS_R::new(((self.bits >> 17) & 7) as u8)
            }
            #[doc = "Bits 20:31 - SPI clock speed. clk = sys / 2 * (SPEED + 1)"]
            #[inline(always)]
            pub fn speed(&self) -> SPEED_R {
                SPEED_R::new(((self.bits >> 20) & 0x0fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CNTL0")
                    .field("speed", &format_args!("{}", self.speed().bits()))
                    .field(
                        "chip_selects",
                        &format_args!("{}", self.chip_selects().bits()),
                    )
                    .field("post_input", &format_args!("{}", self.post_input().bit()))
                    .field("variable_cs", &format_args!("{}", self.variable_cs().bit()))
                    .field(
                        "variable_width",
                        &format_args!("{}", self.variable_width().bit()),
                    )
                    .field(
                        "dout_hold_time",
                        &format_args!("{}", self.dout_hold_time().bits()),
                    )
                    .field("enable", &format_args!("{}", self.enable().bit()))
                    .field("in_rising", &format_args!("{}", self.in_rising().bit()))
                    .field("clear_fifos", &format_args!("{}", self.clear_fifos().bit()))
                    .field("out_rising", &format_args!("{}", self.out_rising().bit()))
                    .field("invert_clk", &format_args!("{}", self.invert_clk().bit()))
                    .field("msb_first", &format_args!("{}", self.msb_first().bit()))
                    .field(
                        "shift_length",
                        &format_args!("{}", self.shift_length().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNTL0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:5 - Number of bits to shift"]
            #[inline(always)]
            #[must_use]
            pub fn shift_length(&mut self) -> SHIFT_LENGTH_W<CNTL0_SPEC, 0> {
                SHIFT_LENGTH_W::new(self)
            }
            #[doc = "Bit 6 - Shift out the most significant bit (MSB) first"]
            #[inline(always)]
            #[must_use]
            pub fn msb_first(&mut self) -> MSB_FIRST_W<CNTL0_SPEC, 6> {
                MSB_FIRST_W::new(self)
            }
            #[doc = "Bit 7 - Idle clock high"]
            #[inline(always)]
            #[must_use]
            pub fn invert_clk(&mut self) -> INVERT_CLK_W<CNTL0_SPEC, 7> {
                INVERT_CLK_W::new(self)
            }
            #[doc = "Bit 8 - Data is clocked out on rising edge of CLK"]
            #[inline(always)]
            #[must_use]
            pub fn out_rising(&mut self) -> OUT_RISING_W<CNTL0_SPEC, 8> {
                OUT_RISING_W::new(self)
            }
            #[doc = "Bit 9 - Clear FIFOs"]
            #[inline(always)]
            #[must_use]
            pub fn clear_fifos(&mut self) -> CLEAR_FIFOS_W<CNTL0_SPEC, 9> {
                CLEAR_FIFOS_W::new(self)
            }
            #[doc = "Bit 10 - Data is clocked in on rising edge of CLK"]
            #[inline(always)]
            #[must_use]
            pub fn in_rising(&mut self) -> IN_RISING_W<CNTL0_SPEC, 10> {
                IN_RISING_W::new(self)
            }
            #[doc = "Bit 11 - Enable the interface"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<CNTL0_SPEC, 11> {
                ENABLE_W::new(self)
            }
            #[doc = "Bits 12:13 - Controls extra DOUT hold time in system clock cycles"]
            #[inline(always)]
            #[must_use]
            pub fn dout_hold_time(&mut self) -> DOUT_HOLD_TIME_W<CNTL0_SPEC, 12> {
                DOUT_HOLD_TIME_W::new(self)
            }
            #[doc = "Bit 14 - Take shift length and data from FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn variable_width(&mut self) -> VARIABLE_WIDTH_W<CNTL0_SPEC, 14> {
                VARIABLE_WIDTH_W::new(self)
            }
            #[doc = "Bit 15 - Take CS pattern and data from TX FIFO (along with VARIABLE_WIDTH)"]
            #[inline(always)]
            #[must_use]
            pub fn variable_cs(&mut self) -> VARIABLE_CS_W<CNTL0_SPEC, 15> {
                VARIABLE_CS_W::new(self)
            }
            #[doc = "Bit 16 - Post input mode"]
            #[inline(always)]
            #[must_use]
            pub fn post_input(&mut self) -> POST_INPUT_W<CNTL0_SPEC, 16> {
                POST_INPUT_W::new(self)
            }
            #[doc = "Bits 17:19 - The CS pattern when active"]
            #[inline(always)]
            #[must_use]
            pub fn chip_selects(&mut self) -> CHIP_SELECTS_W<CNTL0_SPEC, 17> {
                CHIP_SELECTS_W::new(self)
            }
            #[doc = "Bits 20:31 - SPI clock speed. clk = sys / 2 * (SPEED + 1)"]
            #[inline(always)]
            #[must_use]
            pub fn speed(&mut self) -> SPEED_W<CNTL0_SPEC, 20> {
                SPEED_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cntl0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CNTL0_SPEC;
        impl crate::RegisterSpec for CNTL0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cntl0::R`](R) reader structure"]
        impl crate::Readable for CNTL0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cntl0::W`](W) writer structure"]
        impl crate::Writable for CNTL0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CNTL0 to value 0x000e_0000"]
        impl crate::Resettable for CNTL0_SPEC {
            const RESET_VALUE: Self::Ux = 0x000e_0000;
        }
    }
    #[doc = "CNTL1 (rw) register accessor: Control 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cntl1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cntl1`]
module"]
    pub type CNTL1 = crate::Reg<cntl1::CNTL1_SPEC>;
    #[doc = "Control 1"]
    pub mod cntl1 {
        #[doc = "Register `CNTL1` reader"]
        pub type R = crate::R<CNTL1_SPEC>;
        #[doc = "Register `CNTL1` writer"]
        pub type W = crate::W<CNTL1_SPEC>;
        #[doc = "Field `KEEP_INPUT` reader - Don't clear the RX shift register before a new transaction"]
        pub type KEEP_INPUT_R = crate::BitReader;
        #[doc = "Field `KEEP_INPUT` writer - Don't clear the RX shift register before a new transaction"]
        pub type KEEP_INPUT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `MSB_FIRST` reader - Shift the most significant bit first (MSB)"]
        pub type MSB_FIRST_R = crate::BitReader;
        #[doc = "Field `MSB_FIRST` writer - Shift the most significant bit first (MSB)"]
        pub type MSB_FIRST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DONE_ENABLE` reader - Enable DONE interrupt"]
        pub type DONE_ENABLE_R = crate::BitReader;
        #[doc = "Field `DONE_ENABLE` writer - Enable DONE interrupt"]
        pub type DONE_ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXE_ENABLE` reader - Enable TX empty interrupt"]
        pub type TXE_ENABLE_R = crate::BitReader;
        #[doc = "Field `TXE_ENABLE` writer - Enable TX empty interrupt"]
        pub type TXE_ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CS_HIGH_TIME` reader - Additional SPI clock cycles where CS is high"]
        pub type CS_HIGH_TIME_R = crate::FieldReader;
        #[doc = "Field `CS_HIGH_TIME` writer - Additional SPI clock cycles where CS is high"]
        pub type CS_HIGH_TIME_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O>;
        impl R {
            #[doc = "Bit 0 - Don't clear the RX shift register before a new transaction"]
            #[inline(always)]
            pub fn keep_input(&self) -> KEEP_INPUT_R {
                KEEP_INPUT_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Shift the most significant bit first (MSB)"]
            #[inline(always)]
            pub fn msb_first(&self) -> MSB_FIRST_R {
                MSB_FIRST_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 6 - Enable DONE interrupt"]
            #[inline(always)]
            pub fn done_enable(&self) -> DONE_ENABLE_R {
                DONE_ENABLE_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Enable TX empty interrupt"]
            #[inline(always)]
            pub fn txe_enable(&self) -> TXE_ENABLE_R {
                TXE_ENABLE_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 8:10 - Additional SPI clock cycles where CS is high"]
            #[inline(always)]
            pub fn cs_high_time(&self) -> CS_HIGH_TIME_R {
                CS_HIGH_TIME_R::new(((self.bits >> 8) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CNTL1")
                    .field(
                        "cs_high_time",
                        &format_args!("{}", self.cs_high_time().bits()),
                    )
                    .field("txe_enable", &format_args!("{}", self.txe_enable().bit()))
                    .field("done_enable", &format_args!("{}", self.done_enable().bit()))
                    .field("msb_first", &format_args!("{}", self.msb_first().bit()))
                    .field("keep_input", &format_args!("{}", self.keep_input().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNTL1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Don't clear the RX shift register before a new transaction"]
            #[inline(always)]
            #[must_use]
            pub fn keep_input(&mut self) -> KEEP_INPUT_W<CNTL1_SPEC, 0> {
                KEEP_INPUT_W::new(self)
            }
            #[doc = "Bit 1 - Shift the most significant bit first (MSB)"]
            #[inline(always)]
            #[must_use]
            pub fn msb_first(&mut self) -> MSB_FIRST_W<CNTL1_SPEC, 1> {
                MSB_FIRST_W::new(self)
            }
            #[doc = "Bit 6 - Enable DONE interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn done_enable(&mut self) -> DONE_ENABLE_W<CNTL1_SPEC, 6> {
                DONE_ENABLE_W::new(self)
            }
            #[doc = "Bit 7 - Enable TX empty interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn txe_enable(&mut self) -> TXE_ENABLE_W<CNTL1_SPEC, 7> {
                TXE_ENABLE_W::new(self)
            }
            #[doc = "Bits 8:10 - Additional SPI clock cycles where CS is high"]
            #[inline(always)]
            #[must_use]
            pub fn cs_high_time(&mut self) -> CS_HIGH_TIME_W<CNTL1_SPEC, 8> {
                CS_HIGH_TIME_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cntl1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CNTL1_SPEC;
        impl crate::RegisterSpec for CNTL1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cntl1::R`](R) reader structure"]
        impl crate::Readable for CNTL1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cntl1::W`](W) writer structure"]
        impl crate::Writable for CNTL1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CNTL1 to value 0"]
        impl crate::Resettable for CNTL1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "STAT (rw) register accessor: Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`stat::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stat::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stat`]
module"]
    pub type STAT = crate::Reg<stat::STAT_SPEC>;
    #[doc = "Status"]
    pub mod stat {
        #[doc = "Register `STAT` reader"]
        pub type R = crate::R<STAT_SPEC>;
        #[doc = "Register `STAT` writer"]
        pub type W = crate::W<STAT_SPEC>;
        #[doc = "Field `BIT_COUNT` reader - Number of bits left to be processed."]
        pub type BIT_COUNT_R = crate::FieldReader;
        #[doc = "Field `BIT_COUNT` writer - Number of bits left to be processed."]
        pub type BIT_COUNT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 6, O>;
        #[doc = "Field `BUSY` reader - Indicates a transfer is ongoing"]
        pub type BUSY_R = crate::BitReader;
        #[doc = "Field `BUSY` writer - Indicates a transfer is ongoing"]
        pub type BUSY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RX_EMPTY` reader - RX FIFO is empty"]
        pub type RX_EMPTY_R = crate::BitReader;
        #[doc = "Field `RX_EMPTY` writer - RX FIFO is empty"]
        pub type RX_EMPTY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RX_FULL` reader - RX FIFO is full"]
        pub type RX_FULL_R = crate::BitReader;
        #[doc = "Field `RX_FULL` writer - RX FIFO is full"]
        pub type RX_FULL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_EMPTY` reader - TX FIFO is empty"]
        pub type TX_EMPTY_R = crate::BitReader;
        #[doc = "Field `TX_EMPTY` writer - TX FIFO is empty"]
        pub type TX_EMPTY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TX_FULL` reader - TX FIFO is full"]
        pub type TX_FULL_R = crate::BitReader;
        #[doc = "Field `TX_FULL` writer - TX FIFO is full"]
        pub type TX_FULL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RX_LEVEL` reader - Number of entries in RX FIFO"]
        pub type RX_LEVEL_R = crate::FieldReader;
        #[doc = "Field `RX_LEVEL` writer - Number of entries in RX FIFO"]
        pub type RX_LEVEL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        #[doc = "Field `TX_LEVEL` reader - Number of entries in TX FIFO"]
        pub type TX_LEVEL_R = crate::FieldReader;
        #[doc = "Field `TX_LEVEL` writer - Number of entries in TX FIFO"]
        pub type TX_LEVEL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        impl R {
            #[doc = "Bits 0:5 - Number of bits left to be processed."]
            #[inline(always)]
            pub fn bit_count(&self) -> BIT_COUNT_R {
                BIT_COUNT_R::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bit 6 - Indicates a transfer is ongoing"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RX FIFO is empty"]
            #[inline(always)]
            pub fn rx_empty(&self) -> RX_EMPTY_R {
                RX_EMPTY_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - RX FIFO is full"]
            #[inline(always)]
            pub fn rx_full(&self) -> RX_FULL_R {
                RX_FULL_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - TX FIFO is empty"]
            #[inline(always)]
            pub fn tx_empty(&self) -> TX_EMPTY_R {
                TX_EMPTY_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - TX FIFO is full"]
            #[inline(always)]
            pub fn tx_full(&self) -> TX_FULL_R {
                TX_FULL_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bits 16:19 - Number of entries in RX FIFO"]
            #[inline(always)]
            pub fn rx_level(&self) -> RX_LEVEL_R {
                RX_LEVEL_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 24:27 - Number of entries in TX FIFO"]
            #[inline(always)]
            pub fn tx_level(&self) -> TX_LEVEL_R {
                TX_LEVEL_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STAT")
                    .field("tx_level", &format_args!("{}", self.tx_level().bits()))
                    .field("rx_level", &format_args!("{}", self.rx_level().bits()))
                    .field("tx_full", &format_args!("{}", self.tx_full().bit()))
                    .field("tx_empty", &format_args!("{}", self.tx_empty().bit()))
                    .field("rx_full", &format_args!("{}", self.rx_full().bit()))
                    .field("rx_empty", &format_args!("{}", self.rx_empty().bit()))
                    .field("busy", &format_args!("{}", self.busy().bit()))
                    .field("bit_count", &format_args!("{}", self.bit_count().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<STAT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:5 - Number of bits left to be processed."]
            #[inline(always)]
            #[must_use]
            pub fn bit_count(&mut self) -> BIT_COUNT_W<STAT_SPEC, 0> {
                BIT_COUNT_W::new(self)
            }
            #[doc = "Bit 6 - Indicates a transfer is ongoing"]
            #[inline(always)]
            #[must_use]
            pub fn busy(&mut self) -> BUSY_W<STAT_SPEC, 6> {
                BUSY_W::new(self)
            }
            #[doc = "Bit 7 - RX FIFO is empty"]
            #[inline(always)]
            #[must_use]
            pub fn rx_empty(&mut self) -> RX_EMPTY_W<STAT_SPEC, 7> {
                RX_EMPTY_W::new(self)
            }
            #[doc = "Bit 8 - RX FIFO is full"]
            #[inline(always)]
            #[must_use]
            pub fn rx_full(&mut self) -> RX_FULL_W<STAT_SPEC, 8> {
                RX_FULL_W::new(self)
            }
            #[doc = "Bit 9 - TX FIFO is empty"]
            #[inline(always)]
            #[must_use]
            pub fn tx_empty(&mut self) -> TX_EMPTY_W<STAT_SPEC, 9> {
                TX_EMPTY_W::new(self)
            }
            #[doc = "Bit 10 - TX FIFO is full"]
            #[inline(always)]
            #[must_use]
            pub fn tx_full(&mut self) -> TX_FULL_W<STAT_SPEC, 10> {
                TX_FULL_W::new(self)
            }
            #[doc = "Bits 16:19 - Number of entries in RX FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn rx_level(&mut self) -> RX_LEVEL_W<STAT_SPEC, 16> {
                RX_LEVEL_W::new(self)
            }
            #[doc = "Bits 24:27 - Number of entries in TX FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn tx_level(&mut self) -> TX_LEVEL_W<STAT_SPEC, 24> {
                TX_LEVEL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`stat::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stat::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STAT_SPEC;
        impl crate::RegisterSpec for STAT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stat::R`](R) reader structure"]
        impl crate::Readable for STAT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`stat::W`](W) writer structure"]
        impl crate::Writable for STAT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets STAT to value 0"]
        impl crate::Resettable for STAT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "PEEK (r) register accessor: Read the RXFIFO without removing an entry\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`peek::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@peek`]
module"]
    pub type PEEK = crate::Reg<peek::PEEK_SPEC>;
    #[doc = "Read the RXFIFO without removing an entry"]
    pub mod peek {
        #[doc = "Register `PEEK` reader"]
        pub type R = crate::R<PEEK_SPEC>;
        #[doc = "Field `DATA` reader - FIFO data access"]
        pub type DATA_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - FIFO data access"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PEEK")
                    .field("data", &format_args!("{}", self.data().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PEEK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Read the RXFIFO without removing an entry\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`peek::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PEEK_SPEC;
        impl crate::RegisterSpec for PEEK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`peek::R`](R) reader structure"]
        impl crate::Readable for PEEK_SPEC {}
        #[doc = "`reset()` method sets PEEK to value 0"]
        impl crate::Resettable for PEEK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IO (rw) register accessor: Writing to the FIFO will deassert CS at the end of the access\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`io::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`io::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@io`]
module"]
    pub type IO = crate::Reg<io::IO_SPEC>;
    #[doc = "Writing to the FIFO will deassert CS at the end of the access"]
    pub mod io {
        #[doc = "Register `IO%s` reader"]
        pub type R = crate::R<IO_SPEC>;
        #[doc = "Register `IO%s` writer"]
        pub type W = crate::W<IO_SPEC>;
        #[doc = "Field `DATA` reader - FIFO data access"]
        pub type DATA_R = crate::FieldReader<u16>;
        #[doc = "Field `DATA` writer - FIFO data access"]
        pub type DATA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - FIFO data access"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IO")
                    .field("data", &format_args!("{}", self.data().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IO_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - FIFO data access"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<IO_SPEC, 0> {
                DATA_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Writing to the FIFO will deassert CS at the end of the access\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`io::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`io::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IO_SPEC;
        impl crate::RegisterSpec for IO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`io::R`](R) reader structure"]
        impl crate::Readable for IO_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`io::W`](W) writer structure"]
        impl crate::Writable for IO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IO%s to value 0"]
        impl crate::Resettable for IO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "TXHOLD (rw) register accessor: Writing to the FIFO will maintain CS at the end of the access\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txhold::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txhold::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txhold`]
module"]
    pub type TXHOLD = crate::Reg<txhold::TXHOLD_SPEC>;
    #[doc = "Writing to the FIFO will maintain CS at the end of the access"]
    pub mod txhold {
        #[doc = "Register `TXHOLD%s` reader"]
        pub type R = crate::R<TXHOLD_SPEC>;
        #[doc = "Register `TXHOLD%s` writer"]
        pub type W = crate::W<TXHOLD_SPEC>;
        #[doc = "Field `DATA` reader - FIFO data access"]
        pub type DATA_R = crate::FieldReader<u16>;
        #[doc = "Field `DATA` writer - FIFO data access"]
        pub type DATA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - FIFO data access"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TXHOLD")
                    .field("data", &format_args!("{}", self.data().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<TXHOLD_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - FIFO data access"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<TXHOLD_SPEC, 0> {
                DATA_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Writing to the FIFO will maintain CS at the end of the access\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txhold::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txhold::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TXHOLD_SPEC;
        impl crate::RegisterSpec for TXHOLD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`txhold::R`](R) reader structure"]
        impl crate::Readable for TXHOLD_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`txhold::W`](W) writer structure"]
        impl crate::Writable for TXHOLD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets TXHOLD%s to value 0"]
        impl crate::Resettable for TXHOLD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Aux SPI"]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi1::RegisterBlock = 0x2021_50c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI2 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI2").finish()
    }
}
#[doc = "Aux SPI"]
pub use self::spi1 as spi2;
#[doc = "Broadcom Legacy Interrupt Controller"]
pub struct LIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LIC {}
impl LIC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lic::RegisterBlock = 0x2000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lic::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LIC {
    type Target = lic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LIC").finish()
    }
}
#[doc = "Broadcom Legacy Interrupt Controller"]
pub mod lic {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x0200],
        #[doc = "0x200 - Basic pending info"]
        pub basic_pending: BASIC_PENDING,
        #[doc = "0x204 - Pending state for interrupts 1 - 31"]
        pub pending_1: PENDING_1,
        #[doc = "0x208 - Pending state for interrupts 32 - 63"]
        pub pending_2: PENDING_2,
        #[doc = "0x20c - FIQ control"]
        pub fiq_control: FIQ_CONTROL,
        #[doc = "0x210 - Enable interrupts 1 - 31"]
        pub enable_1: ENABLE_1,
        #[doc = "0x214 - Enable interrupts 32 - 63"]
        pub enable_2: ENABLE_2,
        #[doc = "0x218 - Enable basic interrupts"]
        pub enable_basic: ENABLE_BASIC,
        #[doc = "0x21c - Disable interrupts 1 - 31"]
        pub disable_1: DISABLE_1,
        #[doc = "0x220 - Disable interrupts 32 - 63"]
        pub disable_2: DISABLE_2,
        #[doc = "0x224 - Disable basic interrupts"]
        pub disable_basic: DISABLE_BASIC,
    }
    #[doc = "BASIC_PENDING (r) register accessor: Basic pending info\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`basic_pending::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@basic_pending`]
module"]
    pub type BASIC_PENDING = crate::Reg<basic_pending::BASIC_PENDING_SPEC>;
    #[doc = "Basic pending info"]
    pub mod basic_pending {
        #[doc = "Register `BASIC_PENDING` reader"]
        pub type R = crate::R<BASIC_PENDING_SPEC>;
        #[doc = "Field `TIMER` reader - ARMC Timer"]
        pub type TIMER_R = crate::BitReader;
        #[doc = "Field `MAILBOX` reader - Mailbox"]
        pub type MAILBOX_R = crate::BitReader;
        #[doc = "Field `DOORBELL0` reader - Doorbell 0"]
        pub type DOORBELL0_R = crate::BitReader;
        #[doc = "Field `DOORBELL1` reader - Doorbell 1"]
        pub type DOORBELL1_R = crate::BitReader;
        #[doc = "Field `VPU0_HALTED` reader - VPU0 halted"]
        pub type VPU0_HALTED_R = crate::BitReader;
        #[doc = "Field `VPU1_HALTED` reader - VPU1 halted"]
        pub type VPU1_HALTED_R = crate::BitReader;
        #[doc = "Field `ARM_ADDRESS_ERROR` reader - ARM address error"]
        pub type ARM_ADDRESS_ERROR_R = crate::BitReader;
        #[doc = "Field `ARM_AXI_ERROR` reader - ARM AXI error"]
        pub type ARM_AXI_ERROR_R = crate::BitReader;
        #[doc = "Field `PENDING_1` reader - One or more bits are set in PENDING_1 (ignores 7, 9, 10, 18, 19)"]
        pub type PENDING_1_R = crate::BitReader;
        #[doc = "Field `PENDING_2` reader - One or more bits are set in PENDING_2 (ignores 53 - 57, 62)"]
        pub type PENDING_2_R = crate::BitReader;
        #[doc = "Field `JPEG` reader - JPEG"]
        pub type JPEG_R = crate::BitReader;
        #[doc = "Field `USB` reader - USB"]
        pub type USB_R = crate::BitReader;
        #[doc = "Field `V3D` reader - V3D"]
        pub type V3D_R = crate::BitReader;
        #[doc = "Field `DMA_2` reader - DMA 2"]
        pub type DMA_2_R = crate::BitReader;
        #[doc = "Field `DMA_3` reader - DMA 3"]
        pub type DMA_3_R = crate::BitReader;
        #[doc = "Field `I2C` reader - OR of all I2C"]
        pub type I2C_R = crate::BitReader;
        #[doc = "Field `SPI` reader - OR of all SPI"]
        pub type SPI_R = crate::BitReader;
        #[doc = "Field `PCM_I2S` reader - PCM/I2S"]
        pub type PCM_I2S_R = crate::BitReader;
        #[doc = "Field `SDHOST` reader - SDHOST"]
        pub type SDHOST_R = crate::BitReader;
        #[doc = "Field `UART` reader - OR of all PL011 UARTs"]
        pub type UART_R = crate::BitReader;
        #[doc = "Field `EMMC` reader - OR of EMMC and EMMC2"]
        pub type EMMC_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - ARMC Timer"]
            #[inline(always)]
            pub fn timer(&self) -> TIMER_R {
                TIMER_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Mailbox"]
            #[inline(always)]
            pub fn mailbox(&self) -> MAILBOX_R {
                MAILBOX_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Doorbell 0"]
            #[inline(always)]
            pub fn doorbell0(&self) -> DOORBELL0_R {
                DOORBELL0_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Doorbell 1"]
            #[inline(always)]
            pub fn doorbell1(&self) -> DOORBELL1_R {
                DOORBELL1_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - VPU0 halted"]
            #[inline(always)]
            pub fn vpu0_halted(&self) -> VPU0_HALTED_R {
                VPU0_HALTED_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - VPU1 halted"]
            #[inline(always)]
            pub fn vpu1_halted(&self) -> VPU1_HALTED_R {
                VPU1_HALTED_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - ARM address error"]
            #[inline(always)]
            pub fn arm_address_error(&self) -> ARM_ADDRESS_ERROR_R {
                ARM_ADDRESS_ERROR_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ARM AXI error"]
            #[inline(always)]
            pub fn arm_axi_error(&self) -> ARM_AXI_ERROR_R {
                ARM_AXI_ERROR_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - One or more bits are set in PENDING_1 (ignores 7, 9, 10, 18, 19)"]
            #[inline(always)]
            pub fn pending_1(&self) -> PENDING_1_R {
                PENDING_1_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - One or more bits are set in PENDING_2 (ignores 53 - 57, 62)"]
            #[inline(always)]
            pub fn pending_2(&self) -> PENDING_2_R {
                PENDING_2_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - JPEG"]
            #[inline(always)]
            pub fn jpeg(&self) -> JPEG_R {
                JPEG_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - USB"]
            #[inline(always)]
            pub fn usb(&self) -> USB_R {
                USB_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - V3D"]
            #[inline(always)]
            pub fn v3d(&self) -> V3D_R {
                V3D_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - DMA 2"]
            #[inline(always)]
            pub fn dma_2(&self) -> DMA_2_R {
                DMA_2_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - DMA 3"]
            #[inline(always)]
            pub fn dma_3(&self) -> DMA_3_R {
                DMA_3_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - OR of all I2C"]
            #[inline(always)]
            pub fn i2c(&self) -> I2C_R {
                I2C_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - OR of all SPI"]
            #[inline(always)]
            pub fn spi(&self) -> SPI_R {
                SPI_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - PCM/I2S"]
            #[inline(always)]
            pub fn pcm_i2s(&self) -> PCM_I2S_R {
                PCM_I2S_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - SDHOST"]
            #[inline(always)]
            pub fn sdhost(&self) -> SDHOST_R {
                SDHOST_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - OR of all PL011 UARTs"]
            #[inline(always)]
            pub fn uart(&self) -> UART_R {
                UART_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - OR of EMMC and EMMC2"]
            #[inline(always)]
            pub fn emmc(&self) -> EMMC_R {
                EMMC_R::new(((self.bits >> 20) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BASIC_PENDING")
                    .field("timer", &format_args!("{}", self.timer().bit()))
                    .field("mailbox", &format_args!("{}", self.mailbox().bit()))
                    .field("doorbell0", &format_args!("{}", self.doorbell0().bit()))
                    .field("doorbell1", &format_args!("{}", self.doorbell1().bit()))
                    .field("vpu0_halted", &format_args!("{}", self.vpu0_halted().bit()))
                    .field("vpu1_halted", &format_args!("{}", self.vpu1_halted().bit()))
                    .field(
                        "arm_address_error",
                        &format_args!("{}", self.arm_address_error().bit()),
                    )
                    .field(
                        "arm_axi_error",
                        &format_args!("{}", self.arm_axi_error().bit()),
                    )
                    .field("pending_1", &format_args!("{}", self.pending_1().bit()))
                    .field("pending_2", &format_args!("{}", self.pending_2().bit()))
                    .field("jpeg", &format_args!("{}", self.jpeg().bit()))
                    .field("usb", &format_args!("{}", self.usb().bit()))
                    .field("v3d", &format_args!("{}", self.v3d().bit()))
                    .field("dma_2", &format_args!("{}", self.dma_2().bit()))
                    .field("dma_3", &format_args!("{}", self.dma_3().bit()))
                    .field("i2c", &format_args!("{}", self.i2c().bit()))
                    .field("spi", &format_args!("{}", self.spi().bit()))
                    .field("pcm_i2s", &format_args!("{}", self.pcm_i2s().bit()))
                    .field("sdhost", &format_args!("{}", self.sdhost().bit()))
                    .field("uart", &format_args!("{}", self.uart().bit()))
                    .field("emmc", &format_args!("{}", self.emmc().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<BASIC_PENDING_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Basic pending info\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`basic_pending::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BASIC_PENDING_SPEC;
        impl crate::RegisterSpec for BASIC_PENDING_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`basic_pending::R`](R) reader structure"]
        impl crate::Readable for BASIC_PENDING_SPEC {}
        #[doc = "`reset()` method sets BASIC_PENDING to value 0"]
        impl crate::Resettable for BASIC_PENDING_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "PENDING_1 (r) register accessor: Pending state for interrupts 1 - 31\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pending_1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pending_1`]
module"]
    pub type PENDING_1 = crate::Reg<pending_1::PENDING_1_SPEC>;
    #[doc = "Pending state for interrupts 1 - 31"]
    pub mod pending_1 {
        #[doc = "Register `PENDING_1` reader"]
        pub type R = crate::R<PENDING_1_SPEC>;
        #[doc = "Field `TIMER_0` reader - Timer 0"]
        pub type TIMER_0_R = crate::BitReader;
        #[doc = "Field `TIMER_1` reader - Timer 1"]
        pub type TIMER_1_R = crate::BitReader;
        #[doc = "Field `TIMER_2` reader - Timer 2"]
        pub type TIMER_2_R = crate::BitReader;
        #[doc = "Field `TIMER_3` reader - Timer 3"]
        pub type TIMER_3_R = crate::BitReader;
        #[doc = "Field `H264_0` reader - H264 0"]
        pub type H264_0_R = crate::BitReader;
        #[doc = "Field `H264_1` reader - H264 1"]
        pub type H264_1_R = crate::BitReader;
        #[doc = "Field `H264_2` reader - H264 2"]
        pub type H264_2_R = crate::BitReader;
        #[doc = "Field `JPEG` reader - JPEG"]
        pub type JPEG_R = crate::BitReader;
        #[doc = "Field `ISP` reader - ISP"]
        pub type ISP_R = crate::BitReader;
        #[doc = "Field `USB` reader - USB"]
        pub type USB_R = crate::BitReader;
        #[doc = "Field `V3D` reader - V3D"]
        pub type V3D_R = crate::BitReader;
        #[doc = "Field `TRANSPOSER` reader - Transposer"]
        pub type TRANSPOSER_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_0` reader - Multicore Sync 0"]
        pub type MULTICORE_SYNC_0_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_1` reader - Multicore Sync 1"]
        pub type MULTICORE_SYNC_1_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_2` reader - Multicore Sync 2"]
        pub type MULTICORE_SYNC_2_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_3` reader - Multicore Sync 3"]
        pub type MULTICORE_SYNC_3_R = crate::BitReader;
        #[doc = "Field `DMA_0` reader - DMA 0"]
        pub type DMA_0_R = crate::BitReader;
        #[doc = "Field `DMA_1` reader - DMA 1"]
        pub type DMA_1_R = crate::BitReader;
        #[doc = "Field `DMA_2` reader - DMA 2"]
        pub type DMA_2_R = crate::BitReader;
        #[doc = "Field `DMA_3` reader - DMA 3"]
        pub type DMA_3_R = crate::BitReader;
        #[doc = "Field `DMA_4` reader - DMA 4"]
        pub type DMA_4_R = crate::BitReader;
        #[doc = "Field `DMA_5` reader - DMA 5"]
        pub type DMA_5_R = crate::BitReader;
        #[doc = "Field `DMA_6` reader - DMA 6"]
        pub type DMA_6_R = crate::BitReader;
        #[doc = "Field `DMA_7_8` reader - OR of DMA 7 and 8"]
        pub type DMA_7_8_R = crate::BitReader;
        #[doc = "Field `DMA_9_10` reader - OR of DMA 9 and 10"]
        pub type DMA_9_10_R = crate::BitReader;
        #[doc = "Field `DMA_11` reader - DMA 11"]
        pub type DMA_11_R = crate::BitReader;
        #[doc = "Field `DMA_12` reader - DMA 12"]
        pub type DMA_12_R = crate::BitReader;
        #[doc = "Field `DMA_13` reader - DMA 13"]
        pub type DMA_13_R = crate::BitReader;
        #[doc = "Field `DMA_14` reader - DMA 14"]
        pub type DMA_14_R = crate::BitReader;
        #[doc = "Field `AUX` reader - OR of UART1, SPI1 and SPI2"]
        pub type AUX_R = crate::BitReader;
        #[doc = "Field `ARM` reader - ARM"]
        pub type ARM_R = crate::BitReader;
        #[doc = "Field `DMA_15` reader - DMA 15"]
        pub type DMA_15_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Timer 0"]
            #[inline(always)]
            pub fn timer_0(&self) -> TIMER_0_R {
                TIMER_0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Timer 1"]
            #[inline(always)]
            pub fn timer_1(&self) -> TIMER_1_R {
                TIMER_1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Timer 2"]
            #[inline(always)]
            pub fn timer_2(&self) -> TIMER_2_R {
                TIMER_2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Timer 3"]
            #[inline(always)]
            pub fn timer_3(&self) -> TIMER_3_R {
                TIMER_3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - H264 0"]
            #[inline(always)]
            pub fn h264_0(&self) -> H264_0_R {
                H264_0_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - H264 1"]
            #[inline(always)]
            pub fn h264_1(&self) -> H264_1_R {
                H264_1_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - H264 2"]
            #[inline(always)]
            pub fn h264_2(&self) -> H264_2_R {
                H264_2_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - JPEG"]
            #[inline(always)]
            pub fn jpeg(&self) -> JPEG_R {
                JPEG_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - ISP"]
            #[inline(always)]
            pub fn isp(&self) -> ISP_R {
                ISP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - USB"]
            #[inline(always)]
            pub fn usb(&self) -> USB_R {
                USB_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - V3D"]
            #[inline(always)]
            pub fn v3d(&self) -> V3D_R {
                V3D_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Transposer"]
            #[inline(always)]
            pub fn transposer(&self) -> TRANSPOSER_R {
                TRANSPOSER_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Multicore Sync 0"]
            #[inline(always)]
            pub fn multicore_sync_0(&self) -> MULTICORE_SYNC_0_R {
                MULTICORE_SYNC_0_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Multicore Sync 1"]
            #[inline(always)]
            pub fn multicore_sync_1(&self) -> MULTICORE_SYNC_1_R {
                MULTICORE_SYNC_1_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Multicore Sync 2"]
            #[inline(always)]
            pub fn multicore_sync_2(&self) -> MULTICORE_SYNC_2_R {
                MULTICORE_SYNC_2_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Multicore Sync 3"]
            #[inline(always)]
            pub fn multicore_sync_3(&self) -> MULTICORE_SYNC_3_R {
                MULTICORE_SYNC_3_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - DMA 0"]
            #[inline(always)]
            pub fn dma_0(&self) -> DMA_0_R {
                DMA_0_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - DMA 1"]
            #[inline(always)]
            pub fn dma_1(&self) -> DMA_1_R {
                DMA_1_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - DMA 2"]
            #[inline(always)]
            pub fn dma_2(&self) -> DMA_2_R {
                DMA_2_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - DMA 3"]
            #[inline(always)]
            pub fn dma_3(&self) -> DMA_3_R {
                DMA_3_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - DMA 4"]
            #[inline(always)]
            pub fn dma_4(&self) -> DMA_4_R {
                DMA_4_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - DMA 5"]
            #[inline(always)]
            pub fn dma_5(&self) -> DMA_5_R {
                DMA_5_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - DMA 6"]
            #[inline(always)]
            pub fn dma_6(&self) -> DMA_6_R {
                DMA_6_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - OR of DMA 7 and 8"]
            #[inline(always)]
            pub fn dma_7_8(&self) -> DMA_7_8_R {
                DMA_7_8_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - OR of DMA 9 and 10"]
            #[inline(always)]
            pub fn dma_9_10(&self) -> DMA_9_10_R {
                DMA_9_10_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - DMA 11"]
            #[inline(always)]
            pub fn dma_11(&self) -> DMA_11_R {
                DMA_11_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - DMA 12"]
            #[inline(always)]
            pub fn dma_12(&self) -> DMA_12_R {
                DMA_12_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - DMA 13"]
            #[inline(always)]
            pub fn dma_13(&self) -> DMA_13_R {
                DMA_13_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - DMA 14"]
            #[inline(always)]
            pub fn dma_14(&self) -> DMA_14_R {
                DMA_14_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - OR of UART1, SPI1 and SPI2"]
            #[inline(always)]
            pub fn aux(&self) -> AUX_R {
                AUX_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - ARM"]
            #[inline(always)]
            pub fn arm(&self) -> ARM_R {
                ARM_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - DMA 15"]
            #[inline(always)]
            pub fn dma_15(&self) -> DMA_15_R {
                DMA_15_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PENDING_1")
                    .field("timer_0", &format_args!("{}", self.timer_0().bit()))
                    .field("timer_1", &format_args!("{}", self.timer_1().bit()))
                    .field("timer_2", &format_args!("{}", self.timer_2().bit()))
                    .field("timer_3", &format_args!("{}", self.timer_3().bit()))
                    .field("h264_0", &format_args!("{}", self.h264_0().bit()))
                    .field("h264_1", &format_args!("{}", self.h264_1().bit()))
                    .field("h264_2", &format_args!("{}", self.h264_2().bit()))
                    .field("jpeg", &format_args!("{}", self.jpeg().bit()))
                    .field("isp", &format_args!("{}", self.isp().bit()))
                    .field("usb", &format_args!("{}", self.usb().bit()))
                    .field("v3d", &format_args!("{}", self.v3d().bit()))
                    .field("transposer", &format_args!("{}", self.transposer().bit()))
                    .field(
                        "multicore_sync_0",
                        &format_args!("{}", self.multicore_sync_0().bit()),
                    )
                    .field(
                        "multicore_sync_1",
                        &format_args!("{}", self.multicore_sync_1().bit()),
                    )
                    .field(
                        "multicore_sync_2",
                        &format_args!("{}", self.multicore_sync_2().bit()),
                    )
                    .field(
                        "multicore_sync_3",
                        &format_args!("{}", self.multicore_sync_3().bit()),
                    )
                    .field("dma_0", &format_args!("{}", self.dma_0().bit()))
                    .field("dma_1", &format_args!("{}", self.dma_1().bit()))
                    .field("dma_2", &format_args!("{}", self.dma_2().bit()))
                    .field("dma_3", &format_args!("{}", self.dma_3().bit()))
                    .field("dma_4", &format_args!("{}", self.dma_4().bit()))
                    .field("dma_5", &format_args!("{}", self.dma_5().bit()))
                    .field("dma_6", &format_args!("{}", self.dma_6().bit()))
                    .field("dma_7_8", &format_args!("{}", self.dma_7_8().bit()))
                    .field("dma_9_10", &format_args!("{}", self.dma_9_10().bit()))
                    .field("dma_11", &format_args!("{}", self.dma_11().bit()))
                    .field("dma_12", &format_args!("{}", self.dma_12().bit()))
                    .field("dma_13", &format_args!("{}", self.dma_13().bit()))
                    .field("dma_14", &format_args!("{}", self.dma_14().bit()))
                    .field("aux", &format_args!("{}", self.aux().bit()))
                    .field("arm", &format_args!("{}", self.arm().bit()))
                    .field("dma_15", &format_args!("{}", self.dma_15().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PENDING_1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Pending state for interrupts 1 - 31\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pending_1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PENDING_1_SPEC;
        impl crate::RegisterSpec for PENDING_1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pending_1::R`](R) reader structure"]
        impl crate::Readable for PENDING_1_SPEC {}
        #[doc = "`reset()` method sets PENDING_1 to value 0"]
        impl crate::Resettable for PENDING_1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "PENDING_2 (r) register accessor: Pending state for interrupts 32 - 63\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pending_2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pending_2`]
module"]
    pub type PENDING_2 = crate::Reg<pending_2::PENDING_2_SPEC>;
    #[doc = "Pending state for interrupts 32 - 63"]
    pub mod pending_2 {
        #[doc = "Register `PENDING_2` reader"]
        pub type R = crate::R<PENDING_2_SPEC>;
        #[doc = "Field `HDMI_CEC` reader - HDMI CEC"]
        pub type HDMI_CEC_R = crate::BitReader;
        #[doc = "Field `HVS` reader - HVS"]
        pub type HVS_R = crate::BitReader;
        #[doc = "Field `RPIVID` reader - RPIVID"]
        pub type RPIVID_R = crate::BitReader;
        #[doc = "Field `SDC` reader - SDC"]
        pub type SDC_R = crate::BitReader;
        #[doc = "Field `DSI_0` reader - DSI 0"]
        pub type DSI_0_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_2` reader - Pixel Valve 2"]
        pub type PIXEL_VALVE_2_R = crate::BitReader;
        #[doc = "Field `CAMERA_0` reader - Camera 0"]
        pub type CAMERA_0_R = crate::BitReader;
        #[doc = "Field `CAMERA_1` reader - Camera 1"]
        pub type CAMERA_1_R = crate::BitReader;
        #[doc = "Field `HDMI_0` reader - HDMI 0"]
        pub type HDMI_0_R = crate::BitReader;
        #[doc = "Field `HDMI_1` reader - HDMI 1"]
        pub type HDMI_1_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_3` reader - Pixel Valve 3"]
        pub type PIXEL_VALVE_3_R = crate::BitReader;
        #[doc = "Field `SPI_BSC_SLAVE` reader - SPI/BSC Slave"]
        pub type SPI_BSC_SLAVE_R = crate::BitReader;
        #[doc = "Field `DSI_1` reader - DSI 1"]
        pub type DSI_1_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_0` reader - Pixel Valve 0"]
        pub type PIXEL_VALVE_0_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_1_2` reader - OR of Pixel Valve 1 and 2"]
        pub type PIXEL_VALVE_1_2_R = crate::BitReader;
        #[doc = "Field `CPR` reader - CPR"]
        pub type CPR_R = crate::BitReader;
        #[doc = "Field `SMI` reader - SMI"]
        pub type SMI_R = crate::BitReader;
        #[doc = "Field `GPIO_0` reader - GPIO 0"]
        pub type GPIO_0_R = crate::BitReader;
        #[doc = "Field `GPIO_1` reader - GPIO 1"]
        pub type GPIO_1_R = crate::BitReader;
        #[doc = "Field `GPIO_2` reader - GPIO 2"]
        pub type GPIO_2_R = crate::BitReader;
        #[doc = "Field `GPIO_3` reader - GPIO 3"]
        pub type GPIO_3_R = crate::BitReader;
        #[doc = "Field `I2C` reader - OR of all I2C"]
        pub type I2C_R = crate::BitReader;
        #[doc = "Field `SPI` reader - OR of all SPI"]
        pub type SPI_R = crate::BitReader;
        #[doc = "Field `PCM_I2S` reader - PCM/I2S"]
        pub type PCM_I2S_R = crate::BitReader;
        #[doc = "Field `SDHOST` reader - SDHOST"]
        pub type SDHOST_R = crate::BitReader;
        #[doc = "Field `UART` reader - OR of all PL011 UARTs"]
        pub type UART_R = crate::BitReader;
        #[doc = "Field `ETH_PCIE` reader - OR of all ETH_PCIe L2"]
        pub type ETH_PCIE_R = crate::BitReader;
        #[doc = "Field `VEC` reader - VEC"]
        pub type VEC_R = crate::BitReader;
        #[doc = "Field `CPG` reader - CPG"]
        pub type CPG_R = crate::BitReader;
        #[doc = "Field `RNG` reader - RNG"]
        pub type RNG_R = crate::BitReader;
        #[doc = "Field `EMMC` reader - OR of EMMC and EMMC2"]
        pub type EMMC_R = crate::BitReader;
        #[doc = "Field `ETH_PCIE_SECURE` reader - ETH_PCIe secure"]
        pub type ETH_PCIE_SECURE_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - HDMI CEC"]
            #[inline(always)]
            pub fn hdmi_cec(&self) -> HDMI_CEC_R {
                HDMI_CEC_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - HVS"]
            #[inline(always)]
            pub fn hvs(&self) -> HVS_R {
                HVS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RPIVID"]
            #[inline(always)]
            pub fn rpivid(&self) -> RPIVID_R {
                RPIVID_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - SDC"]
            #[inline(always)]
            pub fn sdc(&self) -> SDC_R {
                SDC_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - DSI 0"]
            #[inline(always)]
            pub fn dsi_0(&self) -> DSI_0_R {
                DSI_0_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Pixel Valve 2"]
            #[inline(always)]
            pub fn pixel_valve_2(&self) -> PIXEL_VALVE_2_R {
                PIXEL_VALVE_2_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Camera 0"]
            #[inline(always)]
            pub fn camera_0(&self) -> CAMERA_0_R {
                CAMERA_0_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Camera 1"]
            #[inline(always)]
            pub fn camera_1(&self) -> CAMERA_1_R {
                CAMERA_1_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - HDMI 0"]
            #[inline(always)]
            pub fn hdmi_0(&self) -> HDMI_0_R {
                HDMI_0_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - HDMI 1"]
            #[inline(always)]
            pub fn hdmi_1(&self) -> HDMI_1_R {
                HDMI_1_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Pixel Valve 3"]
            #[inline(always)]
            pub fn pixel_valve_3(&self) -> PIXEL_VALVE_3_R {
                PIXEL_VALVE_3_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - SPI/BSC Slave"]
            #[inline(always)]
            pub fn spi_bsc_slave(&self) -> SPI_BSC_SLAVE_R {
                SPI_BSC_SLAVE_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - DSI 1"]
            #[inline(always)]
            pub fn dsi_1(&self) -> DSI_1_R {
                DSI_1_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Pixel Valve 0"]
            #[inline(always)]
            pub fn pixel_valve_0(&self) -> PIXEL_VALVE_0_R {
                PIXEL_VALVE_0_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - OR of Pixel Valve 1 and 2"]
            #[inline(always)]
            pub fn pixel_valve_1_2(&self) -> PIXEL_VALVE_1_2_R {
                PIXEL_VALVE_1_2_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - CPR"]
            #[inline(always)]
            pub fn cpr(&self) -> CPR_R {
                CPR_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - SMI"]
            #[inline(always)]
            pub fn smi(&self) -> SMI_R {
                SMI_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - GPIO 0"]
            #[inline(always)]
            pub fn gpio_0(&self) -> GPIO_0_R {
                GPIO_0_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - GPIO 1"]
            #[inline(always)]
            pub fn gpio_1(&self) -> GPIO_1_R {
                GPIO_1_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - GPIO 2"]
            #[inline(always)]
            pub fn gpio_2(&self) -> GPIO_2_R {
                GPIO_2_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - GPIO 3"]
            #[inline(always)]
            pub fn gpio_3(&self) -> GPIO_3_R {
                GPIO_3_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - OR of all I2C"]
            #[inline(always)]
            pub fn i2c(&self) -> I2C_R {
                I2C_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - OR of all SPI"]
            #[inline(always)]
            pub fn spi(&self) -> SPI_R {
                SPI_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - PCM/I2S"]
            #[inline(always)]
            pub fn pcm_i2s(&self) -> PCM_I2S_R {
                PCM_I2S_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - SDHOST"]
            #[inline(always)]
            pub fn sdhost(&self) -> SDHOST_R {
                SDHOST_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - OR of all PL011 UARTs"]
            #[inline(always)]
            pub fn uart(&self) -> UART_R {
                UART_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - OR of all ETH_PCIe L2"]
            #[inline(always)]
            pub fn eth_pcie(&self) -> ETH_PCIE_R {
                ETH_PCIE_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - VEC"]
            #[inline(always)]
            pub fn vec(&self) -> VEC_R {
                VEC_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - CPG"]
            #[inline(always)]
            pub fn cpg(&self) -> CPG_R {
                CPG_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - RNG"]
            #[inline(always)]
            pub fn rng(&self) -> RNG_R {
                RNG_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - OR of EMMC and EMMC2"]
            #[inline(always)]
            pub fn emmc(&self) -> EMMC_R {
                EMMC_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - ETH_PCIe secure"]
            #[inline(always)]
            pub fn eth_pcie_secure(&self) -> ETH_PCIE_SECURE_R {
                ETH_PCIE_SECURE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PENDING_2")
                    .field("hdmi_cec", &format_args!("{}", self.hdmi_cec().bit()))
                    .field("hvs", &format_args!("{}", self.hvs().bit()))
                    .field("rpivid", &format_args!("{}", self.rpivid().bit()))
                    .field("sdc", &format_args!("{}", self.sdc().bit()))
                    .field("dsi_0", &format_args!("{}", self.dsi_0().bit()))
                    .field(
                        "pixel_valve_2",
                        &format_args!("{}", self.pixel_valve_2().bit()),
                    )
                    .field("camera_0", &format_args!("{}", self.camera_0().bit()))
                    .field("camera_1", &format_args!("{}", self.camera_1().bit()))
                    .field("hdmi_0", &format_args!("{}", self.hdmi_0().bit()))
                    .field("hdmi_1", &format_args!("{}", self.hdmi_1().bit()))
                    .field(
                        "pixel_valve_3",
                        &format_args!("{}", self.pixel_valve_3().bit()),
                    )
                    .field(
                        "spi_bsc_slave",
                        &format_args!("{}", self.spi_bsc_slave().bit()),
                    )
                    .field("dsi_1", &format_args!("{}", self.dsi_1().bit()))
                    .field(
                        "pixel_valve_0",
                        &format_args!("{}", self.pixel_valve_0().bit()),
                    )
                    .field(
                        "pixel_valve_1_2",
                        &format_args!("{}", self.pixel_valve_1_2().bit()),
                    )
                    .field("cpr", &format_args!("{}", self.cpr().bit()))
                    .field("smi", &format_args!("{}", self.smi().bit()))
                    .field("gpio_0", &format_args!("{}", self.gpio_0().bit()))
                    .field("gpio_1", &format_args!("{}", self.gpio_1().bit()))
                    .field("gpio_2", &format_args!("{}", self.gpio_2().bit()))
                    .field("gpio_3", &format_args!("{}", self.gpio_3().bit()))
                    .field("i2c", &format_args!("{}", self.i2c().bit()))
                    .field("spi", &format_args!("{}", self.spi().bit()))
                    .field("pcm_i2s", &format_args!("{}", self.pcm_i2s().bit()))
                    .field("sdhost", &format_args!("{}", self.sdhost().bit()))
                    .field("uart", &format_args!("{}", self.uart().bit()))
                    .field("eth_pcie", &format_args!("{}", self.eth_pcie().bit()))
                    .field("vec", &format_args!("{}", self.vec().bit()))
                    .field("cpg", &format_args!("{}", self.cpg().bit()))
                    .field("rng", &format_args!("{}", self.rng().bit()))
                    .field("emmc", &format_args!("{}", self.emmc().bit()))
                    .field(
                        "eth_pcie_secure",
                        &format_args!("{}", self.eth_pcie_secure().bit()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PENDING_2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Pending state for interrupts 32 - 63\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pending_2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PENDING_2_SPEC;
        impl crate::RegisterSpec for PENDING_2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pending_2::R`](R) reader structure"]
        impl crate::Readable for PENDING_2_SPEC {}
        #[doc = "`reset()` method sets PENDING_2 to value 0"]
        impl crate::Resettable for PENDING_2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "FIQ_CONTROL (rw) register accessor: FIQ control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fiq_control::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiq_control::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiq_control`]
module"]
    pub type FIQ_CONTROL = crate::Reg<fiq_control::FIQ_CONTROL_SPEC>;
    #[doc = "FIQ control"]
    pub mod fiq_control {
        #[doc = "Register `FIQ_CONTROL` reader"]
        pub type R = crate::R<FIQ_CONTROL_SPEC>;
        #[doc = "Register `FIQ_CONTROL` writer"]
        pub type W = crate::W<FIQ_CONTROL_SPEC>;
        #[doc = "Field `SOURCE` reader - FIQ Source"]
        pub type SOURCE_R = crate::FieldReader<SOURCE_A>;
        #[doc = "FIQ Source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SOURCE_A {
            #[doc = "0: Timer 0"]
            TIMER_0 = 0,
            #[doc = "1: Timer 1"]
            TIMER_1 = 1,
            #[doc = "2: Timer 2"]
            TIMER_2 = 2,
            #[doc = "3: Timer 3"]
            TIMER_3 = 3,
            #[doc = "4: H264 0"]
            H264_0 = 4,
            #[doc = "5: H264 1"]
            H264_1 = 5,
            #[doc = "6: H264 2"]
            H264_2 = 6,
            #[doc = "7: JPEG"]
            JPEG = 7,
            #[doc = "8: ISP"]
            ISP = 8,
            #[doc = "9: USB"]
            USB = 9,
            #[doc = "10: V3D"]
            V3D = 10,
            #[doc = "11: Transposer"]
            TRANSPOSER = 11,
            #[doc = "12: Multicore Sync 0"]
            MULTICORE_SYNC_0 = 12,
            #[doc = "13: Multicore Sync 1"]
            MULTICORE_SYNC_1 = 13,
            #[doc = "14: Multicore Sync 2"]
            MULTICORE_SYNC_2 = 14,
            #[doc = "15: Multicore Sync 3"]
            MULTICORE_SYNC_3 = 15,
            #[doc = "16: DMA 0"]
            DMA_0 = 16,
            #[doc = "17: DMA 1"]
            DMA_1 = 17,
            #[doc = "18: DMA 2"]
            DMA_2 = 18,
            #[doc = "19: DMA 3"]
            DMA_3 = 19,
            #[doc = "20: DMA 4"]
            DMA_4 = 20,
            #[doc = "21: DMA 5"]
            DMA_5 = 21,
            #[doc = "22: DMA 6"]
            DMA_6 = 22,
            #[doc = "23: OR of DMA 7 and 8"]
            DMA_7_8 = 23,
            #[doc = "24: OR of DMA 9 and 10"]
            DMA_9_10 = 24,
            #[doc = "25: DMA 11"]
            DMA_11 = 25,
            #[doc = "26: DMA 12"]
            DMA_12 = 26,
            #[doc = "27: DMA 13"]
            DMA_13 = 27,
            #[doc = "28: DMA 14"]
            DMA_14 = 28,
            #[doc = "29: OR of UART1, SPI1 and SPI2"]
            AUX = 29,
            #[doc = "30: ARM"]
            ARM = 30,
            #[doc = "31: DMA 15"]
            DMA_15 = 31,
            #[doc = "32: HDMI CEC"]
            HDMI_CEC = 32,
            #[doc = "33: HVS"]
            HVS = 33,
            #[doc = "34: RPIVID"]
            RPIVID = 34,
            #[doc = "35: SDC"]
            SDC = 35,
            #[doc = "36: DSI 0"]
            DSI_0 = 36,
            #[doc = "37: Pixel Valve 2"]
            PIXEL_VALVE_2 = 37,
            #[doc = "38: Camera 0"]
            CAMERA_0 = 38,
            #[doc = "39: Camera 1"]
            CAMERA_1 = 39,
            #[doc = "40: HDMI 0"]
            HDMI_0 = 40,
            #[doc = "41: HDMI 1"]
            HDMI_1 = 41,
            #[doc = "42: Pixel Valve 3"]
            PIXEL_VALVE_3 = 42,
            #[doc = "43: SPI/BSC Slave"]
            SPI_BSC_SLAVE = 43,
            #[doc = "44: DSI 1"]
            DSI_1 = 44,
            #[doc = "45: Pixel Valve 0"]
            PIXEL_VALVE_0 = 45,
            #[doc = "46: OR of Pixel Valve 1 and 2"]
            PIXEL_VALVE_1_2 = 46,
            #[doc = "47: CPR"]
            CPR = 47,
            #[doc = "48: SMI"]
            SMI = 48,
            #[doc = "49: GPIO 0"]
            GPIO_0 = 49,
            #[doc = "50: GPIO 1"]
            GPIO_1 = 50,
            #[doc = "51: GPIO 2"]
            GPIO_2 = 51,
            #[doc = "52: GPIO 3"]
            GPIO_3 = 52,
            #[doc = "53: OR of all I2C"]
            I2C = 53,
            #[doc = "54: OR of all SPI"]
            SPI = 54,
            #[doc = "55: PCM/I2S"]
            PCM_I2S = 55,
            #[doc = "56: SDHOST"]
            SDHOST = 56,
            #[doc = "57: OR of all PL011 UARTs"]
            UART = 57,
            #[doc = "58: OR of all ETH_PCIe L2"]
            ETH_PCIE = 58,
            #[doc = "59: VEC"]
            VEC = 59,
            #[doc = "60: CPG"]
            CPG = 60,
            #[doc = "61: RNG"]
            RNG = 61,
            #[doc = "62: OR of EMMC and EMMC2"]
            EMMC = 62,
            #[doc = "63: ETH_PCIe secure"]
            ETH_PCIE_SECURE = 63,
            #[doc = "64: ARMC Timer"]
            TIMER = 64,
            #[doc = "65: Mailbox"]
            MAILBOX = 65,
            #[doc = "66: Doorbell 0"]
            DOORBELL0 = 66,
            #[doc = "67: Doorbell 1"]
            DOORBELL1 = 67,
            #[doc = "68: VPU0 halted"]
            VPU0_HALTED = 68,
            #[doc = "69: VPU1 halted"]
            VPU1_HALTED = 69,
            #[doc = "70: ARM address error"]
            ARM_ADDRESS_ERROR = 70,
            #[doc = "71: ARM AXI error"]
            ARM_AXI_ERROR = 71,
        }
        impl From<SOURCE_A> for u8 {
            #[inline(always)]
            fn from(variant: SOURCE_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for SOURCE_A {
            type Ux = u8;
        }
        impl SOURCE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<SOURCE_A> {
                match self.bits {
                    0 => Some(SOURCE_A::TIMER_0),
                    1 => Some(SOURCE_A::TIMER_1),
                    2 => Some(SOURCE_A::TIMER_2),
                    3 => Some(SOURCE_A::TIMER_3),
                    4 => Some(SOURCE_A::H264_0),
                    5 => Some(SOURCE_A::H264_1),
                    6 => Some(SOURCE_A::H264_2),
                    7 => Some(SOURCE_A::JPEG),
                    8 => Some(SOURCE_A::ISP),
                    9 => Some(SOURCE_A::USB),
                    10 => Some(SOURCE_A::V3D),
                    11 => Some(SOURCE_A::TRANSPOSER),
                    12 => Some(SOURCE_A::MULTICORE_SYNC_0),
                    13 => Some(SOURCE_A::MULTICORE_SYNC_1),
                    14 => Some(SOURCE_A::MULTICORE_SYNC_2),
                    15 => Some(SOURCE_A::MULTICORE_SYNC_3),
                    16 => Some(SOURCE_A::DMA_0),
                    17 => Some(SOURCE_A::DMA_1),
                    18 => Some(SOURCE_A::DMA_2),
                    19 => Some(SOURCE_A::DMA_3),
                    20 => Some(SOURCE_A::DMA_4),
                    21 => Some(SOURCE_A::DMA_5),
                    22 => Some(SOURCE_A::DMA_6),
                    23 => Some(SOURCE_A::DMA_7_8),
                    24 => Some(SOURCE_A::DMA_9_10),
                    25 => Some(SOURCE_A::DMA_11),
                    26 => Some(SOURCE_A::DMA_12),
                    27 => Some(SOURCE_A::DMA_13),
                    28 => Some(SOURCE_A::DMA_14),
                    29 => Some(SOURCE_A::AUX),
                    30 => Some(SOURCE_A::ARM),
                    31 => Some(SOURCE_A::DMA_15),
                    32 => Some(SOURCE_A::HDMI_CEC),
                    33 => Some(SOURCE_A::HVS),
                    34 => Some(SOURCE_A::RPIVID),
                    35 => Some(SOURCE_A::SDC),
                    36 => Some(SOURCE_A::DSI_0),
                    37 => Some(SOURCE_A::PIXEL_VALVE_2),
                    38 => Some(SOURCE_A::CAMERA_0),
                    39 => Some(SOURCE_A::CAMERA_1),
                    40 => Some(SOURCE_A::HDMI_0),
                    41 => Some(SOURCE_A::HDMI_1),
                    42 => Some(SOURCE_A::PIXEL_VALVE_3),
                    43 => Some(SOURCE_A::SPI_BSC_SLAVE),
                    44 => Some(SOURCE_A::DSI_1),
                    45 => Some(SOURCE_A::PIXEL_VALVE_0),
                    46 => Some(SOURCE_A::PIXEL_VALVE_1_2),
                    47 => Some(SOURCE_A::CPR),
                    48 => Some(SOURCE_A::SMI),
                    49 => Some(SOURCE_A::GPIO_0),
                    50 => Some(SOURCE_A::GPIO_1),
                    51 => Some(SOURCE_A::GPIO_2),
                    52 => Some(SOURCE_A::GPIO_3),
                    53 => Some(SOURCE_A::I2C),
                    54 => Some(SOURCE_A::SPI),
                    55 => Some(SOURCE_A::PCM_I2S),
                    56 => Some(SOURCE_A::SDHOST),
                    57 => Some(SOURCE_A::UART),
                    58 => Some(SOURCE_A::ETH_PCIE),
                    59 => Some(SOURCE_A::VEC),
                    60 => Some(SOURCE_A::CPG),
                    61 => Some(SOURCE_A::RNG),
                    62 => Some(SOURCE_A::EMMC),
                    63 => Some(SOURCE_A::ETH_PCIE_SECURE),
                    64 => Some(SOURCE_A::TIMER),
                    65 => Some(SOURCE_A::MAILBOX),
                    66 => Some(SOURCE_A::DOORBELL0),
                    67 => Some(SOURCE_A::DOORBELL1),
                    68 => Some(SOURCE_A::VPU0_HALTED),
                    69 => Some(SOURCE_A::VPU1_HALTED),
                    70 => Some(SOURCE_A::ARM_ADDRESS_ERROR),
                    71 => Some(SOURCE_A::ARM_AXI_ERROR),
                    _ => None,
                }
            }
            #[doc = "Timer 0"]
            #[inline(always)]
            pub fn is_timer_0(&self) -> bool {
                *self == SOURCE_A::TIMER_0
            }
            #[doc = "Timer 1"]
            #[inline(always)]
            pub fn is_timer_1(&self) -> bool {
                *self == SOURCE_A::TIMER_1
            }
            #[doc = "Timer 2"]
            #[inline(always)]
            pub fn is_timer_2(&self) -> bool {
                *self == SOURCE_A::TIMER_2
            }
            #[doc = "Timer 3"]
            #[inline(always)]
            pub fn is_timer_3(&self) -> bool {
                *self == SOURCE_A::TIMER_3
            }
            #[doc = "H264 0"]
            #[inline(always)]
            pub fn is_h264_0(&self) -> bool {
                *self == SOURCE_A::H264_0
            }
            #[doc = "H264 1"]
            #[inline(always)]
            pub fn is_h264_1(&self) -> bool {
                *self == SOURCE_A::H264_1
            }
            #[doc = "H264 2"]
            #[inline(always)]
            pub fn is_h264_2(&self) -> bool {
                *self == SOURCE_A::H264_2
            }
            #[doc = "JPEG"]
            #[inline(always)]
            pub fn is_jpeg(&self) -> bool {
                *self == SOURCE_A::JPEG
            }
            #[doc = "ISP"]
            #[inline(always)]
            pub fn is_isp(&self) -> bool {
                *self == SOURCE_A::ISP
            }
            #[doc = "USB"]
            #[inline(always)]
            pub fn is_usb(&self) -> bool {
                *self == SOURCE_A::USB
            }
            #[doc = "V3D"]
            #[inline(always)]
            pub fn is_v3d(&self) -> bool {
                *self == SOURCE_A::V3D
            }
            #[doc = "Transposer"]
            #[inline(always)]
            pub fn is_transposer(&self) -> bool {
                *self == SOURCE_A::TRANSPOSER
            }
            #[doc = "Multicore Sync 0"]
            #[inline(always)]
            pub fn is_multicore_sync_0(&self) -> bool {
                *self == SOURCE_A::MULTICORE_SYNC_0
            }
            #[doc = "Multicore Sync 1"]
            #[inline(always)]
            pub fn is_multicore_sync_1(&self) -> bool {
                *self == SOURCE_A::MULTICORE_SYNC_1
            }
            #[doc = "Multicore Sync 2"]
            #[inline(always)]
            pub fn is_multicore_sync_2(&self) -> bool {
                *self == SOURCE_A::MULTICORE_SYNC_2
            }
            #[doc = "Multicore Sync 3"]
            #[inline(always)]
            pub fn is_multicore_sync_3(&self) -> bool {
                *self == SOURCE_A::MULTICORE_SYNC_3
            }
            #[doc = "DMA 0"]
            #[inline(always)]
            pub fn is_dma_0(&self) -> bool {
                *self == SOURCE_A::DMA_0
            }
            #[doc = "DMA 1"]
            #[inline(always)]
            pub fn is_dma_1(&self) -> bool {
                *self == SOURCE_A::DMA_1
            }
            #[doc = "DMA 2"]
            #[inline(always)]
            pub fn is_dma_2(&self) -> bool {
                *self == SOURCE_A::DMA_2
            }
            #[doc = "DMA 3"]
            #[inline(always)]
            pub fn is_dma_3(&self) -> bool {
                *self == SOURCE_A::DMA_3
            }
            #[doc = "DMA 4"]
            #[inline(always)]
            pub fn is_dma_4(&self) -> bool {
                *self == SOURCE_A::DMA_4
            }
            #[doc = "DMA 5"]
            #[inline(always)]
            pub fn is_dma_5(&self) -> bool {
                *self == SOURCE_A::DMA_5
            }
            #[doc = "DMA 6"]
            #[inline(always)]
            pub fn is_dma_6(&self) -> bool {
                *self == SOURCE_A::DMA_6
            }
            #[doc = "OR of DMA 7 and 8"]
            #[inline(always)]
            pub fn is_dma_7_8(&self) -> bool {
                *self == SOURCE_A::DMA_7_8
            }
            #[doc = "OR of DMA 9 and 10"]
            #[inline(always)]
            pub fn is_dma_9_10(&self) -> bool {
                *self == SOURCE_A::DMA_9_10
            }
            #[doc = "DMA 11"]
            #[inline(always)]
            pub fn is_dma_11(&self) -> bool {
                *self == SOURCE_A::DMA_11
            }
            #[doc = "DMA 12"]
            #[inline(always)]
            pub fn is_dma_12(&self) -> bool {
                *self == SOURCE_A::DMA_12
            }
            #[doc = "DMA 13"]
            #[inline(always)]
            pub fn is_dma_13(&self) -> bool {
                *self == SOURCE_A::DMA_13
            }
            #[doc = "DMA 14"]
            #[inline(always)]
            pub fn is_dma_14(&self) -> bool {
                *self == SOURCE_A::DMA_14
            }
            #[doc = "OR of UART1, SPI1 and SPI2"]
            #[inline(always)]
            pub fn is_aux(&self) -> bool {
                *self == SOURCE_A::AUX
            }
            #[doc = "ARM"]
            #[inline(always)]
            pub fn is_arm(&self) -> bool {
                *self == SOURCE_A::ARM
            }
            #[doc = "DMA 15"]
            #[inline(always)]
            pub fn is_dma_15(&self) -> bool {
                *self == SOURCE_A::DMA_15
            }
            #[doc = "HDMI CEC"]
            #[inline(always)]
            pub fn is_hdmi_cec(&self) -> bool {
                *self == SOURCE_A::HDMI_CEC
            }
            #[doc = "HVS"]
            #[inline(always)]
            pub fn is_hvs(&self) -> bool {
                *self == SOURCE_A::HVS
            }
            #[doc = "RPIVID"]
            #[inline(always)]
            pub fn is_rpivid(&self) -> bool {
                *self == SOURCE_A::RPIVID
            }
            #[doc = "SDC"]
            #[inline(always)]
            pub fn is_sdc(&self) -> bool {
                *self == SOURCE_A::SDC
            }
            #[doc = "DSI 0"]
            #[inline(always)]
            pub fn is_dsi_0(&self) -> bool {
                *self == SOURCE_A::DSI_0
            }
            #[doc = "Pixel Valve 2"]
            #[inline(always)]
            pub fn is_pixel_valve_2(&self) -> bool {
                *self == SOURCE_A::PIXEL_VALVE_2
            }
            #[doc = "Camera 0"]
            #[inline(always)]
            pub fn is_camera_0(&self) -> bool {
                *self == SOURCE_A::CAMERA_0
            }
            #[doc = "Camera 1"]
            #[inline(always)]
            pub fn is_camera_1(&self) -> bool {
                *self == SOURCE_A::CAMERA_1
            }
            #[doc = "HDMI 0"]
            #[inline(always)]
            pub fn is_hdmi_0(&self) -> bool {
                *self == SOURCE_A::HDMI_0
            }
            #[doc = "HDMI 1"]
            #[inline(always)]
            pub fn is_hdmi_1(&self) -> bool {
                *self == SOURCE_A::HDMI_1
            }
            #[doc = "Pixel Valve 3"]
            #[inline(always)]
            pub fn is_pixel_valve_3(&self) -> bool {
                *self == SOURCE_A::PIXEL_VALVE_3
            }
            #[doc = "SPI/BSC Slave"]
            #[inline(always)]
            pub fn is_spi_bsc_slave(&self) -> bool {
                *self == SOURCE_A::SPI_BSC_SLAVE
            }
            #[doc = "DSI 1"]
            #[inline(always)]
            pub fn is_dsi_1(&self) -> bool {
                *self == SOURCE_A::DSI_1
            }
            #[doc = "Pixel Valve 0"]
            #[inline(always)]
            pub fn is_pixel_valve_0(&self) -> bool {
                *self == SOURCE_A::PIXEL_VALVE_0
            }
            #[doc = "OR of Pixel Valve 1 and 2"]
            #[inline(always)]
            pub fn is_pixel_valve_1_2(&self) -> bool {
                *self == SOURCE_A::PIXEL_VALVE_1_2
            }
            #[doc = "CPR"]
            #[inline(always)]
            pub fn is_cpr(&self) -> bool {
                *self == SOURCE_A::CPR
            }
            #[doc = "SMI"]
            #[inline(always)]
            pub fn is_smi(&self) -> bool {
                *self == SOURCE_A::SMI
            }
            #[doc = "GPIO 0"]
            #[inline(always)]
            pub fn is_gpio_0(&self) -> bool {
                *self == SOURCE_A::GPIO_0
            }
            #[doc = "GPIO 1"]
            #[inline(always)]
            pub fn is_gpio_1(&self) -> bool {
                *self == SOURCE_A::GPIO_1
            }
            #[doc = "GPIO 2"]
            #[inline(always)]
            pub fn is_gpio_2(&self) -> bool {
                *self == SOURCE_A::GPIO_2
            }
            #[doc = "GPIO 3"]
            #[inline(always)]
            pub fn is_gpio_3(&self) -> bool {
                *self == SOURCE_A::GPIO_3
            }
            #[doc = "OR of all I2C"]
            #[inline(always)]
            pub fn is_i2c(&self) -> bool {
                *self == SOURCE_A::I2C
            }
            #[doc = "OR of all SPI"]
            #[inline(always)]
            pub fn is_spi(&self) -> bool {
                *self == SOURCE_A::SPI
            }
            #[doc = "PCM/I2S"]
            #[inline(always)]
            pub fn is_pcm_i2s(&self) -> bool {
                *self == SOURCE_A::PCM_I2S
            }
            #[doc = "SDHOST"]
            #[inline(always)]
            pub fn is_sdhost(&self) -> bool {
                *self == SOURCE_A::SDHOST
            }
            #[doc = "OR of all PL011 UARTs"]
            #[inline(always)]
            pub fn is_uart(&self) -> bool {
                *self == SOURCE_A::UART
            }
            #[doc = "OR of all ETH_PCIe L2"]
            #[inline(always)]
            pub fn is_eth_pcie(&self) -> bool {
                *self == SOURCE_A::ETH_PCIE
            }
            #[doc = "VEC"]
            #[inline(always)]
            pub fn is_vec(&self) -> bool {
                *self == SOURCE_A::VEC
            }
            #[doc = "CPG"]
            #[inline(always)]
            pub fn is_cpg(&self) -> bool {
                *self == SOURCE_A::CPG
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub fn is_rng(&self) -> bool {
                *self == SOURCE_A::RNG
            }
            #[doc = "OR of EMMC and EMMC2"]
            #[inline(always)]
            pub fn is_emmc(&self) -> bool {
                *self == SOURCE_A::EMMC
            }
            #[doc = "ETH_PCIe secure"]
            #[inline(always)]
            pub fn is_eth_pcie_secure(&self) -> bool {
                *self == SOURCE_A::ETH_PCIE_SECURE
            }
            #[doc = "ARMC Timer"]
            #[inline(always)]
            pub fn is_timer(&self) -> bool {
                *self == SOURCE_A::TIMER
            }
            #[doc = "Mailbox"]
            #[inline(always)]
            pub fn is_mailbox(&self) -> bool {
                *self == SOURCE_A::MAILBOX
            }
            #[doc = "Doorbell 0"]
            #[inline(always)]
            pub fn is_doorbell0(&self) -> bool {
                *self == SOURCE_A::DOORBELL0
            }
            #[doc = "Doorbell 1"]
            #[inline(always)]
            pub fn is_doorbell1(&self) -> bool {
                *self == SOURCE_A::DOORBELL1
            }
            #[doc = "VPU0 halted"]
            #[inline(always)]
            pub fn is_vpu0_halted(&self) -> bool {
                *self == SOURCE_A::VPU0_HALTED
            }
            #[doc = "VPU1 halted"]
            #[inline(always)]
            pub fn is_vpu1_halted(&self) -> bool {
                *self == SOURCE_A::VPU1_HALTED
            }
            #[doc = "ARM address error"]
            #[inline(always)]
            pub fn is_arm_address_error(&self) -> bool {
                *self == SOURCE_A::ARM_ADDRESS_ERROR
            }
            #[doc = "ARM AXI error"]
            #[inline(always)]
            pub fn is_arm_axi_error(&self) -> bool {
                *self == SOURCE_A::ARM_AXI_ERROR
            }
        }
        #[doc = "Field `SOURCE` writer - FIQ Source"]
        pub type SOURCE_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 7, O, SOURCE_A>;
        impl<'a, REG, const O: u8> SOURCE_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Timer 0"]
            #[inline(always)]
            pub fn timer_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::TIMER_0)
            }
            #[doc = "Timer 1"]
            #[inline(always)]
            pub fn timer_1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::TIMER_1)
            }
            #[doc = "Timer 2"]
            #[inline(always)]
            pub fn timer_2(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::TIMER_2)
            }
            #[doc = "Timer 3"]
            #[inline(always)]
            pub fn timer_3(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::TIMER_3)
            }
            #[doc = "H264 0"]
            #[inline(always)]
            pub fn h264_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::H264_0)
            }
            #[doc = "H264 1"]
            #[inline(always)]
            pub fn h264_1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::H264_1)
            }
            #[doc = "H264 2"]
            #[inline(always)]
            pub fn h264_2(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::H264_2)
            }
            #[doc = "JPEG"]
            #[inline(always)]
            pub fn jpeg(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::JPEG)
            }
            #[doc = "ISP"]
            #[inline(always)]
            pub fn isp(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::ISP)
            }
            #[doc = "USB"]
            #[inline(always)]
            pub fn usb(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::USB)
            }
            #[doc = "V3D"]
            #[inline(always)]
            pub fn v3d(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::V3D)
            }
            #[doc = "Transposer"]
            #[inline(always)]
            pub fn transposer(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::TRANSPOSER)
            }
            #[doc = "Multicore Sync 0"]
            #[inline(always)]
            pub fn multicore_sync_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::MULTICORE_SYNC_0)
            }
            #[doc = "Multicore Sync 1"]
            #[inline(always)]
            pub fn multicore_sync_1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::MULTICORE_SYNC_1)
            }
            #[doc = "Multicore Sync 2"]
            #[inline(always)]
            pub fn multicore_sync_2(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::MULTICORE_SYNC_2)
            }
            #[doc = "Multicore Sync 3"]
            #[inline(always)]
            pub fn multicore_sync_3(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::MULTICORE_SYNC_3)
            }
            #[doc = "DMA 0"]
            #[inline(always)]
            pub fn dma_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_0)
            }
            #[doc = "DMA 1"]
            #[inline(always)]
            pub fn dma_1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_1)
            }
            #[doc = "DMA 2"]
            #[inline(always)]
            pub fn dma_2(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_2)
            }
            #[doc = "DMA 3"]
            #[inline(always)]
            pub fn dma_3(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_3)
            }
            #[doc = "DMA 4"]
            #[inline(always)]
            pub fn dma_4(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_4)
            }
            #[doc = "DMA 5"]
            #[inline(always)]
            pub fn dma_5(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_5)
            }
            #[doc = "DMA 6"]
            #[inline(always)]
            pub fn dma_6(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_6)
            }
            #[doc = "OR of DMA 7 and 8"]
            #[inline(always)]
            pub fn dma_7_8(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_7_8)
            }
            #[doc = "OR of DMA 9 and 10"]
            #[inline(always)]
            pub fn dma_9_10(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_9_10)
            }
            #[doc = "DMA 11"]
            #[inline(always)]
            pub fn dma_11(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_11)
            }
            #[doc = "DMA 12"]
            #[inline(always)]
            pub fn dma_12(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_12)
            }
            #[doc = "DMA 13"]
            #[inline(always)]
            pub fn dma_13(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_13)
            }
            #[doc = "DMA 14"]
            #[inline(always)]
            pub fn dma_14(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_14)
            }
            #[doc = "OR of UART1, SPI1 and SPI2"]
            #[inline(always)]
            pub fn aux(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::AUX)
            }
            #[doc = "ARM"]
            #[inline(always)]
            pub fn arm(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::ARM)
            }
            #[doc = "DMA 15"]
            #[inline(always)]
            pub fn dma_15(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DMA_15)
            }
            #[doc = "HDMI CEC"]
            #[inline(always)]
            pub fn hdmi_cec(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::HDMI_CEC)
            }
            #[doc = "HVS"]
            #[inline(always)]
            pub fn hvs(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::HVS)
            }
            #[doc = "RPIVID"]
            #[inline(always)]
            pub fn rpivid(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::RPIVID)
            }
            #[doc = "SDC"]
            #[inline(always)]
            pub fn sdc(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::SDC)
            }
            #[doc = "DSI 0"]
            #[inline(always)]
            pub fn dsi_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DSI_0)
            }
            #[doc = "Pixel Valve 2"]
            #[inline(always)]
            pub fn pixel_valve_2(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::PIXEL_VALVE_2)
            }
            #[doc = "Camera 0"]
            #[inline(always)]
            pub fn camera_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::CAMERA_0)
            }
            #[doc = "Camera 1"]
            #[inline(always)]
            pub fn camera_1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::CAMERA_1)
            }
            #[doc = "HDMI 0"]
            #[inline(always)]
            pub fn hdmi_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::HDMI_0)
            }
            #[doc = "HDMI 1"]
            #[inline(always)]
            pub fn hdmi_1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::HDMI_1)
            }
            #[doc = "Pixel Valve 3"]
            #[inline(always)]
            pub fn pixel_valve_3(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::PIXEL_VALVE_3)
            }
            #[doc = "SPI/BSC Slave"]
            #[inline(always)]
            pub fn spi_bsc_slave(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::SPI_BSC_SLAVE)
            }
            #[doc = "DSI 1"]
            #[inline(always)]
            pub fn dsi_1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DSI_1)
            }
            #[doc = "Pixel Valve 0"]
            #[inline(always)]
            pub fn pixel_valve_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::PIXEL_VALVE_0)
            }
            #[doc = "OR of Pixel Valve 1 and 2"]
            #[inline(always)]
            pub fn pixel_valve_1_2(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::PIXEL_VALVE_1_2)
            }
            #[doc = "CPR"]
            #[inline(always)]
            pub fn cpr(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::CPR)
            }
            #[doc = "SMI"]
            #[inline(always)]
            pub fn smi(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::SMI)
            }
            #[doc = "GPIO 0"]
            #[inline(always)]
            pub fn gpio_0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::GPIO_0)
            }
            #[doc = "GPIO 1"]
            #[inline(always)]
            pub fn gpio_1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::GPIO_1)
            }
            #[doc = "GPIO 2"]
            #[inline(always)]
            pub fn gpio_2(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::GPIO_2)
            }
            #[doc = "GPIO 3"]
            #[inline(always)]
            pub fn gpio_3(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::GPIO_3)
            }
            #[doc = "OR of all I2C"]
            #[inline(always)]
            pub fn i2c(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::I2C)
            }
            #[doc = "OR of all SPI"]
            #[inline(always)]
            pub fn spi(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::SPI)
            }
            #[doc = "PCM/I2S"]
            #[inline(always)]
            pub fn pcm_i2s(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::PCM_I2S)
            }
            #[doc = "SDHOST"]
            #[inline(always)]
            pub fn sdhost(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::SDHOST)
            }
            #[doc = "OR of all PL011 UARTs"]
            #[inline(always)]
            pub fn uart(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::UART)
            }
            #[doc = "OR of all ETH_PCIe L2"]
            #[inline(always)]
            pub fn eth_pcie(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::ETH_PCIE)
            }
            #[doc = "VEC"]
            #[inline(always)]
            pub fn vec(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::VEC)
            }
            #[doc = "CPG"]
            #[inline(always)]
            pub fn cpg(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::CPG)
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub fn rng(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::RNG)
            }
            #[doc = "OR of EMMC and EMMC2"]
            #[inline(always)]
            pub fn emmc(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::EMMC)
            }
            #[doc = "ETH_PCIe secure"]
            #[inline(always)]
            pub fn eth_pcie_secure(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::ETH_PCIE_SECURE)
            }
            #[doc = "ARMC Timer"]
            #[inline(always)]
            pub fn timer(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::TIMER)
            }
            #[doc = "Mailbox"]
            #[inline(always)]
            pub fn mailbox(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::MAILBOX)
            }
            #[doc = "Doorbell 0"]
            #[inline(always)]
            pub fn doorbell0(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DOORBELL0)
            }
            #[doc = "Doorbell 1"]
            #[inline(always)]
            pub fn doorbell1(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::DOORBELL1)
            }
            #[doc = "VPU0 halted"]
            #[inline(always)]
            pub fn vpu0_halted(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::VPU0_HALTED)
            }
            #[doc = "VPU1 halted"]
            #[inline(always)]
            pub fn vpu1_halted(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::VPU1_HALTED)
            }
            #[doc = "ARM address error"]
            #[inline(always)]
            pub fn arm_address_error(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::ARM_ADDRESS_ERROR)
            }
            #[doc = "ARM AXI error"]
            #[inline(always)]
            pub fn arm_axi_error(self) -> &'a mut crate::W<REG> {
                self.variant(SOURCE_A::ARM_AXI_ERROR)
            }
        }
        #[doc = "Field `ENABLE` reader - FIQ Enable"]
        pub type ENABLE_R = crate::BitReader;
        #[doc = "Field `ENABLE` writer - FIQ Enable"]
        pub type ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bits 0:6 - FIQ Source"]
            #[inline(always)]
            pub fn source(&self) -> SOURCE_R {
                SOURCE_R::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bit 7 - FIQ Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FIQ_CONTROL")
                    .field("enable", &format_args!("{}", self.enable().bit()))
                    .field("source", &format_args!("{}", self.source().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FIQ_CONTROL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - FIQ Source"]
            #[inline(always)]
            #[must_use]
            pub fn source(&mut self) -> SOURCE_W<FIQ_CONTROL_SPEC, 0> {
                SOURCE_W::new(self)
            }
            #[doc = "Bit 7 - FIQ Enable"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<FIQ_CONTROL_SPEC, 7> {
                ENABLE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "FIQ control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fiq_control::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiq_control::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FIQ_CONTROL_SPEC;
        impl crate::RegisterSpec for FIQ_CONTROL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fiq_control::R`](R) reader structure"]
        impl crate::Readable for FIQ_CONTROL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`fiq_control::W`](W) writer structure"]
        impl crate::Writable for FIQ_CONTROL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets FIQ_CONTROL to value 0"]
        impl crate::Resettable for FIQ_CONTROL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ENABLE_1 (rw) register accessor: Enable interrupts 1 - 31\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable_1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable_1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable_1`]
module"]
    pub type ENABLE_1 = crate::Reg<enable_1::ENABLE_1_SPEC>;
    #[doc = "Enable interrupts 1 - 31"]
    pub mod enable_1 {
        #[doc = "Register `ENABLE_1` reader"]
        pub type R = crate::R<ENABLE_1_SPEC>;
        #[doc = "Register `ENABLE_1` writer"]
        pub type W = crate::W<ENABLE_1_SPEC>;
        #[doc = "Field `TIMER_0` reader - Timer 0"]
        pub type TIMER_0_R = crate::BitReader;
        #[doc = "Field `TIMER_0` writer - Timer 0"]
        pub type TIMER_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `TIMER_1` reader - Timer 1"]
        pub type TIMER_1_R = crate::BitReader;
        #[doc = "Field `TIMER_1` writer - Timer 1"]
        pub type TIMER_1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `TIMER_2` reader - Timer 2"]
        pub type TIMER_2_R = crate::BitReader;
        #[doc = "Field `TIMER_2` writer - Timer 2"]
        pub type TIMER_2_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `TIMER_3` reader - Timer 3"]
        pub type TIMER_3_R = crate::BitReader;
        #[doc = "Field `TIMER_3` writer - Timer 3"]
        pub type TIMER_3_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `H264_0` reader - H264 0"]
        pub type H264_0_R = crate::BitReader;
        #[doc = "Field `H264_0` writer - H264 0"]
        pub type H264_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `H264_1` reader - H264 1"]
        pub type H264_1_R = crate::BitReader;
        #[doc = "Field `H264_1` writer - H264 1"]
        pub type H264_1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `H264_2` reader - H264 2"]
        pub type H264_2_R = crate::BitReader;
        #[doc = "Field `H264_2` writer - H264 2"]
        pub type H264_2_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `JPEG` reader - JPEG"]
        pub type JPEG_R = crate::BitReader;
        #[doc = "Field `JPEG` writer - JPEG"]
        pub type JPEG_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `ISP` reader - ISP"]
        pub type ISP_R = crate::BitReader;
        #[doc = "Field `ISP` writer - ISP"]
        pub type ISP_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `USB` reader - USB"]
        pub type USB_R = crate::BitReader;
        #[doc = "Field `USB` writer - USB"]
        pub type USB_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `V3D` reader - V3D"]
        pub type V3D_R = crate::BitReader;
        #[doc = "Field `V3D` writer - V3D"]
        pub type V3D_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `TRANSPOSER` reader - Transposer"]
        pub type TRANSPOSER_R = crate::BitReader;
        #[doc = "Field `TRANSPOSER` writer - Transposer"]
        pub type TRANSPOSER_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `MULTICORE_SYNC_0` reader - Multicore Sync 0"]
        pub type MULTICORE_SYNC_0_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_0` writer - Multicore Sync 0"]
        pub type MULTICORE_SYNC_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `MULTICORE_SYNC_1` reader - Multicore Sync 1"]
        pub type MULTICORE_SYNC_1_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_1` writer - Multicore Sync 1"]
        pub type MULTICORE_SYNC_1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `MULTICORE_SYNC_2` reader - Multicore Sync 2"]
        pub type MULTICORE_SYNC_2_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_2` writer - Multicore Sync 2"]
        pub type MULTICORE_SYNC_2_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `MULTICORE_SYNC_3` reader - Multicore Sync 3"]
        pub type MULTICORE_SYNC_3_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_3` writer - Multicore Sync 3"]
        pub type MULTICORE_SYNC_3_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_0` reader - DMA 0"]
        pub type DMA_0_R = crate::BitReader;
        #[doc = "Field `DMA_0` writer - DMA 0"]
        pub type DMA_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_1` reader - DMA 1"]
        pub type DMA_1_R = crate::BitReader;
        #[doc = "Field `DMA_1` writer - DMA 1"]
        pub type DMA_1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_2` reader - DMA 2"]
        pub type DMA_2_R = crate::BitReader;
        #[doc = "Field `DMA_2` writer - DMA 2"]
        pub type DMA_2_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_3` reader - DMA 3"]
        pub type DMA_3_R = crate::BitReader;
        #[doc = "Field `DMA_3` writer - DMA 3"]
        pub type DMA_3_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_4` reader - DMA 4"]
        pub type DMA_4_R = crate::BitReader;
        #[doc = "Field `DMA_4` writer - DMA 4"]
        pub type DMA_4_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_5` reader - DMA 5"]
        pub type DMA_5_R = crate::BitReader;
        #[doc = "Field `DMA_5` writer - DMA 5"]
        pub type DMA_5_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_6` reader - DMA 6"]
        pub type DMA_6_R = crate::BitReader;
        #[doc = "Field `DMA_6` writer - DMA 6"]
        pub type DMA_6_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_7_8` reader - OR of DMA 7 and 8"]
        pub type DMA_7_8_R = crate::BitReader;
        #[doc = "Field `DMA_7_8` writer - OR of DMA 7 and 8"]
        pub type DMA_7_8_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_9_10` reader - OR of DMA 9 and 10"]
        pub type DMA_9_10_R = crate::BitReader;
        #[doc = "Field `DMA_9_10` writer - OR of DMA 9 and 10"]
        pub type DMA_9_10_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_11` reader - DMA 11"]
        pub type DMA_11_R = crate::BitReader;
        #[doc = "Field `DMA_11` writer - DMA 11"]
        pub type DMA_11_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_12` reader - DMA 12"]
        pub type DMA_12_R = crate::BitReader;
        #[doc = "Field `DMA_12` writer - DMA 12"]
        pub type DMA_12_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_13` reader - DMA 13"]
        pub type DMA_13_R = crate::BitReader;
        #[doc = "Field `DMA_13` writer - DMA 13"]
        pub type DMA_13_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_14` reader - DMA 14"]
        pub type DMA_14_R = crate::BitReader;
        #[doc = "Field `DMA_14` writer - DMA 14"]
        pub type DMA_14_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `AUX` reader - OR of UART1, SPI1 and SPI2"]
        pub type AUX_R = crate::BitReader;
        #[doc = "Field `AUX` writer - OR of UART1, SPI1 and SPI2"]
        pub type AUX_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `ARM` reader - ARM"]
        pub type ARM_R = crate::BitReader;
        #[doc = "Field `ARM` writer - ARM"]
        pub type ARM_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DMA_15` reader - DMA 15"]
        pub type DMA_15_R = crate::BitReader;
        #[doc = "Field `DMA_15` writer - DMA 15"]
        pub type DMA_15_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Timer 0"]
            #[inline(always)]
            pub fn timer_0(&self) -> TIMER_0_R {
                TIMER_0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Timer 1"]
            #[inline(always)]
            pub fn timer_1(&self) -> TIMER_1_R {
                TIMER_1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Timer 2"]
            #[inline(always)]
            pub fn timer_2(&self) -> TIMER_2_R {
                TIMER_2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Timer 3"]
            #[inline(always)]
            pub fn timer_3(&self) -> TIMER_3_R {
                TIMER_3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - H264 0"]
            #[inline(always)]
            pub fn h264_0(&self) -> H264_0_R {
                H264_0_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - H264 1"]
            #[inline(always)]
            pub fn h264_1(&self) -> H264_1_R {
                H264_1_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - H264 2"]
            #[inline(always)]
            pub fn h264_2(&self) -> H264_2_R {
                H264_2_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - JPEG"]
            #[inline(always)]
            pub fn jpeg(&self) -> JPEG_R {
                JPEG_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - ISP"]
            #[inline(always)]
            pub fn isp(&self) -> ISP_R {
                ISP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - USB"]
            #[inline(always)]
            pub fn usb(&self) -> USB_R {
                USB_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - V3D"]
            #[inline(always)]
            pub fn v3d(&self) -> V3D_R {
                V3D_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Transposer"]
            #[inline(always)]
            pub fn transposer(&self) -> TRANSPOSER_R {
                TRANSPOSER_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Multicore Sync 0"]
            #[inline(always)]
            pub fn multicore_sync_0(&self) -> MULTICORE_SYNC_0_R {
                MULTICORE_SYNC_0_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Multicore Sync 1"]
            #[inline(always)]
            pub fn multicore_sync_1(&self) -> MULTICORE_SYNC_1_R {
                MULTICORE_SYNC_1_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Multicore Sync 2"]
            #[inline(always)]
            pub fn multicore_sync_2(&self) -> MULTICORE_SYNC_2_R {
                MULTICORE_SYNC_2_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Multicore Sync 3"]
            #[inline(always)]
            pub fn multicore_sync_3(&self) -> MULTICORE_SYNC_3_R {
                MULTICORE_SYNC_3_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - DMA 0"]
            #[inline(always)]
            pub fn dma_0(&self) -> DMA_0_R {
                DMA_0_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - DMA 1"]
            #[inline(always)]
            pub fn dma_1(&self) -> DMA_1_R {
                DMA_1_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - DMA 2"]
            #[inline(always)]
            pub fn dma_2(&self) -> DMA_2_R {
                DMA_2_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - DMA 3"]
            #[inline(always)]
            pub fn dma_3(&self) -> DMA_3_R {
                DMA_3_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - DMA 4"]
            #[inline(always)]
            pub fn dma_4(&self) -> DMA_4_R {
                DMA_4_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - DMA 5"]
            #[inline(always)]
            pub fn dma_5(&self) -> DMA_5_R {
                DMA_5_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - DMA 6"]
            #[inline(always)]
            pub fn dma_6(&self) -> DMA_6_R {
                DMA_6_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - OR of DMA 7 and 8"]
            #[inline(always)]
            pub fn dma_7_8(&self) -> DMA_7_8_R {
                DMA_7_8_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - OR of DMA 9 and 10"]
            #[inline(always)]
            pub fn dma_9_10(&self) -> DMA_9_10_R {
                DMA_9_10_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - DMA 11"]
            #[inline(always)]
            pub fn dma_11(&self) -> DMA_11_R {
                DMA_11_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - DMA 12"]
            #[inline(always)]
            pub fn dma_12(&self) -> DMA_12_R {
                DMA_12_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - DMA 13"]
            #[inline(always)]
            pub fn dma_13(&self) -> DMA_13_R {
                DMA_13_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - DMA 14"]
            #[inline(always)]
            pub fn dma_14(&self) -> DMA_14_R {
                DMA_14_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - OR of UART1, SPI1 and SPI2"]
            #[inline(always)]
            pub fn aux(&self) -> AUX_R {
                AUX_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - ARM"]
            #[inline(always)]
            pub fn arm(&self) -> ARM_R {
                ARM_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - DMA 15"]
            #[inline(always)]
            pub fn dma_15(&self) -> DMA_15_R {
                DMA_15_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ENABLE_1")
                    .field("timer_0", &format_args!("{}", self.timer_0().bit()))
                    .field("timer_1", &format_args!("{}", self.timer_1().bit()))
                    .field("timer_2", &format_args!("{}", self.timer_2().bit()))
                    .field("timer_3", &format_args!("{}", self.timer_3().bit()))
                    .field("h264_0", &format_args!("{}", self.h264_0().bit()))
                    .field("h264_1", &format_args!("{}", self.h264_1().bit()))
                    .field("h264_2", &format_args!("{}", self.h264_2().bit()))
                    .field("jpeg", &format_args!("{}", self.jpeg().bit()))
                    .field("isp", &format_args!("{}", self.isp().bit()))
                    .field("usb", &format_args!("{}", self.usb().bit()))
                    .field("v3d", &format_args!("{}", self.v3d().bit()))
                    .field("transposer", &format_args!("{}", self.transposer().bit()))
                    .field(
                        "multicore_sync_0",
                        &format_args!("{}", self.multicore_sync_0().bit()),
                    )
                    .field(
                        "multicore_sync_1",
                        &format_args!("{}", self.multicore_sync_1().bit()),
                    )
                    .field(
                        "multicore_sync_2",
                        &format_args!("{}", self.multicore_sync_2().bit()),
                    )
                    .field(
                        "multicore_sync_3",
                        &format_args!("{}", self.multicore_sync_3().bit()),
                    )
                    .field("dma_0", &format_args!("{}", self.dma_0().bit()))
                    .field("dma_1", &format_args!("{}", self.dma_1().bit()))
                    .field("dma_2", &format_args!("{}", self.dma_2().bit()))
                    .field("dma_3", &format_args!("{}", self.dma_3().bit()))
                    .field("dma_4", &format_args!("{}", self.dma_4().bit()))
                    .field("dma_5", &format_args!("{}", self.dma_5().bit()))
                    .field("dma_6", &format_args!("{}", self.dma_6().bit()))
                    .field("dma_7_8", &format_args!("{}", self.dma_7_8().bit()))
                    .field("dma_9_10", &format_args!("{}", self.dma_9_10().bit()))
                    .field("dma_11", &format_args!("{}", self.dma_11().bit()))
                    .field("dma_12", &format_args!("{}", self.dma_12().bit()))
                    .field("dma_13", &format_args!("{}", self.dma_13().bit()))
                    .field("dma_14", &format_args!("{}", self.dma_14().bit()))
                    .field("aux", &format_args!("{}", self.aux().bit()))
                    .field("arm", &format_args!("{}", self.arm().bit()))
                    .field("dma_15", &format_args!("{}", self.dma_15().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<ENABLE_1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Timer 0"]
            #[inline(always)]
            #[must_use]
            pub fn timer_0(&mut self) -> TIMER_0_W<ENABLE_1_SPEC, 0> {
                TIMER_0_W::new(self)
            }
            #[doc = "Bit 1 - Timer 1"]
            #[inline(always)]
            #[must_use]
            pub fn timer_1(&mut self) -> TIMER_1_W<ENABLE_1_SPEC, 1> {
                TIMER_1_W::new(self)
            }
            #[doc = "Bit 2 - Timer 2"]
            #[inline(always)]
            #[must_use]
            pub fn timer_2(&mut self) -> TIMER_2_W<ENABLE_1_SPEC, 2> {
                TIMER_2_W::new(self)
            }
            #[doc = "Bit 3 - Timer 3"]
            #[inline(always)]
            #[must_use]
            pub fn timer_3(&mut self) -> TIMER_3_W<ENABLE_1_SPEC, 3> {
                TIMER_3_W::new(self)
            }
            #[doc = "Bit 4 - H264 0"]
            #[inline(always)]
            #[must_use]
            pub fn h264_0(&mut self) -> H264_0_W<ENABLE_1_SPEC, 4> {
                H264_0_W::new(self)
            }
            #[doc = "Bit 5 - H264 1"]
            #[inline(always)]
            #[must_use]
            pub fn h264_1(&mut self) -> H264_1_W<ENABLE_1_SPEC, 5> {
                H264_1_W::new(self)
            }
            #[doc = "Bit 6 - H264 2"]
            #[inline(always)]
            #[must_use]
            pub fn h264_2(&mut self) -> H264_2_W<ENABLE_1_SPEC, 6> {
                H264_2_W::new(self)
            }
            #[doc = "Bit 7 - JPEG"]
            #[inline(always)]
            #[must_use]
            pub fn jpeg(&mut self) -> JPEG_W<ENABLE_1_SPEC, 7> {
                JPEG_W::new(self)
            }
            #[doc = "Bit 8 - ISP"]
            #[inline(always)]
            #[must_use]
            pub fn isp(&mut self) -> ISP_W<ENABLE_1_SPEC, 8> {
                ISP_W::new(self)
            }
            #[doc = "Bit 9 - USB"]
            #[inline(always)]
            #[must_use]
            pub fn usb(&mut self) -> USB_W<ENABLE_1_SPEC, 9> {
                USB_W::new(self)
            }
            #[doc = "Bit 10 - V3D"]
            #[inline(always)]
            #[must_use]
            pub fn v3d(&mut self) -> V3D_W<ENABLE_1_SPEC, 10> {
                V3D_W::new(self)
            }
            #[doc = "Bit 11 - Transposer"]
            #[inline(always)]
            #[must_use]
            pub fn transposer(&mut self) -> TRANSPOSER_W<ENABLE_1_SPEC, 11> {
                TRANSPOSER_W::new(self)
            }
            #[doc = "Bit 12 - Multicore Sync 0"]
            #[inline(always)]
            #[must_use]
            pub fn multicore_sync_0(&mut self) -> MULTICORE_SYNC_0_W<ENABLE_1_SPEC, 12> {
                MULTICORE_SYNC_0_W::new(self)
            }
            #[doc = "Bit 13 - Multicore Sync 1"]
            #[inline(always)]
            #[must_use]
            pub fn multicore_sync_1(&mut self) -> MULTICORE_SYNC_1_W<ENABLE_1_SPEC, 13> {
                MULTICORE_SYNC_1_W::new(self)
            }
            #[doc = "Bit 14 - Multicore Sync 2"]
            #[inline(always)]
            #[must_use]
            pub fn multicore_sync_2(&mut self) -> MULTICORE_SYNC_2_W<ENABLE_1_SPEC, 14> {
                MULTICORE_SYNC_2_W::new(self)
            }
            #[doc = "Bit 15 - Multicore Sync 3"]
            #[inline(always)]
            #[must_use]
            pub fn multicore_sync_3(&mut self) -> MULTICORE_SYNC_3_W<ENABLE_1_SPEC, 15> {
                MULTICORE_SYNC_3_W::new(self)
            }
            #[doc = "Bit 16 - DMA 0"]
            #[inline(always)]
            #[must_use]
            pub fn dma_0(&mut self) -> DMA_0_W<ENABLE_1_SPEC, 16> {
                DMA_0_W::new(self)
            }
            #[doc = "Bit 17 - DMA 1"]
            #[inline(always)]
            #[must_use]
            pub fn dma_1(&mut self) -> DMA_1_W<ENABLE_1_SPEC, 17> {
                DMA_1_W::new(self)
            }
            #[doc = "Bit 18 - DMA 2"]
            #[inline(always)]
            #[must_use]
            pub fn dma_2(&mut self) -> DMA_2_W<ENABLE_1_SPEC, 18> {
                DMA_2_W::new(self)
            }
            #[doc = "Bit 19 - DMA 3"]
            #[inline(always)]
            #[must_use]
            pub fn dma_3(&mut self) -> DMA_3_W<ENABLE_1_SPEC, 19> {
                DMA_3_W::new(self)
            }
            #[doc = "Bit 20 - DMA 4"]
            #[inline(always)]
            #[must_use]
            pub fn dma_4(&mut self) -> DMA_4_W<ENABLE_1_SPEC, 20> {
                DMA_4_W::new(self)
            }
            #[doc = "Bit 21 - DMA 5"]
            #[inline(always)]
            #[must_use]
            pub fn dma_5(&mut self) -> DMA_5_W<ENABLE_1_SPEC, 21> {
                DMA_5_W::new(self)
            }
            #[doc = "Bit 22 - DMA 6"]
            #[inline(always)]
            #[must_use]
            pub fn dma_6(&mut self) -> DMA_6_W<ENABLE_1_SPEC, 22> {
                DMA_6_W::new(self)
            }
            #[doc = "Bit 23 - OR of DMA 7 and 8"]
            #[inline(always)]
            #[must_use]
            pub fn dma_7_8(&mut self) -> DMA_7_8_W<ENABLE_1_SPEC, 23> {
                DMA_7_8_W::new(self)
            }
            #[doc = "Bit 24 - OR of DMA 9 and 10"]
            #[inline(always)]
            #[must_use]
            pub fn dma_9_10(&mut self) -> DMA_9_10_W<ENABLE_1_SPEC, 24> {
                DMA_9_10_W::new(self)
            }
            #[doc = "Bit 25 - DMA 11"]
            #[inline(always)]
            #[must_use]
            pub fn dma_11(&mut self) -> DMA_11_W<ENABLE_1_SPEC, 25> {
                DMA_11_W::new(self)
            }
            #[doc = "Bit 26 - DMA 12"]
            #[inline(always)]
            #[must_use]
            pub fn dma_12(&mut self) -> DMA_12_W<ENABLE_1_SPEC, 26> {
                DMA_12_W::new(self)
            }
            #[doc = "Bit 27 - DMA 13"]
            #[inline(always)]
            #[must_use]
            pub fn dma_13(&mut self) -> DMA_13_W<ENABLE_1_SPEC, 27> {
                DMA_13_W::new(self)
            }
            #[doc = "Bit 28 - DMA 14"]
            #[inline(always)]
            #[must_use]
            pub fn dma_14(&mut self) -> DMA_14_W<ENABLE_1_SPEC, 28> {
                DMA_14_W::new(self)
            }
            #[doc = "Bit 29 - OR of UART1, SPI1 and SPI2"]
            #[inline(always)]
            #[must_use]
            pub fn aux(&mut self) -> AUX_W<ENABLE_1_SPEC, 29> {
                AUX_W::new(self)
            }
            #[doc = "Bit 30 - ARM"]
            #[inline(always)]
            #[must_use]
            pub fn arm(&mut self) -> ARM_W<ENABLE_1_SPEC, 30> {
                ARM_W::new(self)
            }
            #[doc = "Bit 31 - DMA 15"]
            #[inline(always)]
            #[must_use]
            pub fn dma_15(&mut self) -> DMA_15_W<ENABLE_1_SPEC, 31> {
                DMA_15_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Enable interrupts 1 - 31\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable_1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable_1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ENABLE_1_SPEC;
        impl crate::RegisterSpec for ENABLE_1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`enable_1::R`](R) reader structure"]
        impl crate::Readable for ENABLE_1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`enable_1::W`](W) writer structure"]
        impl crate::Writable for ENABLE_1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xffff_ffff;
        }
        #[doc = "`reset()` method sets ENABLE_1 to value 0"]
        impl crate::Resettable for ENABLE_1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ENABLE_2 (rw) register accessor: Enable interrupts 32 - 63\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable_2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable_2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable_2`]
module"]
    pub type ENABLE_2 = crate::Reg<enable_2::ENABLE_2_SPEC>;
    #[doc = "Enable interrupts 32 - 63"]
    pub mod enable_2 {
        #[doc = "Register `ENABLE_2` reader"]
        pub type R = crate::R<ENABLE_2_SPEC>;
        #[doc = "Register `ENABLE_2` writer"]
        pub type W = crate::W<ENABLE_2_SPEC>;
        #[doc = "Field `HDMI_CEC` reader - HDMI CEC"]
        pub type HDMI_CEC_R = crate::BitReader;
        #[doc = "Field `HDMI_CEC` writer - HDMI CEC"]
        pub type HDMI_CEC_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `HVS` reader - HVS"]
        pub type HVS_R = crate::BitReader;
        #[doc = "Field `HVS` writer - HVS"]
        pub type HVS_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `RPIVID` reader - RPIVID"]
        pub type RPIVID_R = crate::BitReader;
        #[doc = "Field `RPIVID` writer - RPIVID"]
        pub type RPIVID_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SDC` reader - SDC"]
        pub type SDC_R = crate::BitReader;
        #[doc = "Field `SDC` writer - SDC"]
        pub type SDC_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DSI_0` reader - DSI 0"]
        pub type DSI_0_R = crate::BitReader;
        #[doc = "Field `DSI_0` writer - DSI 0"]
        pub type DSI_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `PIXEL_VALVE_2` reader - Pixel Valve 2"]
        pub type PIXEL_VALVE_2_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_2` writer - Pixel Valve 2"]
        pub type PIXEL_VALVE_2_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `CAMERA_0` reader - Camera 0"]
        pub type CAMERA_0_R = crate::BitReader;
        #[doc = "Field `CAMERA_0` writer - Camera 0"]
        pub type CAMERA_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `CAMERA_1` reader - Camera 1"]
        pub type CAMERA_1_R = crate::BitReader;
        #[doc = "Field `CAMERA_1` writer - Camera 1"]
        pub type CAMERA_1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `HDMI_0` reader - HDMI 0"]
        pub type HDMI_0_R = crate::BitReader;
        #[doc = "Field `HDMI_0` writer - HDMI 0"]
        pub type HDMI_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `HDMI_1` reader - HDMI 1"]
        pub type HDMI_1_R = crate::BitReader;
        #[doc = "Field `HDMI_1` writer - HDMI 1"]
        pub type HDMI_1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `PIXEL_VALVE_3` reader - Pixel Valve 3"]
        pub type PIXEL_VALVE_3_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_3` writer - Pixel Valve 3"]
        pub type PIXEL_VALVE_3_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SPI_BSC_SLAVE` reader - SPI/BSC Slave"]
        pub type SPI_BSC_SLAVE_R = crate::BitReader;
        #[doc = "Field `SPI_BSC_SLAVE` writer - SPI/BSC Slave"]
        pub type SPI_BSC_SLAVE_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DSI_1` reader - DSI 1"]
        pub type DSI_1_R = crate::BitReader;
        #[doc = "Field `DSI_1` writer - DSI 1"]
        pub type DSI_1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `PIXEL_VALVE_0` reader - Pixel Valve 0"]
        pub type PIXEL_VALVE_0_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_0` writer - Pixel Valve 0"]
        pub type PIXEL_VALVE_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `PIXEL_VALVE_1_2` reader - OR of Pixel Valve 1 and 2"]
        pub type PIXEL_VALVE_1_2_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_1_2` writer - OR of Pixel Valve 1 and 2"]
        pub type PIXEL_VALVE_1_2_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `CPR` reader - CPR"]
        pub type CPR_R = crate::BitReader;
        #[doc = "Field `CPR` writer - CPR"]
        pub type CPR_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SMI` reader - SMI"]
        pub type SMI_R = crate::BitReader;
        #[doc = "Field `SMI` writer - SMI"]
        pub type SMI_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `GPIO_0` reader - GPIO 0"]
        pub type GPIO_0_R = crate::BitReader;
        #[doc = "Field `GPIO_0` writer - GPIO 0"]
        pub type GPIO_0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `GPIO_1` reader - GPIO 1"]
        pub type GPIO_1_R = crate::BitReader;
        #[doc = "Field `GPIO_1` writer - GPIO 1"]
        pub type GPIO_1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `GPIO_2` reader - GPIO 2"]
        pub type GPIO_2_R = crate::BitReader;
        #[doc = "Field `GPIO_2` writer - GPIO 2"]
        pub type GPIO_2_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `GPIO_3` reader - GPIO 3"]
        pub type GPIO_3_R = crate::BitReader;
        #[doc = "Field `GPIO_3` writer - GPIO 3"]
        pub type GPIO_3_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `I2C` reader - OR of all I2C"]
        pub type I2C_R = crate::BitReader;
        #[doc = "Field `I2C` writer - OR of all I2C"]
        pub type I2C_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SPI` reader - OR of all SPI"]
        pub type SPI_R = crate::BitReader;
        #[doc = "Field `SPI` writer - OR of all SPI"]
        pub type SPI_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `PCM_I2S` reader - PCM/I2S"]
        pub type PCM_I2S_R = crate::BitReader;
        #[doc = "Field `PCM_I2S` writer - PCM/I2S"]
        pub type PCM_I2S_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `SDHOST` reader - SDHOST"]
        pub type SDHOST_R = crate::BitReader;
        #[doc = "Field `SDHOST` writer - SDHOST"]
        pub type SDHOST_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `UART` reader - OR of all PL011 UARTs"]
        pub type UART_R = crate::BitReader;
        #[doc = "Field `UART` writer - OR of all PL011 UARTs"]
        pub type UART_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `ETH_PCIE` reader - OR of all ETH_PCIe L2"]
        pub type ETH_PCIE_R = crate::BitReader;
        #[doc = "Field `ETH_PCIE` writer - OR of all ETH_PCIe L2"]
        pub type ETH_PCIE_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `VEC` reader - VEC"]
        pub type VEC_R = crate::BitReader;
        #[doc = "Field `VEC` writer - VEC"]
        pub type VEC_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `CPG` reader - CPG"]
        pub type CPG_R = crate::BitReader;
        #[doc = "Field `CPG` writer - CPG"]
        pub type CPG_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `RNG` reader - RNG"]
        pub type RNG_R = crate::BitReader;
        #[doc = "Field `RNG` writer - RNG"]
        pub type RNG_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `EMMC` reader - OR of EMMC and EMMC2"]
        pub type EMMC_R = crate::BitReader;
        #[doc = "Field `EMMC` writer - OR of EMMC and EMMC2"]
        pub type EMMC_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `ETH_PCIE_SECURE` reader - ETH_PCIe secure"]
        pub type ETH_PCIE_SECURE_R = crate::BitReader;
        #[doc = "Field `ETH_PCIE_SECURE` writer - ETH_PCIe secure"]
        pub type ETH_PCIE_SECURE_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - HDMI CEC"]
            #[inline(always)]
            pub fn hdmi_cec(&self) -> HDMI_CEC_R {
                HDMI_CEC_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - HVS"]
            #[inline(always)]
            pub fn hvs(&self) -> HVS_R {
                HVS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RPIVID"]
            #[inline(always)]
            pub fn rpivid(&self) -> RPIVID_R {
                RPIVID_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - SDC"]
            #[inline(always)]
            pub fn sdc(&self) -> SDC_R {
                SDC_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - DSI 0"]
            #[inline(always)]
            pub fn dsi_0(&self) -> DSI_0_R {
                DSI_0_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Pixel Valve 2"]
            #[inline(always)]
            pub fn pixel_valve_2(&self) -> PIXEL_VALVE_2_R {
                PIXEL_VALVE_2_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Camera 0"]
            #[inline(always)]
            pub fn camera_0(&self) -> CAMERA_0_R {
                CAMERA_0_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Camera 1"]
            #[inline(always)]
            pub fn camera_1(&self) -> CAMERA_1_R {
                CAMERA_1_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - HDMI 0"]
            #[inline(always)]
            pub fn hdmi_0(&self) -> HDMI_0_R {
                HDMI_0_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - HDMI 1"]
            #[inline(always)]
            pub fn hdmi_1(&self) -> HDMI_1_R {
                HDMI_1_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Pixel Valve 3"]
            #[inline(always)]
            pub fn pixel_valve_3(&self) -> PIXEL_VALVE_3_R {
                PIXEL_VALVE_3_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - SPI/BSC Slave"]
            #[inline(always)]
            pub fn spi_bsc_slave(&self) -> SPI_BSC_SLAVE_R {
                SPI_BSC_SLAVE_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - DSI 1"]
            #[inline(always)]
            pub fn dsi_1(&self) -> DSI_1_R {
                DSI_1_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Pixel Valve 0"]
            #[inline(always)]
            pub fn pixel_valve_0(&self) -> PIXEL_VALVE_0_R {
                PIXEL_VALVE_0_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - OR of Pixel Valve 1 and 2"]
            #[inline(always)]
            pub fn pixel_valve_1_2(&self) -> PIXEL_VALVE_1_2_R {
                PIXEL_VALVE_1_2_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - CPR"]
            #[inline(always)]
            pub fn cpr(&self) -> CPR_R {
                CPR_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - SMI"]
            #[inline(always)]
            pub fn smi(&self) -> SMI_R {
                SMI_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - GPIO 0"]
            #[inline(always)]
            pub fn gpio_0(&self) -> GPIO_0_R {
                GPIO_0_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - GPIO 1"]
            #[inline(always)]
            pub fn gpio_1(&self) -> GPIO_1_R {
                GPIO_1_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - GPIO 2"]
            #[inline(always)]
            pub fn gpio_2(&self) -> GPIO_2_R {
                GPIO_2_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - GPIO 3"]
            #[inline(always)]
            pub fn gpio_3(&self) -> GPIO_3_R {
                GPIO_3_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - OR of all I2C"]
            #[inline(always)]
            pub fn i2c(&self) -> I2C_R {
                I2C_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - OR of all SPI"]
            #[inline(always)]
            pub fn spi(&self) -> SPI_R {
                SPI_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - PCM/I2S"]
            #[inline(always)]
            pub fn pcm_i2s(&self) -> PCM_I2S_R {
                PCM_I2S_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - SDHOST"]
            #[inline(always)]
            pub fn sdhost(&self) -> SDHOST_R {
                SDHOST_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - OR of all PL011 UARTs"]
            #[inline(always)]
            pub fn uart(&self) -> UART_R {
                UART_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - OR of all ETH_PCIe L2"]
            #[inline(always)]
            pub fn eth_pcie(&self) -> ETH_PCIE_R {
                ETH_PCIE_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - VEC"]
            #[inline(always)]
            pub fn vec(&self) -> VEC_R {
                VEC_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - CPG"]
            #[inline(always)]
            pub fn cpg(&self) -> CPG_R {
                CPG_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - RNG"]
            #[inline(always)]
            pub fn rng(&self) -> RNG_R {
                RNG_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - OR of EMMC and EMMC2"]
            #[inline(always)]
            pub fn emmc(&self) -> EMMC_R {
                EMMC_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - ETH_PCIe secure"]
            #[inline(always)]
            pub fn eth_pcie_secure(&self) -> ETH_PCIE_SECURE_R {
                ETH_PCIE_SECURE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ENABLE_2")
                    .field("hdmi_cec", &format_args!("{}", self.hdmi_cec().bit()))
                    .field("hvs", &format_args!("{}", self.hvs().bit()))
                    .field("rpivid", &format_args!("{}", self.rpivid().bit()))
                    .field("sdc", &format_args!("{}", self.sdc().bit()))
                    .field("dsi_0", &format_args!("{}", self.dsi_0().bit()))
                    .field(
                        "pixel_valve_2",
                        &format_args!("{}", self.pixel_valve_2().bit()),
                    )
                    .field("camera_0", &format_args!("{}", self.camera_0().bit()))
                    .field("camera_1", &format_args!("{}", self.camera_1().bit()))
                    .field("hdmi_0", &format_args!("{}", self.hdmi_0().bit()))
                    .field("hdmi_1", &format_args!("{}", self.hdmi_1().bit()))
                    .field(
                        "pixel_valve_3",
                        &format_args!("{}", self.pixel_valve_3().bit()),
                    )
                    .field(
                        "spi_bsc_slave",
                        &format_args!("{}", self.spi_bsc_slave().bit()),
                    )
                    .field("dsi_1", &format_args!("{}", self.dsi_1().bit()))
                    .field(
                        "pixel_valve_0",
                        &format_args!("{}", self.pixel_valve_0().bit()),
                    )
                    .field(
                        "pixel_valve_1_2",
                        &format_args!("{}", self.pixel_valve_1_2().bit()),
                    )
                    .field("cpr", &format_args!("{}", self.cpr().bit()))
                    .field("smi", &format_args!("{}", self.smi().bit()))
                    .field("gpio_0", &format_args!("{}", self.gpio_0().bit()))
                    .field("gpio_1", &format_args!("{}", self.gpio_1().bit()))
                    .field("gpio_2", &format_args!("{}", self.gpio_2().bit()))
                    .field("gpio_3", &format_args!("{}", self.gpio_3().bit()))
                    .field("i2c", &format_args!("{}", self.i2c().bit()))
                    .field("spi", &format_args!("{}", self.spi().bit()))
                    .field("pcm_i2s", &format_args!("{}", self.pcm_i2s().bit()))
                    .field("sdhost", &format_args!("{}", self.sdhost().bit()))
                    .field("uart", &format_args!("{}", self.uart().bit()))
                    .field("eth_pcie", &format_args!("{}", self.eth_pcie().bit()))
                    .field("vec", &format_args!("{}", self.vec().bit()))
                    .field("cpg", &format_args!("{}", self.cpg().bit()))
                    .field("rng", &format_args!("{}", self.rng().bit()))
                    .field("emmc", &format_args!("{}", self.emmc().bit()))
                    .field(
                        "eth_pcie_secure",
                        &format_args!("{}", self.eth_pcie_secure().bit()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<ENABLE_2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - HDMI CEC"]
            #[inline(always)]
            #[must_use]
            pub fn hdmi_cec(&mut self) -> HDMI_CEC_W<ENABLE_2_SPEC, 0> {
                HDMI_CEC_W::new(self)
            }
            #[doc = "Bit 1 - HVS"]
            #[inline(always)]
            #[must_use]
            pub fn hvs(&mut self) -> HVS_W<ENABLE_2_SPEC, 1> {
                HVS_W::new(self)
            }
            #[doc = "Bit 2 - RPIVID"]
            #[inline(always)]
            #[must_use]
            pub fn rpivid(&mut self) -> RPIVID_W<ENABLE_2_SPEC, 2> {
                RPIVID_W::new(self)
            }
            #[doc = "Bit 3 - SDC"]
            #[inline(always)]
            #[must_use]
            pub fn sdc(&mut self) -> SDC_W<ENABLE_2_SPEC, 3> {
                SDC_W::new(self)
            }
            #[doc = "Bit 4 - DSI 0"]
            #[inline(always)]
            #[must_use]
            pub fn dsi_0(&mut self) -> DSI_0_W<ENABLE_2_SPEC, 4> {
                DSI_0_W::new(self)
            }
            #[doc = "Bit 5 - Pixel Valve 2"]
            #[inline(always)]
            #[must_use]
            pub fn pixel_valve_2(&mut self) -> PIXEL_VALVE_2_W<ENABLE_2_SPEC, 5> {
                PIXEL_VALVE_2_W::new(self)
            }
            #[doc = "Bit 6 - Camera 0"]
            #[inline(always)]
            #[must_use]
            pub fn camera_0(&mut self) -> CAMERA_0_W<ENABLE_2_SPEC, 6> {
                CAMERA_0_W::new(self)
            }
            #[doc = "Bit 7 - Camera 1"]
            #[inline(always)]
            #[must_use]
            pub fn camera_1(&mut self) -> CAMERA_1_W<ENABLE_2_SPEC, 7> {
                CAMERA_1_W::new(self)
            }
            #[doc = "Bit 8 - HDMI 0"]
            #[inline(always)]
            #[must_use]
            pub fn hdmi_0(&mut self) -> HDMI_0_W<ENABLE_2_SPEC, 8> {
                HDMI_0_W::new(self)
            }
            #[doc = "Bit 9 - HDMI 1"]
            #[inline(always)]
            #[must_use]
            pub fn hdmi_1(&mut self) -> HDMI_1_W<ENABLE_2_SPEC, 9> {
                HDMI_1_W::new(self)
            }
            #[doc = "Bit 10 - Pixel Valve 3"]
            #[inline(always)]
            #[must_use]
            pub fn pixel_valve_3(&mut self) -> PIXEL_VALVE_3_W<ENABLE_2_SPEC, 10> {
                PIXEL_VALVE_3_W::new(self)
            }
            #[doc = "Bit 11 - SPI/BSC Slave"]
            #[inline(always)]
            #[must_use]
            pub fn spi_bsc_slave(&mut self) -> SPI_BSC_SLAVE_W<ENABLE_2_SPEC, 11> {
                SPI_BSC_SLAVE_W::new(self)
            }
            #[doc = "Bit 12 - DSI 1"]
            #[inline(always)]
            #[must_use]
            pub fn dsi_1(&mut self) -> DSI_1_W<ENABLE_2_SPEC, 12> {
                DSI_1_W::new(self)
            }
            #[doc = "Bit 13 - Pixel Valve 0"]
            #[inline(always)]
            #[must_use]
            pub fn pixel_valve_0(&mut self) -> PIXEL_VALVE_0_W<ENABLE_2_SPEC, 13> {
                PIXEL_VALVE_0_W::new(self)
            }
            #[doc = "Bit 14 - OR of Pixel Valve 1 and 2"]
            #[inline(always)]
            #[must_use]
            pub fn pixel_valve_1_2(&mut self) -> PIXEL_VALVE_1_2_W<ENABLE_2_SPEC, 14> {
                PIXEL_VALVE_1_2_W::new(self)
            }
            #[doc = "Bit 15 - CPR"]
            #[inline(always)]
            #[must_use]
            pub fn cpr(&mut self) -> CPR_W<ENABLE_2_SPEC, 15> {
                CPR_W::new(self)
            }
            #[doc = "Bit 16 - SMI"]
            #[inline(always)]
            #[must_use]
            pub fn smi(&mut self) -> SMI_W<ENABLE_2_SPEC, 16> {
                SMI_W::new(self)
            }
            #[doc = "Bit 17 - GPIO 0"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_0(&mut self) -> GPIO_0_W<ENABLE_2_SPEC, 17> {
                GPIO_0_W::new(self)
            }
            #[doc = "Bit 18 - GPIO 1"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_1(&mut self) -> GPIO_1_W<ENABLE_2_SPEC, 18> {
                GPIO_1_W::new(self)
            }
            #[doc = "Bit 19 - GPIO 2"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_2(&mut self) -> GPIO_2_W<ENABLE_2_SPEC, 19> {
                GPIO_2_W::new(self)
            }
            #[doc = "Bit 20 - GPIO 3"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_3(&mut self) -> GPIO_3_W<ENABLE_2_SPEC, 20> {
                GPIO_3_W::new(self)
            }
            #[doc = "Bit 21 - OR of all I2C"]
            #[inline(always)]
            #[must_use]
            pub fn i2c(&mut self) -> I2C_W<ENABLE_2_SPEC, 21> {
                I2C_W::new(self)
            }
            #[doc = "Bit 22 - OR of all SPI"]
            #[inline(always)]
            #[must_use]
            pub fn spi(&mut self) -> SPI_W<ENABLE_2_SPEC, 22> {
                SPI_W::new(self)
            }
            #[doc = "Bit 23 - PCM/I2S"]
            #[inline(always)]
            #[must_use]
            pub fn pcm_i2s(&mut self) -> PCM_I2S_W<ENABLE_2_SPEC, 23> {
                PCM_I2S_W::new(self)
            }
            #[doc = "Bit 24 - SDHOST"]
            #[inline(always)]
            #[must_use]
            pub fn sdhost(&mut self) -> SDHOST_W<ENABLE_2_SPEC, 24> {
                SDHOST_W::new(self)
            }
            #[doc = "Bit 25 - OR of all PL011 UARTs"]
            #[inline(always)]
            #[must_use]
            pub fn uart(&mut self) -> UART_W<ENABLE_2_SPEC, 25> {
                UART_W::new(self)
            }
            #[doc = "Bit 26 - OR of all ETH_PCIe L2"]
            #[inline(always)]
            #[must_use]
            pub fn eth_pcie(&mut self) -> ETH_PCIE_W<ENABLE_2_SPEC, 26> {
                ETH_PCIE_W::new(self)
            }
            #[doc = "Bit 27 - VEC"]
            #[inline(always)]
            #[must_use]
            pub fn vec(&mut self) -> VEC_W<ENABLE_2_SPEC, 27> {
                VEC_W::new(self)
            }
            #[doc = "Bit 28 - CPG"]
            #[inline(always)]
            #[must_use]
            pub fn cpg(&mut self) -> CPG_W<ENABLE_2_SPEC, 28> {
                CPG_W::new(self)
            }
            #[doc = "Bit 29 - RNG"]
            #[inline(always)]
            #[must_use]
            pub fn rng(&mut self) -> RNG_W<ENABLE_2_SPEC, 29> {
                RNG_W::new(self)
            }
            #[doc = "Bit 30 - OR of EMMC and EMMC2"]
            #[inline(always)]
            #[must_use]
            pub fn emmc(&mut self) -> EMMC_W<ENABLE_2_SPEC, 30> {
                EMMC_W::new(self)
            }
            #[doc = "Bit 31 - ETH_PCIe secure"]
            #[inline(always)]
            #[must_use]
            pub fn eth_pcie_secure(&mut self) -> ETH_PCIE_SECURE_W<ENABLE_2_SPEC, 31> {
                ETH_PCIE_SECURE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Enable interrupts 32 - 63\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable_2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable_2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ENABLE_2_SPEC;
        impl crate::RegisterSpec for ENABLE_2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`enable_2::R`](R) reader structure"]
        impl crate::Readable for ENABLE_2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`enable_2::W`](W) writer structure"]
        impl crate::Writable for ENABLE_2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xffff_ffff;
        }
        #[doc = "`reset()` method sets ENABLE_2 to value 0"]
        impl crate::Resettable for ENABLE_2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ENABLE_BASIC (rw) register accessor: Enable basic interrupts\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable_basic::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable_basic::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable_basic`]
module"]
    pub type ENABLE_BASIC = crate::Reg<enable_basic::ENABLE_BASIC_SPEC>;
    #[doc = "Enable basic interrupts"]
    pub mod enable_basic {
        #[doc = "Register `ENABLE_BASIC` reader"]
        pub type R = crate::R<ENABLE_BASIC_SPEC>;
        #[doc = "Register `ENABLE_BASIC` writer"]
        pub type W = crate::W<ENABLE_BASIC_SPEC>;
        #[doc = "Field `TIMER` reader - ARMC Timer"]
        pub type TIMER_R = crate::BitReader;
        #[doc = "Field `TIMER` writer - ARMC Timer"]
        pub type TIMER_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `MAILBOX` reader - Mailbox"]
        pub type MAILBOX_R = crate::BitReader;
        #[doc = "Field `MAILBOX` writer - Mailbox"]
        pub type MAILBOX_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DOORBELL0` reader - Doorbell 0"]
        pub type DOORBELL0_R = crate::BitReader;
        #[doc = "Field `DOORBELL0` writer - Doorbell 0"]
        pub type DOORBELL0_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `DOORBELL1` reader - Doorbell 1"]
        pub type DOORBELL1_R = crate::BitReader;
        #[doc = "Field `DOORBELL1` writer - Doorbell 1"]
        pub type DOORBELL1_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `VPU0_HALTED` reader - VPU0 halted"]
        pub type VPU0_HALTED_R = crate::BitReader;
        #[doc = "Field `VPU0_HALTED` writer - VPU0 halted"]
        pub type VPU0_HALTED_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `VPU1_HALTED` reader - VPU1 halted"]
        pub type VPU1_HALTED_R = crate::BitReader;
        #[doc = "Field `VPU1_HALTED` writer - VPU1 halted"]
        pub type VPU1_HALTED_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `ARM_ADDRESS_ERROR` reader - ARM address error"]
        pub type ARM_ADDRESS_ERROR_R = crate::BitReader;
        #[doc = "Field `ARM_ADDRESS_ERROR` writer - ARM address error"]
        pub type ARM_ADDRESS_ERROR_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        #[doc = "Field `ARM_AXI_ERROR` reader - ARM AXI error"]
        pub type ARM_AXI_ERROR_R = crate::BitReader;
        #[doc = "Field `ARM_AXI_ERROR` writer - ARM AXI error"]
        pub type ARM_AXI_ERROR_W<'a, REG, const O: u8> = crate::BitWriter1S<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - ARMC Timer"]
            #[inline(always)]
            pub fn timer(&self) -> TIMER_R {
                TIMER_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Mailbox"]
            #[inline(always)]
            pub fn mailbox(&self) -> MAILBOX_R {
                MAILBOX_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Doorbell 0"]
            #[inline(always)]
            pub fn doorbell0(&self) -> DOORBELL0_R {
                DOORBELL0_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Doorbell 1"]
            #[inline(always)]
            pub fn doorbell1(&self) -> DOORBELL1_R {
                DOORBELL1_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - VPU0 halted"]
            #[inline(always)]
            pub fn vpu0_halted(&self) -> VPU0_HALTED_R {
                VPU0_HALTED_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - VPU1 halted"]
            #[inline(always)]
            pub fn vpu1_halted(&self) -> VPU1_HALTED_R {
                VPU1_HALTED_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - ARM address error"]
            #[inline(always)]
            pub fn arm_address_error(&self) -> ARM_ADDRESS_ERROR_R {
                ARM_ADDRESS_ERROR_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ARM AXI error"]
            #[inline(always)]
            pub fn arm_axi_error(&self) -> ARM_AXI_ERROR_R {
                ARM_AXI_ERROR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ENABLE_BASIC")
                    .field("timer", &format_args!("{}", self.timer().bit()))
                    .field("mailbox", &format_args!("{}", self.mailbox().bit()))
                    .field("doorbell0", &format_args!("{}", self.doorbell0().bit()))
                    .field("doorbell1", &format_args!("{}", self.doorbell1().bit()))
                    .field("vpu0_halted", &format_args!("{}", self.vpu0_halted().bit()))
                    .field("vpu1_halted", &format_args!("{}", self.vpu1_halted().bit()))
                    .field(
                        "arm_address_error",
                        &format_args!("{}", self.arm_address_error().bit()),
                    )
                    .field(
                        "arm_axi_error",
                        &format_args!("{}", self.arm_axi_error().bit()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<ENABLE_BASIC_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - ARMC Timer"]
            #[inline(always)]
            #[must_use]
            pub fn timer(&mut self) -> TIMER_W<ENABLE_BASIC_SPEC, 0> {
                TIMER_W::new(self)
            }
            #[doc = "Bit 1 - Mailbox"]
            #[inline(always)]
            #[must_use]
            pub fn mailbox(&mut self) -> MAILBOX_W<ENABLE_BASIC_SPEC, 1> {
                MAILBOX_W::new(self)
            }
            #[doc = "Bit 2 - Doorbell 0"]
            #[inline(always)]
            #[must_use]
            pub fn doorbell0(&mut self) -> DOORBELL0_W<ENABLE_BASIC_SPEC, 2> {
                DOORBELL0_W::new(self)
            }
            #[doc = "Bit 3 - Doorbell 1"]
            #[inline(always)]
            #[must_use]
            pub fn doorbell1(&mut self) -> DOORBELL1_W<ENABLE_BASIC_SPEC, 3> {
                DOORBELL1_W::new(self)
            }
            #[doc = "Bit 4 - VPU0 halted"]
            #[inline(always)]
            #[must_use]
            pub fn vpu0_halted(&mut self) -> VPU0_HALTED_W<ENABLE_BASIC_SPEC, 4> {
                VPU0_HALTED_W::new(self)
            }
            #[doc = "Bit 5 - VPU1 halted"]
            #[inline(always)]
            #[must_use]
            pub fn vpu1_halted(&mut self) -> VPU1_HALTED_W<ENABLE_BASIC_SPEC, 5> {
                VPU1_HALTED_W::new(self)
            }
            #[doc = "Bit 6 - ARM address error"]
            #[inline(always)]
            #[must_use]
            pub fn arm_address_error(&mut self) -> ARM_ADDRESS_ERROR_W<ENABLE_BASIC_SPEC, 6> {
                ARM_ADDRESS_ERROR_W::new(self)
            }
            #[doc = "Bit 7 - ARM AXI error"]
            #[inline(always)]
            #[must_use]
            pub fn arm_axi_error(&mut self) -> ARM_AXI_ERROR_W<ENABLE_BASIC_SPEC, 7> {
                ARM_AXI_ERROR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Enable basic interrupts\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable_basic::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable_basic::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ENABLE_BASIC_SPEC;
        impl crate::RegisterSpec for ENABLE_BASIC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`enable_basic::R`](R) reader structure"]
        impl crate::Readable for ENABLE_BASIC_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`enable_basic::W`](W) writer structure"]
        impl crate::Writable for ENABLE_BASIC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xff;
        }
        #[doc = "`reset()` method sets ENABLE_BASIC to value 0"]
        impl crate::Resettable for ENABLE_BASIC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DISABLE_1 (rw) register accessor: Disable interrupts 1 - 31\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`disable_1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`disable_1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@disable_1`]
module"]
    pub type DISABLE_1 = crate::Reg<disable_1::DISABLE_1_SPEC>;
    #[doc = "Disable interrupts 1 - 31"]
    pub mod disable_1 {
        #[doc = "Register `DISABLE_1` reader"]
        pub type R = crate::R<DISABLE_1_SPEC>;
        #[doc = "Register `DISABLE_1` writer"]
        pub type W = crate::W<DISABLE_1_SPEC>;
        #[doc = "Field `TIMER_0` reader - Timer 0"]
        pub type TIMER_0_R = crate::BitReader;
        #[doc = "Field `TIMER_0` writer - Timer 0"]
        pub type TIMER_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `TIMER_1` reader - Timer 1"]
        pub type TIMER_1_R = crate::BitReader;
        #[doc = "Field `TIMER_1` writer - Timer 1"]
        pub type TIMER_1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `TIMER_2` reader - Timer 2"]
        pub type TIMER_2_R = crate::BitReader;
        #[doc = "Field `TIMER_2` writer - Timer 2"]
        pub type TIMER_2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `TIMER_3` reader - Timer 3"]
        pub type TIMER_3_R = crate::BitReader;
        #[doc = "Field `TIMER_3` writer - Timer 3"]
        pub type TIMER_3_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `H264_0` reader - H264 0"]
        pub type H264_0_R = crate::BitReader;
        #[doc = "Field `H264_0` writer - H264 0"]
        pub type H264_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `H264_1` reader - H264 1"]
        pub type H264_1_R = crate::BitReader;
        #[doc = "Field `H264_1` writer - H264 1"]
        pub type H264_1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `H264_2` reader - H264 2"]
        pub type H264_2_R = crate::BitReader;
        #[doc = "Field `H264_2` writer - H264 2"]
        pub type H264_2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `JPEG` reader - JPEG"]
        pub type JPEG_R = crate::BitReader;
        #[doc = "Field `JPEG` writer - JPEG"]
        pub type JPEG_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `ISP` reader - ISP"]
        pub type ISP_R = crate::BitReader;
        #[doc = "Field `ISP` writer - ISP"]
        pub type ISP_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `USB` reader - USB"]
        pub type USB_R = crate::BitReader;
        #[doc = "Field `USB` writer - USB"]
        pub type USB_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `V3D` reader - V3D"]
        pub type V3D_R = crate::BitReader;
        #[doc = "Field `V3D` writer - V3D"]
        pub type V3D_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `TRANSPOSER` reader - Transposer"]
        pub type TRANSPOSER_R = crate::BitReader;
        #[doc = "Field `TRANSPOSER` writer - Transposer"]
        pub type TRANSPOSER_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `MULTICORE_SYNC_0` reader - Multicore Sync 0"]
        pub type MULTICORE_SYNC_0_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_0` writer - Multicore Sync 0"]
        pub type MULTICORE_SYNC_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `MULTICORE_SYNC_1` reader - Multicore Sync 1"]
        pub type MULTICORE_SYNC_1_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_1` writer - Multicore Sync 1"]
        pub type MULTICORE_SYNC_1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `MULTICORE_SYNC_2` reader - Multicore Sync 2"]
        pub type MULTICORE_SYNC_2_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_2` writer - Multicore Sync 2"]
        pub type MULTICORE_SYNC_2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `MULTICORE_SYNC_3` reader - Multicore Sync 3"]
        pub type MULTICORE_SYNC_3_R = crate::BitReader;
        #[doc = "Field `MULTICORE_SYNC_3` writer - Multicore Sync 3"]
        pub type MULTICORE_SYNC_3_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_0` reader - DMA 0"]
        pub type DMA_0_R = crate::BitReader;
        #[doc = "Field `DMA_0` writer - DMA 0"]
        pub type DMA_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_1` reader - DMA 1"]
        pub type DMA_1_R = crate::BitReader;
        #[doc = "Field `DMA_1` writer - DMA 1"]
        pub type DMA_1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_2` reader - DMA 2"]
        pub type DMA_2_R = crate::BitReader;
        #[doc = "Field `DMA_2` writer - DMA 2"]
        pub type DMA_2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_3` reader - DMA 3"]
        pub type DMA_3_R = crate::BitReader;
        #[doc = "Field `DMA_3` writer - DMA 3"]
        pub type DMA_3_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_4` reader - DMA 4"]
        pub type DMA_4_R = crate::BitReader;
        #[doc = "Field `DMA_4` writer - DMA 4"]
        pub type DMA_4_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_5` reader - DMA 5"]
        pub type DMA_5_R = crate::BitReader;
        #[doc = "Field `DMA_5` writer - DMA 5"]
        pub type DMA_5_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_6` reader - DMA 6"]
        pub type DMA_6_R = crate::BitReader;
        #[doc = "Field `DMA_6` writer - DMA 6"]
        pub type DMA_6_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_7_8` reader - OR of DMA 7 and 8"]
        pub type DMA_7_8_R = crate::BitReader;
        #[doc = "Field `DMA_7_8` writer - OR of DMA 7 and 8"]
        pub type DMA_7_8_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_9_10` reader - OR of DMA 9 and 10"]
        pub type DMA_9_10_R = crate::BitReader;
        #[doc = "Field `DMA_9_10` writer - OR of DMA 9 and 10"]
        pub type DMA_9_10_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_11` reader - DMA 11"]
        pub type DMA_11_R = crate::BitReader;
        #[doc = "Field `DMA_11` writer - DMA 11"]
        pub type DMA_11_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_12` reader - DMA 12"]
        pub type DMA_12_R = crate::BitReader;
        #[doc = "Field `DMA_12` writer - DMA 12"]
        pub type DMA_12_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_13` reader - DMA 13"]
        pub type DMA_13_R = crate::BitReader;
        #[doc = "Field `DMA_13` writer - DMA 13"]
        pub type DMA_13_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_14` reader - DMA 14"]
        pub type DMA_14_R = crate::BitReader;
        #[doc = "Field `DMA_14` writer - DMA 14"]
        pub type DMA_14_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `AUX` reader - OR of UART1, SPI1 and SPI2"]
        pub type AUX_R = crate::BitReader;
        #[doc = "Field `AUX` writer - OR of UART1, SPI1 and SPI2"]
        pub type AUX_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `ARM` reader - ARM"]
        pub type ARM_R = crate::BitReader;
        #[doc = "Field `ARM` writer - ARM"]
        pub type ARM_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DMA_15` reader - DMA 15"]
        pub type DMA_15_R = crate::BitReader;
        #[doc = "Field `DMA_15` writer - DMA 15"]
        pub type DMA_15_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Timer 0"]
            #[inline(always)]
            pub fn timer_0(&self) -> TIMER_0_R {
                TIMER_0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Timer 1"]
            #[inline(always)]
            pub fn timer_1(&self) -> TIMER_1_R {
                TIMER_1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Timer 2"]
            #[inline(always)]
            pub fn timer_2(&self) -> TIMER_2_R {
                TIMER_2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Timer 3"]
            #[inline(always)]
            pub fn timer_3(&self) -> TIMER_3_R {
                TIMER_3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - H264 0"]
            #[inline(always)]
            pub fn h264_0(&self) -> H264_0_R {
                H264_0_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - H264 1"]
            #[inline(always)]
            pub fn h264_1(&self) -> H264_1_R {
                H264_1_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - H264 2"]
            #[inline(always)]
            pub fn h264_2(&self) -> H264_2_R {
                H264_2_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - JPEG"]
            #[inline(always)]
            pub fn jpeg(&self) -> JPEG_R {
                JPEG_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - ISP"]
            #[inline(always)]
            pub fn isp(&self) -> ISP_R {
                ISP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - USB"]
            #[inline(always)]
            pub fn usb(&self) -> USB_R {
                USB_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - V3D"]
            #[inline(always)]
            pub fn v3d(&self) -> V3D_R {
                V3D_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Transposer"]
            #[inline(always)]
            pub fn transposer(&self) -> TRANSPOSER_R {
                TRANSPOSER_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Multicore Sync 0"]
            #[inline(always)]
            pub fn multicore_sync_0(&self) -> MULTICORE_SYNC_0_R {
                MULTICORE_SYNC_0_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Multicore Sync 1"]
            #[inline(always)]
            pub fn multicore_sync_1(&self) -> MULTICORE_SYNC_1_R {
                MULTICORE_SYNC_1_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Multicore Sync 2"]
            #[inline(always)]
            pub fn multicore_sync_2(&self) -> MULTICORE_SYNC_2_R {
                MULTICORE_SYNC_2_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Multicore Sync 3"]
            #[inline(always)]
            pub fn multicore_sync_3(&self) -> MULTICORE_SYNC_3_R {
                MULTICORE_SYNC_3_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - DMA 0"]
            #[inline(always)]
            pub fn dma_0(&self) -> DMA_0_R {
                DMA_0_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - DMA 1"]
            #[inline(always)]
            pub fn dma_1(&self) -> DMA_1_R {
                DMA_1_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - DMA 2"]
            #[inline(always)]
            pub fn dma_2(&self) -> DMA_2_R {
                DMA_2_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - DMA 3"]
            #[inline(always)]
            pub fn dma_3(&self) -> DMA_3_R {
                DMA_3_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - DMA 4"]
            #[inline(always)]
            pub fn dma_4(&self) -> DMA_4_R {
                DMA_4_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - DMA 5"]
            #[inline(always)]
            pub fn dma_5(&self) -> DMA_5_R {
                DMA_5_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - DMA 6"]
            #[inline(always)]
            pub fn dma_6(&self) -> DMA_6_R {
                DMA_6_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - OR of DMA 7 and 8"]
            #[inline(always)]
            pub fn dma_7_8(&self) -> DMA_7_8_R {
                DMA_7_8_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - OR of DMA 9 and 10"]
            #[inline(always)]
            pub fn dma_9_10(&self) -> DMA_9_10_R {
                DMA_9_10_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - DMA 11"]
            #[inline(always)]
            pub fn dma_11(&self) -> DMA_11_R {
                DMA_11_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - DMA 12"]
            #[inline(always)]
            pub fn dma_12(&self) -> DMA_12_R {
                DMA_12_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - DMA 13"]
            #[inline(always)]
            pub fn dma_13(&self) -> DMA_13_R {
                DMA_13_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - DMA 14"]
            #[inline(always)]
            pub fn dma_14(&self) -> DMA_14_R {
                DMA_14_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - OR of UART1, SPI1 and SPI2"]
            #[inline(always)]
            pub fn aux(&self) -> AUX_R {
                AUX_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - ARM"]
            #[inline(always)]
            pub fn arm(&self) -> ARM_R {
                ARM_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - DMA 15"]
            #[inline(always)]
            pub fn dma_15(&self) -> DMA_15_R {
                DMA_15_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DISABLE_1")
                    .field("timer_0", &format_args!("{}", self.timer_0().bit()))
                    .field("timer_1", &format_args!("{}", self.timer_1().bit()))
                    .field("timer_2", &format_args!("{}", self.timer_2().bit()))
                    .field("timer_3", &format_args!("{}", self.timer_3().bit()))
                    .field("h264_0", &format_args!("{}", self.h264_0().bit()))
                    .field("h264_1", &format_args!("{}", self.h264_1().bit()))
                    .field("h264_2", &format_args!("{}", self.h264_2().bit()))
                    .field("jpeg", &format_args!("{}", self.jpeg().bit()))
                    .field("isp", &format_args!("{}", self.isp().bit()))
                    .field("usb", &format_args!("{}", self.usb().bit()))
                    .field("v3d", &format_args!("{}", self.v3d().bit()))
                    .field("transposer", &format_args!("{}", self.transposer().bit()))
                    .field(
                        "multicore_sync_0",
                        &format_args!("{}", self.multicore_sync_0().bit()),
                    )
                    .field(
                        "multicore_sync_1",
                        &format_args!("{}", self.multicore_sync_1().bit()),
                    )
                    .field(
                        "multicore_sync_2",
                        &format_args!("{}", self.multicore_sync_2().bit()),
                    )
                    .field(
                        "multicore_sync_3",
                        &format_args!("{}", self.multicore_sync_3().bit()),
                    )
                    .field("dma_0", &format_args!("{}", self.dma_0().bit()))
                    .field("dma_1", &format_args!("{}", self.dma_1().bit()))
                    .field("dma_2", &format_args!("{}", self.dma_2().bit()))
                    .field("dma_3", &format_args!("{}", self.dma_3().bit()))
                    .field("dma_4", &format_args!("{}", self.dma_4().bit()))
                    .field("dma_5", &format_args!("{}", self.dma_5().bit()))
                    .field("dma_6", &format_args!("{}", self.dma_6().bit()))
                    .field("dma_7_8", &format_args!("{}", self.dma_7_8().bit()))
                    .field("dma_9_10", &format_args!("{}", self.dma_9_10().bit()))
                    .field("dma_11", &format_args!("{}", self.dma_11().bit()))
                    .field("dma_12", &format_args!("{}", self.dma_12().bit()))
                    .field("dma_13", &format_args!("{}", self.dma_13().bit()))
                    .field("dma_14", &format_args!("{}", self.dma_14().bit()))
                    .field("aux", &format_args!("{}", self.aux().bit()))
                    .field("arm", &format_args!("{}", self.arm().bit()))
                    .field("dma_15", &format_args!("{}", self.dma_15().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DISABLE_1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Timer 0"]
            #[inline(always)]
            #[must_use]
            pub fn timer_0(&mut self) -> TIMER_0_W<DISABLE_1_SPEC, 0> {
                TIMER_0_W::new(self)
            }
            #[doc = "Bit 1 - Timer 1"]
            #[inline(always)]
            #[must_use]
            pub fn timer_1(&mut self) -> TIMER_1_W<DISABLE_1_SPEC, 1> {
                TIMER_1_W::new(self)
            }
            #[doc = "Bit 2 - Timer 2"]
            #[inline(always)]
            #[must_use]
            pub fn timer_2(&mut self) -> TIMER_2_W<DISABLE_1_SPEC, 2> {
                TIMER_2_W::new(self)
            }
            #[doc = "Bit 3 - Timer 3"]
            #[inline(always)]
            #[must_use]
            pub fn timer_3(&mut self) -> TIMER_3_W<DISABLE_1_SPEC, 3> {
                TIMER_3_W::new(self)
            }
            #[doc = "Bit 4 - H264 0"]
            #[inline(always)]
            #[must_use]
            pub fn h264_0(&mut self) -> H264_0_W<DISABLE_1_SPEC, 4> {
                H264_0_W::new(self)
            }
            #[doc = "Bit 5 - H264 1"]
            #[inline(always)]
            #[must_use]
            pub fn h264_1(&mut self) -> H264_1_W<DISABLE_1_SPEC, 5> {
                H264_1_W::new(self)
            }
            #[doc = "Bit 6 - H264 2"]
            #[inline(always)]
            #[must_use]
            pub fn h264_2(&mut self) -> H264_2_W<DISABLE_1_SPEC, 6> {
                H264_2_W::new(self)
            }
            #[doc = "Bit 7 - JPEG"]
            #[inline(always)]
            #[must_use]
            pub fn jpeg(&mut self) -> JPEG_W<DISABLE_1_SPEC, 7> {
                JPEG_W::new(self)
            }
            #[doc = "Bit 8 - ISP"]
            #[inline(always)]
            #[must_use]
            pub fn isp(&mut self) -> ISP_W<DISABLE_1_SPEC, 8> {
                ISP_W::new(self)
            }
            #[doc = "Bit 9 - USB"]
            #[inline(always)]
            #[must_use]
            pub fn usb(&mut self) -> USB_W<DISABLE_1_SPEC, 9> {
                USB_W::new(self)
            }
            #[doc = "Bit 10 - V3D"]
            #[inline(always)]
            #[must_use]
            pub fn v3d(&mut self) -> V3D_W<DISABLE_1_SPEC, 10> {
                V3D_W::new(self)
            }
            #[doc = "Bit 11 - Transposer"]
            #[inline(always)]
            #[must_use]
            pub fn transposer(&mut self) -> TRANSPOSER_W<DISABLE_1_SPEC, 11> {
                TRANSPOSER_W::new(self)
            }
            #[doc = "Bit 12 - Multicore Sync 0"]
            #[inline(always)]
            #[must_use]
            pub fn multicore_sync_0(&mut self) -> MULTICORE_SYNC_0_W<DISABLE_1_SPEC, 12> {
                MULTICORE_SYNC_0_W::new(self)
            }
            #[doc = "Bit 13 - Multicore Sync 1"]
            #[inline(always)]
            #[must_use]
            pub fn multicore_sync_1(&mut self) -> MULTICORE_SYNC_1_W<DISABLE_1_SPEC, 13> {
                MULTICORE_SYNC_1_W::new(self)
            }
            #[doc = "Bit 14 - Multicore Sync 2"]
            #[inline(always)]
            #[must_use]
            pub fn multicore_sync_2(&mut self) -> MULTICORE_SYNC_2_W<DISABLE_1_SPEC, 14> {
                MULTICORE_SYNC_2_W::new(self)
            }
            #[doc = "Bit 15 - Multicore Sync 3"]
            #[inline(always)]
            #[must_use]
            pub fn multicore_sync_3(&mut self) -> MULTICORE_SYNC_3_W<DISABLE_1_SPEC, 15> {
                MULTICORE_SYNC_3_W::new(self)
            }
            #[doc = "Bit 16 - DMA 0"]
            #[inline(always)]
            #[must_use]
            pub fn dma_0(&mut self) -> DMA_0_W<DISABLE_1_SPEC, 16> {
                DMA_0_W::new(self)
            }
            #[doc = "Bit 17 - DMA 1"]
            #[inline(always)]
            #[must_use]
            pub fn dma_1(&mut self) -> DMA_1_W<DISABLE_1_SPEC, 17> {
                DMA_1_W::new(self)
            }
            #[doc = "Bit 18 - DMA 2"]
            #[inline(always)]
            #[must_use]
            pub fn dma_2(&mut self) -> DMA_2_W<DISABLE_1_SPEC, 18> {
                DMA_2_W::new(self)
            }
            #[doc = "Bit 19 - DMA 3"]
            #[inline(always)]
            #[must_use]
            pub fn dma_3(&mut self) -> DMA_3_W<DISABLE_1_SPEC, 19> {
                DMA_3_W::new(self)
            }
            #[doc = "Bit 20 - DMA 4"]
            #[inline(always)]
            #[must_use]
            pub fn dma_4(&mut self) -> DMA_4_W<DISABLE_1_SPEC, 20> {
                DMA_4_W::new(self)
            }
            #[doc = "Bit 21 - DMA 5"]
            #[inline(always)]
            #[must_use]
            pub fn dma_5(&mut self) -> DMA_5_W<DISABLE_1_SPEC, 21> {
                DMA_5_W::new(self)
            }
            #[doc = "Bit 22 - DMA 6"]
            #[inline(always)]
            #[must_use]
            pub fn dma_6(&mut self) -> DMA_6_W<DISABLE_1_SPEC, 22> {
                DMA_6_W::new(self)
            }
            #[doc = "Bit 23 - OR of DMA 7 and 8"]
            #[inline(always)]
            #[must_use]
            pub fn dma_7_8(&mut self) -> DMA_7_8_W<DISABLE_1_SPEC, 23> {
                DMA_7_8_W::new(self)
            }
            #[doc = "Bit 24 - OR of DMA 9 and 10"]
            #[inline(always)]
            #[must_use]
            pub fn dma_9_10(&mut self) -> DMA_9_10_W<DISABLE_1_SPEC, 24> {
                DMA_9_10_W::new(self)
            }
            #[doc = "Bit 25 - DMA 11"]
            #[inline(always)]
            #[must_use]
            pub fn dma_11(&mut self) -> DMA_11_W<DISABLE_1_SPEC, 25> {
                DMA_11_W::new(self)
            }
            #[doc = "Bit 26 - DMA 12"]
            #[inline(always)]
            #[must_use]
            pub fn dma_12(&mut self) -> DMA_12_W<DISABLE_1_SPEC, 26> {
                DMA_12_W::new(self)
            }
            #[doc = "Bit 27 - DMA 13"]
            #[inline(always)]
            #[must_use]
            pub fn dma_13(&mut self) -> DMA_13_W<DISABLE_1_SPEC, 27> {
                DMA_13_W::new(self)
            }
            #[doc = "Bit 28 - DMA 14"]
            #[inline(always)]
            #[must_use]
            pub fn dma_14(&mut self) -> DMA_14_W<DISABLE_1_SPEC, 28> {
                DMA_14_W::new(self)
            }
            #[doc = "Bit 29 - OR of UART1, SPI1 and SPI2"]
            #[inline(always)]
            #[must_use]
            pub fn aux(&mut self) -> AUX_W<DISABLE_1_SPEC, 29> {
                AUX_W::new(self)
            }
            #[doc = "Bit 30 - ARM"]
            #[inline(always)]
            #[must_use]
            pub fn arm(&mut self) -> ARM_W<DISABLE_1_SPEC, 30> {
                ARM_W::new(self)
            }
            #[doc = "Bit 31 - DMA 15"]
            #[inline(always)]
            #[must_use]
            pub fn dma_15(&mut self) -> DMA_15_W<DISABLE_1_SPEC, 31> {
                DMA_15_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Disable interrupts 1 - 31\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`disable_1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`disable_1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DISABLE_1_SPEC;
        impl crate::RegisterSpec for DISABLE_1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`disable_1::R`](R) reader structure"]
        impl crate::Readable for DISABLE_1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`disable_1::W`](W) writer structure"]
        impl crate::Writable for DISABLE_1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xffff_ffff;
        }
        #[doc = "`reset()` method sets DISABLE_1 to value 0"]
        impl crate::Resettable for DISABLE_1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DISABLE_2 (rw) register accessor: Disable interrupts 32 - 63\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`disable_2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`disable_2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@disable_2`]
module"]
    pub type DISABLE_2 = crate::Reg<disable_2::DISABLE_2_SPEC>;
    #[doc = "Disable interrupts 32 - 63"]
    pub mod disable_2 {
        #[doc = "Register `DISABLE_2` reader"]
        pub type R = crate::R<DISABLE_2_SPEC>;
        #[doc = "Register `DISABLE_2` writer"]
        pub type W = crate::W<DISABLE_2_SPEC>;
        #[doc = "Field `HDMI_CEC` reader - HDMI CEC"]
        pub type HDMI_CEC_R = crate::BitReader;
        #[doc = "Field `HDMI_CEC` writer - HDMI CEC"]
        pub type HDMI_CEC_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `HVS` reader - HVS"]
        pub type HVS_R = crate::BitReader;
        #[doc = "Field `HVS` writer - HVS"]
        pub type HVS_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `RPIVID` reader - RPIVID"]
        pub type RPIVID_R = crate::BitReader;
        #[doc = "Field `RPIVID` writer - RPIVID"]
        pub type RPIVID_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `SDC` reader - SDC"]
        pub type SDC_R = crate::BitReader;
        #[doc = "Field `SDC` writer - SDC"]
        pub type SDC_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DSI_0` reader - DSI 0"]
        pub type DSI_0_R = crate::BitReader;
        #[doc = "Field `DSI_0` writer - DSI 0"]
        pub type DSI_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `PIXEL_VALVE_2` reader - Pixel Valve 2"]
        pub type PIXEL_VALVE_2_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_2` writer - Pixel Valve 2"]
        pub type PIXEL_VALVE_2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CAMERA_0` reader - Camera 0"]
        pub type CAMERA_0_R = crate::BitReader;
        #[doc = "Field `CAMERA_0` writer - Camera 0"]
        pub type CAMERA_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CAMERA_1` reader - Camera 1"]
        pub type CAMERA_1_R = crate::BitReader;
        #[doc = "Field `CAMERA_1` writer - Camera 1"]
        pub type CAMERA_1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `HDMI_0` reader - HDMI 0"]
        pub type HDMI_0_R = crate::BitReader;
        #[doc = "Field `HDMI_0` writer - HDMI 0"]
        pub type HDMI_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `HDMI_1` reader - HDMI 1"]
        pub type HDMI_1_R = crate::BitReader;
        #[doc = "Field `HDMI_1` writer - HDMI 1"]
        pub type HDMI_1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `PIXEL_VALVE_3` reader - Pixel Valve 3"]
        pub type PIXEL_VALVE_3_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_3` writer - Pixel Valve 3"]
        pub type PIXEL_VALVE_3_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `SPI_BSC_SLAVE` reader - SPI/BSC Slave"]
        pub type SPI_BSC_SLAVE_R = crate::BitReader;
        #[doc = "Field `SPI_BSC_SLAVE` writer - SPI/BSC Slave"]
        pub type SPI_BSC_SLAVE_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DSI_1` reader - DSI 1"]
        pub type DSI_1_R = crate::BitReader;
        #[doc = "Field `DSI_1` writer - DSI 1"]
        pub type DSI_1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `PIXEL_VALVE_0` reader - Pixel Valve 0"]
        pub type PIXEL_VALVE_0_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_0` writer - Pixel Valve 0"]
        pub type PIXEL_VALVE_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `PIXEL_VALVE_1_2` reader - OR of Pixel Valve 1 and 2"]
        pub type PIXEL_VALVE_1_2_R = crate::BitReader;
        #[doc = "Field `PIXEL_VALVE_1_2` writer - OR of Pixel Valve 1 and 2"]
        pub type PIXEL_VALVE_1_2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CPR` reader - CPR"]
        pub type CPR_R = crate::BitReader;
        #[doc = "Field `CPR` writer - CPR"]
        pub type CPR_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `SMI` reader - SMI"]
        pub type SMI_R = crate::BitReader;
        #[doc = "Field `SMI` writer - SMI"]
        pub type SMI_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `GPIO_0` reader - GPIO 0"]
        pub type GPIO_0_R = crate::BitReader;
        #[doc = "Field `GPIO_0` writer - GPIO 0"]
        pub type GPIO_0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `GPIO_1` reader - GPIO 1"]
        pub type GPIO_1_R = crate::BitReader;
        #[doc = "Field `GPIO_1` writer - GPIO 1"]
        pub type GPIO_1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `GPIO_2` reader - GPIO 2"]
        pub type GPIO_2_R = crate::BitReader;
        #[doc = "Field `GPIO_2` writer - GPIO 2"]
        pub type GPIO_2_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `GPIO_3` reader - GPIO 3"]
        pub type GPIO_3_R = crate::BitReader;
        #[doc = "Field `GPIO_3` writer - GPIO 3"]
        pub type GPIO_3_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `I2C` reader - OR of all I2C"]
        pub type I2C_R = crate::BitReader;
        #[doc = "Field `I2C` writer - OR of all I2C"]
        pub type I2C_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `SPI` reader - OR of all SPI"]
        pub type SPI_R = crate::BitReader;
        #[doc = "Field `SPI` writer - OR of all SPI"]
        pub type SPI_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `PCM_I2S` reader - PCM/I2S"]
        pub type PCM_I2S_R = crate::BitReader;
        #[doc = "Field `PCM_I2S` writer - PCM/I2S"]
        pub type PCM_I2S_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `SDHOST` reader - SDHOST"]
        pub type SDHOST_R = crate::BitReader;
        #[doc = "Field `SDHOST` writer - SDHOST"]
        pub type SDHOST_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `UART` reader - OR of all PL011 UARTs"]
        pub type UART_R = crate::BitReader;
        #[doc = "Field `UART` writer - OR of all PL011 UARTs"]
        pub type UART_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `ETH_PCIE` reader - OR of all ETH_PCIe L2"]
        pub type ETH_PCIE_R = crate::BitReader;
        #[doc = "Field `ETH_PCIE` writer - OR of all ETH_PCIe L2"]
        pub type ETH_PCIE_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `VEC` reader - VEC"]
        pub type VEC_R = crate::BitReader;
        #[doc = "Field `VEC` writer - VEC"]
        pub type VEC_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `CPG` reader - CPG"]
        pub type CPG_R = crate::BitReader;
        #[doc = "Field `CPG` writer - CPG"]
        pub type CPG_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `RNG` reader - RNG"]
        pub type RNG_R = crate::BitReader;
        #[doc = "Field `RNG` writer - RNG"]
        pub type RNG_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `EMMC` reader - OR of EMMC and EMMC2"]
        pub type EMMC_R = crate::BitReader;
        #[doc = "Field `EMMC` writer - OR of EMMC and EMMC2"]
        pub type EMMC_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `ETH_PCIE_SECURE` reader - ETH_PCIe secure"]
        pub type ETH_PCIE_SECURE_R = crate::BitReader;
        #[doc = "Field `ETH_PCIE_SECURE` writer - ETH_PCIe secure"]
        pub type ETH_PCIE_SECURE_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - HDMI CEC"]
            #[inline(always)]
            pub fn hdmi_cec(&self) -> HDMI_CEC_R {
                HDMI_CEC_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - HVS"]
            #[inline(always)]
            pub fn hvs(&self) -> HVS_R {
                HVS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RPIVID"]
            #[inline(always)]
            pub fn rpivid(&self) -> RPIVID_R {
                RPIVID_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - SDC"]
            #[inline(always)]
            pub fn sdc(&self) -> SDC_R {
                SDC_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - DSI 0"]
            #[inline(always)]
            pub fn dsi_0(&self) -> DSI_0_R {
                DSI_0_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Pixel Valve 2"]
            #[inline(always)]
            pub fn pixel_valve_2(&self) -> PIXEL_VALVE_2_R {
                PIXEL_VALVE_2_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Camera 0"]
            #[inline(always)]
            pub fn camera_0(&self) -> CAMERA_0_R {
                CAMERA_0_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Camera 1"]
            #[inline(always)]
            pub fn camera_1(&self) -> CAMERA_1_R {
                CAMERA_1_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - HDMI 0"]
            #[inline(always)]
            pub fn hdmi_0(&self) -> HDMI_0_R {
                HDMI_0_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - HDMI 1"]
            #[inline(always)]
            pub fn hdmi_1(&self) -> HDMI_1_R {
                HDMI_1_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Pixel Valve 3"]
            #[inline(always)]
            pub fn pixel_valve_3(&self) -> PIXEL_VALVE_3_R {
                PIXEL_VALVE_3_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - SPI/BSC Slave"]
            #[inline(always)]
            pub fn spi_bsc_slave(&self) -> SPI_BSC_SLAVE_R {
                SPI_BSC_SLAVE_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - DSI 1"]
            #[inline(always)]
            pub fn dsi_1(&self) -> DSI_1_R {
                DSI_1_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Pixel Valve 0"]
            #[inline(always)]
            pub fn pixel_valve_0(&self) -> PIXEL_VALVE_0_R {
                PIXEL_VALVE_0_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - OR of Pixel Valve 1 and 2"]
            #[inline(always)]
            pub fn pixel_valve_1_2(&self) -> PIXEL_VALVE_1_2_R {
                PIXEL_VALVE_1_2_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - CPR"]
            #[inline(always)]
            pub fn cpr(&self) -> CPR_R {
                CPR_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - SMI"]
            #[inline(always)]
            pub fn smi(&self) -> SMI_R {
                SMI_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - GPIO 0"]
            #[inline(always)]
            pub fn gpio_0(&self) -> GPIO_0_R {
                GPIO_0_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - GPIO 1"]
            #[inline(always)]
            pub fn gpio_1(&self) -> GPIO_1_R {
                GPIO_1_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - GPIO 2"]
            #[inline(always)]
            pub fn gpio_2(&self) -> GPIO_2_R {
                GPIO_2_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - GPIO 3"]
            #[inline(always)]
            pub fn gpio_3(&self) -> GPIO_3_R {
                GPIO_3_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - OR of all I2C"]
            #[inline(always)]
            pub fn i2c(&self) -> I2C_R {
                I2C_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - OR of all SPI"]
            #[inline(always)]
            pub fn spi(&self) -> SPI_R {
                SPI_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - PCM/I2S"]
            #[inline(always)]
            pub fn pcm_i2s(&self) -> PCM_I2S_R {
                PCM_I2S_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - SDHOST"]
            #[inline(always)]
            pub fn sdhost(&self) -> SDHOST_R {
                SDHOST_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - OR of all PL011 UARTs"]
            #[inline(always)]
            pub fn uart(&self) -> UART_R {
                UART_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - OR of all ETH_PCIe L2"]
            #[inline(always)]
            pub fn eth_pcie(&self) -> ETH_PCIE_R {
                ETH_PCIE_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - VEC"]
            #[inline(always)]
            pub fn vec(&self) -> VEC_R {
                VEC_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - CPG"]
            #[inline(always)]
            pub fn cpg(&self) -> CPG_R {
                CPG_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - RNG"]
            #[inline(always)]
            pub fn rng(&self) -> RNG_R {
                RNG_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - OR of EMMC and EMMC2"]
            #[inline(always)]
            pub fn emmc(&self) -> EMMC_R {
                EMMC_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - ETH_PCIe secure"]
            #[inline(always)]
            pub fn eth_pcie_secure(&self) -> ETH_PCIE_SECURE_R {
                ETH_PCIE_SECURE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DISABLE_2")
                    .field("hdmi_cec", &format_args!("{}", self.hdmi_cec().bit()))
                    .field("hvs", &format_args!("{}", self.hvs().bit()))
                    .field("rpivid", &format_args!("{}", self.rpivid().bit()))
                    .field("sdc", &format_args!("{}", self.sdc().bit()))
                    .field("dsi_0", &format_args!("{}", self.dsi_0().bit()))
                    .field(
                        "pixel_valve_2",
                        &format_args!("{}", self.pixel_valve_2().bit()),
                    )
                    .field("camera_0", &format_args!("{}", self.camera_0().bit()))
                    .field("camera_1", &format_args!("{}", self.camera_1().bit()))
                    .field("hdmi_0", &format_args!("{}", self.hdmi_0().bit()))
                    .field("hdmi_1", &format_args!("{}", self.hdmi_1().bit()))
                    .field(
                        "pixel_valve_3",
                        &format_args!("{}", self.pixel_valve_3().bit()),
                    )
                    .field(
                        "spi_bsc_slave",
                        &format_args!("{}", self.spi_bsc_slave().bit()),
                    )
                    .field("dsi_1", &format_args!("{}", self.dsi_1().bit()))
                    .field(
                        "pixel_valve_0",
                        &format_args!("{}", self.pixel_valve_0().bit()),
                    )
                    .field(
                        "pixel_valve_1_2",
                        &format_args!("{}", self.pixel_valve_1_2().bit()),
                    )
                    .field("cpr", &format_args!("{}", self.cpr().bit()))
                    .field("smi", &format_args!("{}", self.smi().bit()))
                    .field("gpio_0", &format_args!("{}", self.gpio_0().bit()))
                    .field("gpio_1", &format_args!("{}", self.gpio_1().bit()))
                    .field("gpio_2", &format_args!("{}", self.gpio_2().bit()))
                    .field("gpio_3", &format_args!("{}", self.gpio_3().bit()))
                    .field("i2c", &format_args!("{}", self.i2c().bit()))
                    .field("spi", &format_args!("{}", self.spi().bit()))
                    .field("pcm_i2s", &format_args!("{}", self.pcm_i2s().bit()))
                    .field("sdhost", &format_args!("{}", self.sdhost().bit()))
                    .field("uart", &format_args!("{}", self.uart().bit()))
                    .field("eth_pcie", &format_args!("{}", self.eth_pcie().bit()))
                    .field("vec", &format_args!("{}", self.vec().bit()))
                    .field("cpg", &format_args!("{}", self.cpg().bit()))
                    .field("rng", &format_args!("{}", self.rng().bit()))
                    .field("emmc", &format_args!("{}", self.emmc().bit()))
                    .field(
                        "eth_pcie_secure",
                        &format_args!("{}", self.eth_pcie_secure().bit()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DISABLE_2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - HDMI CEC"]
            #[inline(always)]
            #[must_use]
            pub fn hdmi_cec(&mut self) -> HDMI_CEC_W<DISABLE_2_SPEC, 0> {
                HDMI_CEC_W::new(self)
            }
            #[doc = "Bit 1 - HVS"]
            #[inline(always)]
            #[must_use]
            pub fn hvs(&mut self) -> HVS_W<DISABLE_2_SPEC, 1> {
                HVS_W::new(self)
            }
            #[doc = "Bit 2 - RPIVID"]
            #[inline(always)]
            #[must_use]
            pub fn rpivid(&mut self) -> RPIVID_W<DISABLE_2_SPEC, 2> {
                RPIVID_W::new(self)
            }
            #[doc = "Bit 3 - SDC"]
            #[inline(always)]
            #[must_use]
            pub fn sdc(&mut self) -> SDC_W<DISABLE_2_SPEC, 3> {
                SDC_W::new(self)
            }
            #[doc = "Bit 4 - DSI 0"]
            #[inline(always)]
            #[must_use]
            pub fn dsi_0(&mut self) -> DSI_0_W<DISABLE_2_SPEC, 4> {
                DSI_0_W::new(self)
            }
            #[doc = "Bit 5 - Pixel Valve 2"]
            #[inline(always)]
            #[must_use]
            pub fn pixel_valve_2(&mut self) -> PIXEL_VALVE_2_W<DISABLE_2_SPEC, 5> {
                PIXEL_VALVE_2_W::new(self)
            }
            #[doc = "Bit 6 - Camera 0"]
            #[inline(always)]
            #[must_use]
            pub fn camera_0(&mut self) -> CAMERA_0_W<DISABLE_2_SPEC, 6> {
                CAMERA_0_W::new(self)
            }
            #[doc = "Bit 7 - Camera 1"]
            #[inline(always)]
            #[must_use]
            pub fn camera_1(&mut self) -> CAMERA_1_W<DISABLE_2_SPEC, 7> {
                CAMERA_1_W::new(self)
            }
            #[doc = "Bit 8 - HDMI 0"]
            #[inline(always)]
            #[must_use]
            pub fn hdmi_0(&mut self) -> HDMI_0_W<DISABLE_2_SPEC, 8> {
                HDMI_0_W::new(self)
            }
            #[doc = "Bit 9 - HDMI 1"]
            #[inline(always)]
            #[must_use]
            pub fn hdmi_1(&mut self) -> HDMI_1_W<DISABLE_2_SPEC, 9> {
                HDMI_1_W::new(self)
            }
            #[doc = "Bit 10 - Pixel Valve 3"]
            #[inline(always)]
            #[must_use]
            pub fn pixel_valve_3(&mut self) -> PIXEL_VALVE_3_W<DISABLE_2_SPEC, 10> {
                PIXEL_VALVE_3_W::new(self)
            }
            #[doc = "Bit 11 - SPI/BSC Slave"]
            #[inline(always)]
            #[must_use]
            pub fn spi_bsc_slave(&mut self) -> SPI_BSC_SLAVE_W<DISABLE_2_SPEC, 11> {
                SPI_BSC_SLAVE_W::new(self)
            }
            #[doc = "Bit 12 - DSI 1"]
            #[inline(always)]
            #[must_use]
            pub fn dsi_1(&mut self) -> DSI_1_W<DISABLE_2_SPEC, 12> {
                DSI_1_W::new(self)
            }
            #[doc = "Bit 13 - Pixel Valve 0"]
            #[inline(always)]
            #[must_use]
            pub fn pixel_valve_0(&mut self) -> PIXEL_VALVE_0_W<DISABLE_2_SPEC, 13> {
                PIXEL_VALVE_0_W::new(self)
            }
            #[doc = "Bit 14 - OR of Pixel Valve 1 and 2"]
            #[inline(always)]
            #[must_use]
            pub fn pixel_valve_1_2(&mut self) -> PIXEL_VALVE_1_2_W<DISABLE_2_SPEC, 14> {
                PIXEL_VALVE_1_2_W::new(self)
            }
            #[doc = "Bit 15 - CPR"]
            #[inline(always)]
            #[must_use]
            pub fn cpr(&mut self) -> CPR_W<DISABLE_2_SPEC, 15> {
                CPR_W::new(self)
            }
            #[doc = "Bit 16 - SMI"]
            #[inline(always)]
            #[must_use]
            pub fn smi(&mut self) -> SMI_W<DISABLE_2_SPEC, 16> {
                SMI_W::new(self)
            }
            #[doc = "Bit 17 - GPIO 0"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_0(&mut self) -> GPIO_0_W<DISABLE_2_SPEC, 17> {
                GPIO_0_W::new(self)
            }
            #[doc = "Bit 18 - GPIO 1"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_1(&mut self) -> GPIO_1_W<DISABLE_2_SPEC, 18> {
                GPIO_1_W::new(self)
            }
            #[doc = "Bit 19 - GPIO 2"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_2(&mut self) -> GPIO_2_W<DISABLE_2_SPEC, 19> {
                GPIO_2_W::new(self)
            }
            #[doc = "Bit 20 - GPIO 3"]
            #[inline(always)]
            #[must_use]
            pub fn gpio_3(&mut self) -> GPIO_3_W<DISABLE_2_SPEC, 20> {
                GPIO_3_W::new(self)
            }
            #[doc = "Bit 21 - OR of all I2C"]
            #[inline(always)]
            #[must_use]
            pub fn i2c(&mut self) -> I2C_W<DISABLE_2_SPEC, 21> {
                I2C_W::new(self)
            }
            #[doc = "Bit 22 - OR of all SPI"]
            #[inline(always)]
            #[must_use]
            pub fn spi(&mut self) -> SPI_W<DISABLE_2_SPEC, 22> {
                SPI_W::new(self)
            }
            #[doc = "Bit 23 - PCM/I2S"]
            #[inline(always)]
            #[must_use]
            pub fn pcm_i2s(&mut self) -> PCM_I2S_W<DISABLE_2_SPEC, 23> {
                PCM_I2S_W::new(self)
            }
            #[doc = "Bit 24 - SDHOST"]
            #[inline(always)]
            #[must_use]
            pub fn sdhost(&mut self) -> SDHOST_W<DISABLE_2_SPEC, 24> {
                SDHOST_W::new(self)
            }
            #[doc = "Bit 25 - OR of all PL011 UARTs"]
            #[inline(always)]
            #[must_use]
            pub fn uart(&mut self) -> UART_W<DISABLE_2_SPEC, 25> {
                UART_W::new(self)
            }
            #[doc = "Bit 26 - OR of all ETH_PCIe L2"]
            #[inline(always)]
            #[must_use]
            pub fn eth_pcie(&mut self) -> ETH_PCIE_W<DISABLE_2_SPEC, 26> {
                ETH_PCIE_W::new(self)
            }
            #[doc = "Bit 27 - VEC"]
            #[inline(always)]
            #[must_use]
            pub fn vec(&mut self) -> VEC_W<DISABLE_2_SPEC, 27> {
                VEC_W::new(self)
            }
            #[doc = "Bit 28 - CPG"]
            #[inline(always)]
            #[must_use]
            pub fn cpg(&mut self) -> CPG_W<DISABLE_2_SPEC, 28> {
                CPG_W::new(self)
            }
            #[doc = "Bit 29 - RNG"]
            #[inline(always)]
            #[must_use]
            pub fn rng(&mut self) -> RNG_W<DISABLE_2_SPEC, 29> {
                RNG_W::new(self)
            }
            #[doc = "Bit 30 - OR of EMMC and EMMC2"]
            #[inline(always)]
            #[must_use]
            pub fn emmc(&mut self) -> EMMC_W<DISABLE_2_SPEC, 30> {
                EMMC_W::new(self)
            }
            #[doc = "Bit 31 - ETH_PCIe secure"]
            #[inline(always)]
            #[must_use]
            pub fn eth_pcie_secure(&mut self) -> ETH_PCIE_SECURE_W<DISABLE_2_SPEC, 31> {
                ETH_PCIE_SECURE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Disable interrupts 32 - 63\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`disable_2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`disable_2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DISABLE_2_SPEC;
        impl crate::RegisterSpec for DISABLE_2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`disable_2::R`](R) reader structure"]
        impl crate::Readable for DISABLE_2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`disable_2::W`](W) writer structure"]
        impl crate::Writable for DISABLE_2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xffff_ffff;
        }
        #[doc = "`reset()` method sets DISABLE_2 to value 0"]
        impl crate::Resettable for DISABLE_2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DISABLE_BASIC (rw) register accessor: Disable basic interrupts\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`disable_basic::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`disable_basic::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@disable_basic`]
module"]
    pub type DISABLE_BASIC = crate::Reg<disable_basic::DISABLE_BASIC_SPEC>;
    #[doc = "Disable basic interrupts"]
    pub mod disable_basic {
        #[doc = "Register `DISABLE_BASIC` reader"]
        pub type R = crate::R<DISABLE_BASIC_SPEC>;
        #[doc = "Register `DISABLE_BASIC` writer"]
        pub type W = crate::W<DISABLE_BASIC_SPEC>;
        #[doc = "Field `TIMER` reader - ARMC Timer"]
        pub type TIMER_R = crate::BitReader;
        #[doc = "Field `TIMER` writer - ARMC Timer"]
        pub type TIMER_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `MAILBOX` reader - Mailbox"]
        pub type MAILBOX_R = crate::BitReader;
        #[doc = "Field `MAILBOX` writer - Mailbox"]
        pub type MAILBOX_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DOORBELL0` reader - Doorbell 0"]
        pub type DOORBELL0_R = crate::BitReader;
        #[doc = "Field `DOORBELL0` writer - Doorbell 0"]
        pub type DOORBELL0_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `DOORBELL1` reader - Doorbell 1"]
        pub type DOORBELL1_R = crate::BitReader;
        #[doc = "Field `DOORBELL1` writer - Doorbell 1"]
        pub type DOORBELL1_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `VPU0_HALTED` reader - VPU0 halted"]
        pub type VPU0_HALTED_R = crate::BitReader;
        #[doc = "Field `VPU0_HALTED` writer - VPU0 halted"]
        pub type VPU0_HALTED_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `VPU1_HALTED` reader - VPU1 halted"]
        pub type VPU1_HALTED_R = crate::BitReader;
        #[doc = "Field `VPU1_HALTED` writer - VPU1 halted"]
        pub type VPU1_HALTED_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `ARM_ADDRESS_ERROR` reader - ARM address error"]
        pub type ARM_ADDRESS_ERROR_R = crate::BitReader;
        #[doc = "Field `ARM_ADDRESS_ERROR` writer - ARM address error"]
        pub type ARM_ADDRESS_ERROR_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        #[doc = "Field `ARM_AXI_ERROR` reader - ARM AXI error"]
        pub type ARM_AXI_ERROR_R = crate::BitReader;
        #[doc = "Field `ARM_AXI_ERROR` writer - ARM AXI error"]
        pub type ARM_AXI_ERROR_W<'a, REG, const O: u8> = crate::BitWriter1C<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - ARMC Timer"]
            #[inline(always)]
            pub fn timer(&self) -> TIMER_R {
                TIMER_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Mailbox"]
            #[inline(always)]
            pub fn mailbox(&self) -> MAILBOX_R {
                MAILBOX_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Doorbell 0"]
            #[inline(always)]
            pub fn doorbell0(&self) -> DOORBELL0_R {
                DOORBELL0_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Doorbell 1"]
            #[inline(always)]
            pub fn doorbell1(&self) -> DOORBELL1_R {
                DOORBELL1_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - VPU0 halted"]
            #[inline(always)]
            pub fn vpu0_halted(&self) -> VPU0_HALTED_R {
                VPU0_HALTED_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - VPU1 halted"]
            #[inline(always)]
            pub fn vpu1_halted(&self) -> VPU1_HALTED_R {
                VPU1_HALTED_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - ARM address error"]
            #[inline(always)]
            pub fn arm_address_error(&self) -> ARM_ADDRESS_ERROR_R {
                ARM_ADDRESS_ERROR_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ARM AXI error"]
            #[inline(always)]
            pub fn arm_axi_error(&self) -> ARM_AXI_ERROR_R {
                ARM_AXI_ERROR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DISABLE_BASIC")
                    .field("timer", &format_args!("{}", self.timer().bit()))
                    .field("mailbox", &format_args!("{}", self.mailbox().bit()))
                    .field("doorbell0", &format_args!("{}", self.doorbell0().bit()))
                    .field("doorbell1", &format_args!("{}", self.doorbell1().bit()))
                    .field("vpu0_halted", &format_args!("{}", self.vpu0_halted().bit()))
                    .field("vpu1_halted", &format_args!("{}", self.vpu1_halted().bit()))
                    .field(
                        "arm_address_error",
                        &format_args!("{}", self.arm_address_error().bit()),
                    )
                    .field(
                        "arm_axi_error",
                        &format_args!("{}", self.arm_axi_error().bit()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DISABLE_BASIC_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - ARMC Timer"]
            #[inline(always)]
            #[must_use]
            pub fn timer(&mut self) -> TIMER_W<DISABLE_BASIC_SPEC, 0> {
                TIMER_W::new(self)
            }
            #[doc = "Bit 1 - Mailbox"]
            #[inline(always)]
            #[must_use]
            pub fn mailbox(&mut self) -> MAILBOX_W<DISABLE_BASIC_SPEC, 1> {
                MAILBOX_W::new(self)
            }
            #[doc = "Bit 2 - Doorbell 0"]
            #[inline(always)]
            #[must_use]
            pub fn doorbell0(&mut self) -> DOORBELL0_W<DISABLE_BASIC_SPEC, 2> {
                DOORBELL0_W::new(self)
            }
            #[doc = "Bit 3 - Doorbell 1"]
            #[inline(always)]
            #[must_use]
            pub fn doorbell1(&mut self) -> DOORBELL1_W<DISABLE_BASIC_SPEC, 3> {
                DOORBELL1_W::new(self)
            }
            #[doc = "Bit 4 - VPU0 halted"]
            #[inline(always)]
            #[must_use]
            pub fn vpu0_halted(&mut self) -> VPU0_HALTED_W<DISABLE_BASIC_SPEC, 4> {
                VPU0_HALTED_W::new(self)
            }
            #[doc = "Bit 5 - VPU1 halted"]
            #[inline(always)]
            #[must_use]
            pub fn vpu1_halted(&mut self) -> VPU1_HALTED_W<DISABLE_BASIC_SPEC, 5> {
                VPU1_HALTED_W::new(self)
            }
            #[doc = "Bit 6 - ARM address error"]
            #[inline(always)]
            #[must_use]
            pub fn arm_address_error(&mut self) -> ARM_ADDRESS_ERROR_W<DISABLE_BASIC_SPEC, 6> {
                ARM_ADDRESS_ERROR_W::new(self)
            }
            #[doc = "Bit 7 - ARM AXI error"]
            #[inline(always)]
            #[must_use]
            pub fn arm_axi_error(&mut self) -> ARM_AXI_ERROR_W<DISABLE_BASIC_SPEC, 7> {
                ARM_AXI_ERROR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Disable basic interrupts\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`disable_basic::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`disable_basic::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DISABLE_BASIC_SPEC;
        impl crate::RegisterSpec for DISABLE_BASIC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`disable_basic::R`](R) reader structure"]
        impl crate::Readable for DISABLE_BASIC_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`disable_basic::W`](W) writer structure"]
        impl crate::Writable for DISABLE_BASIC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xff;
        }
        #[doc = "`reset()` method sets DISABLE_BASIC to value 0"]
        impl crate::Resettable for DISABLE_BASIC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "USB on the go high speed"]
pub struct USB_OTG_GLOBAL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB_OTG_GLOBAL {}
impl USB_OTG_GLOBAL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb_otg_global::RegisterBlock = 0x2098_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb_otg_global::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB_OTG_GLOBAL {
    type Target = usb_otg_global::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB_OTG_GLOBAL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB_OTG_GLOBAL").finish()
    }
}
#[doc = "USB on the go high speed"]
pub mod usb_otg_global {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - OTG_HS control and status register"]
        pub gotgctl: GOTGCTL,
        #[doc = "0x04 - OTG_HS interrupt register"]
        pub gotgint: GOTGINT,
        #[doc = "0x08 - OTG_HS AHB configuration register"]
        pub gahbcfg: GAHBCFG,
        #[doc = "0x0c - OTG_HS USB configuration register"]
        pub gusbcfg: GUSBCFG,
        #[doc = "0x10 - OTG_HS reset register"]
        pub grstctl: GRSTCTL,
        #[doc = "0x14 - OTG_HS core interrupt register"]
        pub gintsts: GINTSTS,
        #[doc = "0x18 - OTG_HS interrupt mask register"]
        pub gintmsk: GINTMSK,
        _reserved_7_grxstsr: [u8; 0x04],
        _reserved_8_grxstsp: [u8; 0x04],
        #[doc = "0x24 - OTG_HS Receive FIFO size register"]
        pub grxfsiz: GRXFSIZ,
        _reserved_10_gnptxfsiz_host: [u8; 0x04],
        #[doc = "0x2c - OTG_HS nonperiodic transmit FIFO/queue status register"]
        pub gnptxsts: GNPTXSTS,
        _reserved12: [u8; 0x08],
        #[doc = "0x38 - OTG_HS general core configuration register"]
        pub gccfg: GCCFG,
        #[doc = "0x3c - OTG_HS core ID register"]
        pub cid: CID,
        #[doc = "0x40 - OTG_HS vendor ID register"]
        pub vid: VID,
        #[doc = "0x44 - Direction"]
        pub hw_direction: HW_DIRECTION,
        #[doc = "0x48 - Hardware Config 0"]
        pub hw_config0: HW_CONFIG0,
        _reserved17: [u8; 0xb4],
        #[doc = "0x100 - OTG_HS Host periodic transmit FIFO size register"]
        pub hptxfsiz: HPTXFSIZ,
        #[doc = "0x104 - OTG_HS device IN endpoint transmit FIFO size register"]
        pub dieptxf1: DIEPTXF1,
        #[doc = "0x108 - OTG_HS device IN endpoint transmit FIFO size register"]
        pub dieptxf2: DIEPTXF2,
        _reserved20: [u8; 0x10],
        #[doc = "0x11c - OTG_HS device IN endpoint transmit FIFO size register"]
        pub dieptxf3: DIEPTXF3,
        #[doc = "0x120 - OTG_HS device IN endpoint transmit FIFO size register"]
        pub dieptxf4: DIEPTXF4,
        #[doc = "0x124 - OTG_HS device IN endpoint transmit FIFO size register"]
        pub dieptxf5: DIEPTXF5,
        #[doc = "0x128 - OTG_HS device IN endpoint transmit FIFO size register"]
        pub dieptxf6: DIEPTXF6,
        #[doc = "0x12c - OTG_HS device IN endpoint transmit FIFO size register"]
        pub dieptxf7: DIEPTXF7,
    }
    impl RegisterBlock {
        #[doc = "0x1c - OTG_HS Receive status debug read register (peripheral mode mode)"]
        #[inline(always)]
        pub const fn grxstsr_peripheral(&self) -> &GRXSTSR_PERIPHERAL {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
        #[doc = "0x1c - OTG_HS Receive status debug read register (host mode)"]
        #[inline(always)]
        pub const fn grxstsr_host(&self) -> &GRXSTSR_HOST {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
        #[doc = "0x20 - OTG_HS status read and pop register (peripheral mode)"]
        #[inline(always)]
        pub const fn grxstsp_peripheral(&self) -> &GRXSTSP_PERIPHERAL {
            unsafe { &*(self as *const Self).cast::<u8>().add(32usize).cast() }
        }
        #[doc = "0x20 - OTG_HS status read and pop register (host mode)"]
        #[inline(always)]
        pub const fn grxstsp_host(&self) -> &GRXSTSP_HOST {
            unsafe { &*(self as *const Self).cast::<u8>().add(32usize).cast() }
        }
        #[doc = "0x28 - Endpoint 0 transmit FIFO size (peripheral mode)"]
        #[inline(always)]
        pub const fn tx0fsiz_peripheral(&self) -> &TX0FSIZ_PERIPHERAL {
            unsafe { &*(self as *const Self).cast::<u8>().add(40usize).cast() }
        }
        #[doc = "0x28 - OTG_HS nonperiodic transmit FIFO size register (host mode)"]
        #[inline(always)]
        pub const fn gnptxfsiz_host(&self) -> &GNPTXFSIZ_HOST {
            unsafe { &*(self as *const Self).cast::<u8>().add(40usize).cast() }
        }
    }
    #[doc = "GOTGCTL (rw) register accessor: OTG_HS control and status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gotgctl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gotgctl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gotgctl`]
module"]
    pub type GOTGCTL = crate::Reg<gotgctl::GOTGCTL_SPEC>;
    #[doc = "OTG_HS control and status register"]
    pub mod gotgctl {
        #[doc = "Register `GOTGCTL` reader"]
        pub type R = crate::R<GOTGCTL_SPEC>;
        #[doc = "Register `GOTGCTL` writer"]
        pub type W = crate::W<GOTGCTL_SPEC>;
        #[doc = "Field `SRQSCS` reader - Session request success"]
        pub type SRQSCS_R = crate::BitReader;
        #[doc = "Field `SRQ` reader - Session request"]
        pub type SRQ_R = crate::BitReader;
        #[doc = "Field `SRQ` writer - Session request"]
        pub type SRQ_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HNGSCS` reader - Host negotiation success"]
        pub type HNGSCS_R = crate::BitReader;
        #[doc = "Field `HNPRQ` reader - HNP request"]
        pub type HNPRQ_R = crate::BitReader;
        #[doc = "Field `HNPRQ` writer - HNP request"]
        pub type HNPRQ_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HSHNPEN` reader - Host set HNP enable"]
        pub type HSHNPEN_R = crate::BitReader;
        #[doc = "Field `HSHNPEN` writer - Host set HNP enable"]
        pub type HSHNPEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DHNPEN` reader - Device HNP enabled"]
        pub type DHNPEN_R = crate::BitReader;
        #[doc = "Field `DHNPEN` writer - Device HNP enabled"]
        pub type DHNPEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CIDSTS` reader - Connector ID status"]
        pub type CIDSTS_R = crate::BitReader;
        #[doc = "Field `DBCT` reader - Long/short debounce time"]
        pub type DBCT_R = crate::BitReader;
        #[doc = "Field `ASVLD` reader - A-session valid"]
        pub type ASVLD_R = crate::BitReader;
        #[doc = "Field `BSVLD` reader - B-session valid"]
        pub type BSVLD_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Session request success"]
            #[inline(always)]
            pub fn srqscs(&self) -> SRQSCS_R {
                SRQSCS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Session request"]
            #[inline(always)]
            pub fn srq(&self) -> SRQ_R {
                SRQ_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 8 - Host negotiation success"]
            #[inline(always)]
            pub fn hngscs(&self) -> HNGSCS_R {
                HNGSCS_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - HNP request"]
            #[inline(always)]
            pub fn hnprq(&self) -> HNPRQ_R {
                HNPRQ_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Host set HNP enable"]
            #[inline(always)]
            pub fn hshnpen(&self) -> HSHNPEN_R {
                HSHNPEN_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Device HNP enabled"]
            #[inline(always)]
            pub fn dhnpen(&self) -> DHNPEN_R {
                DHNPEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 16 - Connector ID status"]
            #[inline(always)]
            pub fn cidsts(&self) -> CIDSTS_R {
                CIDSTS_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Long/short debounce time"]
            #[inline(always)]
            pub fn dbct(&self) -> DBCT_R {
                DBCT_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - A-session valid"]
            #[inline(always)]
            pub fn asvld(&self) -> ASVLD_R {
                ASVLD_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - B-session valid"]
            #[inline(always)]
            pub fn bsvld(&self) -> BSVLD_R {
                BSVLD_R::new(((self.bits >> 19) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GOTGCTL")
                    .field("srqscs", &format_args!("{}", self.srqscs().bit()))
                    .field("srq", &format_args!("{}", self.srq().bit()))
                    .field("hngscs", &format_args!("{}", self.hngscs().bit()))
                    .field("hnprq", &format_args!("{}", self.hnprq().bit()))
                    .field("hshnpen", &format_args!("{}", self.hshnpen().bit()))
                    .field("dhnpen", &format_args!("{}", self.dhnpen().bit()))
                    .field("cidsts", &format_args!("{}", self.cidsts().bit()))
                    .field("dbct", &format_args!("{}", self.dbct().bit()))
                    .field("asvld", &format_args!("{}", self.asvld().bit()))
                    .field("bsvld", &format_args!("{}", self.bsvld().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GOTGCTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - Session request"]
            #[inline(always)]
            #[must_use]
            pub fn srq(&mut self) -> SRQ_W<GOTGCTL_SPEC, 1> {
                SRQ_W::new(self)
            }
            #[doc = "Bit 9 - HNP request"]
            #[inline(always)]
            #[must_use]
            pub fn hnprq(&mut self) -> HNPRQ_W<GOTGCTL_SPEC, 9> {
                HNPRQ_W::new(self)
            }
            #[doc = "Bit 10 - Host set HNP enable"]
            #[inline(always)]
            #[must_use]
            pub fn hshnpen(&mut self) -> HSHNPEN_W<GOTGCTL_SPEC, 10> {
                HSHNPEN_W::new(self)
            }
            #[doc = "Bit 11 - Device HNP enabled"]
            #[inline(always)]
            #[must_use]
            pub fn dhnpen(&mut self) -> DHNPEN_W<GOTGCTL_SPEC, 11> {
                DHNPEN_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS control and status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gotgctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gotgctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GOTGCTL_SPEC;
        impl crate::RegisterSpec for GOTGCTL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gotgctl::R`](R) reader structure"]
        impl crate::Readable for GOTGCTL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gotgctl::W`](W) writer structure"]
        impl crate::Writable for GOTGCTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GOTGCTL to value 0x0800"]
        impl crate::Resettable for GOTGCTL_SPEC {
            const RESET_VALUE: Self::Ux = 0x0800;
        }
    }
    #[doc = "GOTGINT (rw) register accessor: OTG_HS interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gotgint::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gotgint::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gotgint`]
module"]
    pub type GOTGINT = crate::Reg<gotgint::GOTGINT_SPEC>;
    #[doc = "OTG_HS interrupt register"]
    pub mod gotgint {
        #[doc = "Register `GOTGINT` reader"]
        pub type R = crate::R<GOTGINT_SPEC>;
        #[doc = "Register `GOTGINT` writer"]
        pub type W = crate::W<GOTGINT_SPEC>;
        #[doc = "Field `SEDET` reader - Session end detected"]
        pub type SEDET_R = crate::BitReader;
        #[doc = "Field `SEDET` writer - Session end detected"]
        pub type SEDET_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SRSSCHG` reader - Session request success status change"]
        pub type SRSSCHG_R = crate::BitReader;
        #[doc = "Field `SRSSCHG` writer - Session request success status change"]
        pub type SRSSCHG_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HNSSCHG` reader - Host negotiation success status change"]
        pub type HNSSCHG_R = crate::BitReader;
        #[doc = "Field `HNSSCHG` writer - Host negotiation success status change"]
        pub type HNSSCHG_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HNGDET` reader - Host negotiation detected"]
        pub type HNGDET_R = crate::BitReader;
        #[doc = "Field `HNGDET` writer - Host negotiation detected"]
        pub type HNGDET_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ADTOCHG` reader - A-device timeout change"]
        pub type ADTOCHG_R = crate::BitReader;
        #[doc = "Field `ADTOCHG` writer - A-device timeout change"]
        pub type ADTOCHG_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DBCDNE` reader - Debounce done"]
        pub type DBCDNE_R = crate::BitReader;
        #[doc = "Field `DBCDNE` writer - Debounce done"]
        pub type DBCDNE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 2 - Session end detected"]
            #[inline(always)]
            pub fn sedet(&self) -> SEDET_R {
                SEDET_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 8 - Session request success status change"]
            #[inline(always)]
            pub fn srsschg(&self) -> SRSSCHG_R {
                SRSSCHG_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Host negotiation success status change"]
            #[inline(always)]
            pub fn hnsschg(&self) -> HNSSCHG_R {
                HNSSCHG_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 17 - Host negotiation detected"]
            #[inline(always)]
            pub fn hngdet(&self) -> HNGDET_R {
                HNGDET_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - A-device timeout change"]
            #[inline(always)]
            pub fn adtochg(&self) -> ADTOCHG_R {
                ADTOCHG_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Debounce done"]
            #[inline(always)]
            pub fn dbcdne(&self) -> DBCDNE_R {
                DBCDNE_R::new(((self.bits >> 19) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GOTGINT")
                    .field("sedet", &format_args!("{}", self.sedet().bit()))
                    .field("srsschg", &format_args!("{}", self.srsschg().bit()))
                    .field("hnsschg", &format_args!("{}", self.hnsschg().bit()))
                    .field("hngdet", &format_args!("{}", self.hngdet().bit()))
                    .field("adtochg", &format_args!("{}", self.adtochg().bit()))
                    .field("dbcdne", &format_args!("{}", self.dbcdne().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GOTGINT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 2 - Session end detected"]
            #[inline(always)]
            #[must_use]
            pub fn sedet(&mut self) -> SEDET_W<GOTGINT_SPEC, 2> {
                SEDET_W::new(self)
            }
            #[doc = "Bit 8 - Session request success status change"]
            #[inline(always)]
            #[must_use]
            pub fn srsschg(&mut self) -> SRSSCHG_W<GOTGINT_SPEC, 8> {
                SRSSCHG_W::new(self)
            }
            #[doc = "Bit 9 - Host negotiation success status change"]
            #[inline(always)]
            #[must_use]
            pub fn hnsschg(&mut self) -> HNSSCHG_W<GOTGINT_SPEC, 9> {
                HNSSCHG_W::new(self)
            }
            #[doc = "Bit 17 - Host negotiation detected"]
            #[inline(always)]
            #[must_use]
            pub fn hngdet(&mut self) -> HNGDET_W<GOTGINT_SPEC, 17> {
                HNGDET_W::new(self)
            }
            #[doc = "Bit 18 - A-device timeout change"]
            #[inline(always)]
            #[must_use]
            pub fn adtochg(&mut self) -> ADTOCHG_W<GOTGINT_SPEC, 18> {
                ADTOCHG_W::new(self)
            }
            #[doc = "Bit 19 - Debounce done"]
            #[inline(always)]
            #[must_use]
            pub fn dbcdne(&mut self) -> DBCDNE_W<GOTGINT_SPEC, 19> {
                DBCDNE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gotgint::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gotgint::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GOTGINT_SPEC;
        impl crate::RegisterSpec for GOTGINT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gotgint::R`](R) reader structure"]
        impl crate::Readable for GOTGINT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gotgint::W`](W) writer structure"]
        impl crate::Writable for GOTGINT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GOTGINT to value 0"]
        impl crate::Resettable for GOTGINT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "GAHBCFG (rw) register accessor: OTG_HS AHB configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gahbcfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gahbcfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gahbcfg`]
module"]
    pub type GAHBCFG = crate::Reg<gahbcfg::GAHBCFG_SPEC>;
    #[doc = "OTG_HS AHB configuration register"]
    pub mod gahbcfg {
        #[doc = "Register `GAHBCFG` reader"]
        pub type R = crate::R<GAHBCFG_SPEC>;
        #[doc = "Register `GAHBCFG` writer"]
        pub type W = crate::W<GAHBCFG_SPEC>;
        #[doc = "Field `GINT` reader - Global interrupt mask"]
        pub type GINT_R = crate::BitReader;
        #[doc = "Field `GINT` writer - Global interrupt mask"]
        pub type GINT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `AXI_BURST` reader - Maximum AXI burst length"]
        pub type AXI_BURST_R = crate::FieldReader<BURST_A>;
        #[doc = "Maximum AXI burst length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum BURST_A {
            #[doc = "0: `0`"]
            _4 = 0,
            #[doc = "1: `1`"]
            _3 = 1,
            #[doc = "2: `10`"]
            _2 = 2,
            #[doc = "3: `11`"]
            _1 = 3,
        }
        impl From<BURST_A> for u8 {
            #[inline(always)]
            fn from(variant: BURST_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for BURST_A {
            type Ux = u8;
        }
        impl AXI_BURST_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BURST_A {
                match self.bits {
                    0 => BURST_A::_4,
                    1 => BURST_A::_3,
                    2 => BURST_A::_2,
                    3 => BURST_A::_1,
                    _ => unreachable!(),
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_4(&self) -> bool {
                *self == BURST_A::_4
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_3(&self) -> bool {
                *self == BURST_A::_3
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_2(&self) -> bool {
                *self == BURST_A::_2
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_1(&self) -> bool {
                *self == BURST_A::_1
            }
        }
        #[doc = "Field `AXI_BURST` writer - Maximum AXI burst length"]
        pub type AXI_BURST_W<'a, REG, const O: u8> = crate::FieldWriterSafe<'a, REG, 2, O, BURST_A>;
        impl<'a, REG, const O: u8> AXI_BURST_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn _4(self) -> &'a mut crate::W<REG> {
                self.variant(BURST_A::_4)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn _3(self) -> &'a mut crate::W<REG> {
                self.variant(BURST_A::_3)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn _2(self) -> &'a mut crate::W<REG> {
                self.variant(BURST_A::_2)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn _1(self) -> &'a mut crate::W<REG> {
                self.variant(BURST_A::_1)
            }
        }
        #[doc = "Field `AXI_WAIT` reader - Wait for all AXI writes before signaling DMA"]
        pub type AXI_WAIT_R = crate::BitReader;
        #[doc = "Field `AXI_WAIT` writer - Wait for all AXI writes before signaling DMA"]
        pub type AXI_WAIT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DMAEN` reader - DMA enable"]
        pub type DMAEN_R = crate::BitReader;
        #[doc = "Field `DMAEN` writer - DMA enable"]
        pub type DMAEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXFELVL` reader - TxFIFO empty level"]
        pub type TXFELVL_R = crate::BitReader;
        #[doc = "Field `TXFELVL` writer - TxFIFO empty level"]
        pub type TXFELVL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PTXFELVL` reader - Periodic TxFIFO empty level"]
        pub type PTXFELVL_R = crate::BitReader;
        #[doc = "Field `PTXFELVL` writer - Periodic TxFIFO empty level"]
        pub type PTXFELVL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Global interrupt mask"]
            #[inline(always)]
            pub fn gint(&self) -> GINT_R {
                GINT_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:2 - Maximum AXI burst length"]
            #[inline(always)]
            pub fn axi_burst(&self) -> AXI_BURST_R {
                AXI_BURST_R::new(((self.bits >> 1) & 3) as u8)
            }
            #[doc = "Bit 4 - Wait for all AXI writes before signaling DMA"]
            #[inline(always)]
            pub fn axi_wait(&self) -> AXI_WAIT_R {
                AXI_WAIT_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DMA enable"]
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 7 - TxFIFO empty level"]
            #[inline(always)]
            pub fn txfelvl(&self) -> TXFELVL_R {
                TXFELVL_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Periodic TxFIFO empty level"]
            #[inline(always)]
            pub fn ptxfelvl(&self) -> PTXFELVL_R {
                PTXFELVL_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GAHBCFG")
                    .field("gint", &format_args!("{}", self.gint().bit()))
                    .field("axi_wait", &format_args!("{}", self.axi_wait().bit()))
                    .field("axi_burst", &format_args!("{}", self.axi_burst().bits()))
                    .field("dmaen", &format_args!("{}", self.dmaen().bit()))
                    .field("txfelvl", &format_args!("{}", self.txfelvl().bit()))
                    .field("ptxfelvl", &format_args!("{}", self.ptxfelvl().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GAHBCFG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Global interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn gint(&mut self) -> GINT_W<GAHBCFG_SPEC, 0> {
                GINT_W::new(self)
            }
            #[doc = "Bits 1:2 - Maximum AXI burst length"]
            #[inline(always)]
            #[must_use]
            pub fn axi_burst(&mut self) -> AXI_BURST_W<GAHBCFG_SPEC, 1> {
                AXI_BURST_W::new(self)
            }
            #[doc = "Bit 4 - Wait for all AXI writes before signaling DMA"]
            #[inline(always)]
            #[must_use]
            pub fn axi_wait(&mut self) -> AXI_WAIT_W<GAHBCFG_SPEC, 4> {
                AXI_WAIT_W::new(self)
            }
            #[doc = "Bit 5 - DMA enable"]
            #[inline(always)]
            #[must_use]
            pub fn dmaen(&mut self) -> DMAEN_W<GAHBCFG_SPEC, 5> {
                DMAEN_W::new(self)
            }
            #[doc = "Bit 7 - TxFIFO empty level"]
            #[inline(always)]
            #[must_use]
            pub fn txfelvl(&mut self) -> TXFELVL_W<GAHBCFG_SPEC, 7> {
                TXFELVL_W::new(self)
            }
            #[doc = "Bit 8 - Periodic TxFIFO empty level"]
            #[inline(always)]
            #[must_use]
            pub fn ptxfelvl(&mut self) -> PTXFELVL_W<GAHBCFG_SPEC, 8> {
                PTXFELVL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS AHB configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gahbcfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gahbcfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GAHBCFG_SPEC;
        impl crate::RegisterSpec for GAHBCFG_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gahbcfg::R`](R) reader structure"]
        impl crate::Readable for GAHBCFG_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gahbcfg::W`](W) writer structure"]
        impl crate::Writable for GAHBCFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GAHBCFG to value 0"]
        impl crate::Resettable for GAHBCFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "GUSBCFG (rw) register accessor: OTG_HS USB configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gusbcfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gusbcfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gusbcfg`]
module"]
    pub type GUSBCFG = crate::Reg<gusbcfg::GUSBCFG_SPEC>;
    #[doc = "OTG_HS USB configuration register"]
    pub mod gusbcfg {
        #[doc = "Register `GUSBCFG` reader"]
        pub type R = crate::R<GUSBCFG_SPEC>;
        #[doc = "Register `GUSBCFG` writer"]
        pub type W = crate::W<GUSBCFG_SPEC>;
        #[doc = "Field `TOCAL` reader - FS timeout calibration"]
        pub type TOCAL_R = crate::FieldReader;
        #[doc = "Field `TOCAL` writer - FS timeout calibration"]
        pub type TOCAL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O>;
        #[doc = "Field `PHYIF` reader - PHY Interface width"]
        pub type PHYIF_R = crate::BitReader<PHYIF_A>;
        #[doc = "PHY Interface width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PHYIF_A {
            #[doc = "0: `0`"]
            _8BIT = 0,
            #[doc = "1: `1`"]
            _16BIT = 1,
        }
        impl From<PHYIF_A> for bool {
            #[inline(always)]
            fn from(variant: PHYIF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PHYIF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PHYIF_A {
                match self.bits {
                    false => PHYIF_A::_8BIT,
                    true => PHYIF_A::_16BIT,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_8bit(&self) -> bool {
                *self == PHYIF_A::_8BIT
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_16bit(&self) -> bool {
                *self == PHYIF_A::_16BIT
            }
        }
        #[doc = "Field `PHYIF` writer - PHY Interface width"]
        pub type PHYIF_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, PHYIF_A>;
        impl<'a, REG, const O: u8> PHYIF_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn _8bit(self) -> &'a mut crate::W<REG> {
                self.variant(PHYIF_A::_8BIT)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn _16bit(self) -> &'a mut crate::W<REG> {
                self.variant(PHYIF_A::_16BIT)
            }
        }
        #[doc = "Field `PHYTYPE` reader - PHY Type"]
        pub type PHYTYPE_R = crate::BitReader<PHYTYPE_A>;
        #[doc = "PHY Type\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PHYTYPE_A {
            #[doc = "0: `0`"]
            UTMI = 0,
            #[doc = "1: `1`"]
            ULPI = 1,
        }
        impl From<PHYTYPE_A> for bool {
            #[inline(always)]
            fn from(variant: PHYTYPE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PHYTYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PHYTYPE_A {
                match self.bits {
                    false => PHYTYPE_A::UTMI,
                    true => PHYTYPE_A::ULPI,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_utmi(&self) -> bool {
                *self == PHYTYPE_A::UTMI
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_ulpi(&self) -> bool {
                *self == PHYTYPE_A::ULPI
            }
        }
        #[doc = "Field `PHYTYPE` writer - PHY Type"]
        pub type PHYTYPE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, PHYTYPE_A>;
        impl<'a, REG, const O: u8> PHYTYPE_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn utmi(self) -> &'a mut crate::W<REG> {
                self.variant(PHYTYPE_A::UTMI)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ulpi(self) -> &'a mut crate::W<REG> {
                self.variant(PHYTYPE_A::ULPI)
            }
        }
        #[doc = "Field `FSIF` reader - Full speed interface"]
        pub type FSIF_R = crate::BitReader<FSIF_A>;
        #[doc = "Full speed interface\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FSIF_A {
            #[doc = "0: `0`"]
            _6PIN = 0,
            #[doc = "1: `1`"]
            _3PIN = 1,
        }
        impl From<FSIF_A> for bool {
            #[inline(always)]
            fn from(variant: FSIF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl FSIF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSIF_A {
                match self.bits {
                    false => FSIF_A::_6PIN,
                    true => FSIF_A::_3PIN,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_6pin(&self) -> bool {
                *self == FSIF_A::_6PIN
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_3pin(&self) -> bool {
                *self == FSIF_A::_3PIN
            }
        }
        #[doc = "Field `FSIF` writer - Full speed interface"]
        pub type FSIF_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, FSIF_A>;
        impl<'a, REG, const O: u8> FSIF_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn _6pin(self) -> &'a mut crate::W<REG> {
                self.variant(FSIF_A::_6PIN)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn _3pin(self) -> &'a mut crate::W<REG> {
                self.variant(FSIF_A::_3PIN)
            }
        }
        #[doc = "Field `PHYSEL` reader - Transceiver select"]
        pub type PHYSEL_R = crate::BitReader<PHYSEL_A>;
        #[doc = "Transceiver select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PHYSEL_A {
            #[doc = "0: `0`"]
            USB20 = 0,
            #[doc = "1: `1`"]
            USB11 = 1,
        }
        impl From<PHYSEL_A> for bool {
            #[inline(always)]
            fn from(variant: PHYSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PHYSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PHYSEL_A {
                match self.bits {
                    false => PHYSEL_A::USB20,
                    true => PHYSEL_A::USB11,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_usb20(&self) -> bool {
                *self == PHYSEL_A::USB20
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_usb11(&self) -> bool {
                *self == PHYSEL_A::USB11
            }
        }
        #[doc = "Field `PHYSEL` writer - Transceiver select"]
        pub type PHYSEL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, PHYSEL_A>;
        impl<'a, REG, const O: u8> PHYSEL_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn usb20(self) -> &'a mut crate::W<REG> {
                self.variant(PHYSEL_A::USB20)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn usb11(self) -> &'a mut crate::W<REG> {
                self.variant(PHYSEL_A::USB11)
            }
        }
        #[doc = "Field `DDRSEL` reader - ULPI data rate"]
        pub type DDRSEL_R = crate::BitReader<DDRSEL_A>;
        #[doc = "ULPI data rate\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DDRSEL_A {
            #[doc = "0: `0`"]
            SINGLE = 0,
            #[doc = "1: `1`"]
            DOUBLE = 1,
        }
        impl From<DDRSEL_A> for bool {
            #[inline(always)]
            fn from(variant: DDRSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DDRSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DDRSEL_A {
                match self.bits {
                    false => DDRSEL_A::SINGLE,
                    true => DDRSEL_A::DOUBLE,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == DDRSEL_A::SINGLE
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_double(&self) -> bool {
                *self == DDRSEL_A::DOUBLE
            }
        }
        #[doc = "Field `DDRSEL` writer - ULPI data rate"]
        pub type DDRSEL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, DDRSEL_A>;
        impl<'a, REG, const O: u8> DDRSEL_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn single(self) -> &'a mut crate::W<REG> {
                self.variant(DDRSEL_A::SINGLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn double(self) -> &'a mut crate::W<REG> {
                self.variant(DDRSEL_A::DOUBLE)
            }
        }
        #[doc = "Field `SRPCAP` reader - SRP-capable"]
        pub type SRPCAP_R = crate::BitReader;
        #[doc = "Field `SRPCAP` writer - SRP-capable"]
        pub type SRPCAP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HNPCAP` reader - HNP-capable"]
        pub type HNPCAP_R = crate::BitReader;
        #[doc = "Field `HNPCAP` writer - HNP-capable"]
        pub type HNPCAP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TRDT` reader - USB turnaround time"]
        pub type TRDT_R = crate::FieldReader;
        #[doc = "Field `TRDT` writer - USB turnaround time"]
        pub type TRDT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        #[doc = "Field `PHYLPCS` reader - PHY Low-power clock select"]
        pub type PHYLPCS_R = crate::BitReader;
        #[doc = "Field `PHYLPCS` writer - PHY Low-power clock select"]
        pub type PHYLPCS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ULPIFSLS` reader - ULPI FS/LS select"]
        pub type ULPIFSLS_R = crate::BitReader;
        #[doc = "Field `ULPIFSLS` writer - ULPI FS/LS select"]
        pub type ULPIFSLS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ULPIAR` reader - ULPI Auto-resume"]
        pub type ULPIAR_R = crate::BitReader;
        #[doc = "Field `ULPIAR` writer - ULPI Auto-resume"]
        pub type ULPIAR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ULPICSM` reader - ULPI Clock SuspendM"]
        pub type ULPICSM_R = crate::BitReader;
        #[doc = "Field `ULPICSM` writer - ULPI Clock SuspendM"]
        pub type ULPICSM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ULPIEVBUSD` reader - ULPI External VBUS Drive"]
        pub type ULPIEVBUSD_R = crate::BitReader;
        #[doc = "Field `ULPIEVBUSD` writer - ULPI External VBUS Drive"]
        pub type ULPIEVBUSD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ULPIEVBUSI` reader - ULPI external VBUS indicator"]
        pub type ULPIEVBUSI_R = crate::BitReader;
        #[doc = "Field `ULPIEVBUSI` writer - ULPI external VBUS indicator"]
        pub type ULPIEVBUSI_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TSDPS` reader - TermSel DLine pulsing selection"]
        pub type TSDPS_R = crate::BitReader;
        #[doc = "Field `TSDPS` writer - TermSel DLine pulsing selection"]
        pub type TSDPS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PCCI` reader - Indicator complement"]
        pub type PCCI_R = crate::BitReader;
        #[doc = "Field `PCCI` writer - Indicator complement"]
        pub type PCCI_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PTCI` reader - Indicator pass through"]
        pub type PTCI_R = crate::BitReader;
        #[doc = "Field `PTCI` writer - Indicator pass through"]
        pub type PTCI_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ULPIIPD` reader - ULPI interface protect disable"]
        pub type ULPIIPD_R = crate::BitReader;
        #[doc = "Field `ULPIIPD` writer - ULPI interface protect disable"]
        pub type ULPIIPD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FHMOD` reader - Forced host mode"]
        pub type FHMOD_R = crate::BitReader;
        #[doc = "Field `FHMOD` writer - Forced host mode"]
        pub type FHMOD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FDMOD` reader - Forced peripheral mode"]
        pub type FDMOD_R = crate::BitReader;
        #[doc = "Field `FDMOD` writer - Forced peripheral mode"]
        pub type FDMOD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTXPKT` reader - Corrupt Tx packet"]
        pub type CTXPKT_R = crate::BitReader;
        #[doc = "Field `CTXPKT` writer - Corrupt Tx packet"]
        pub type CTXPKT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bits 0:2 - FS timeout calibration"]
            #[inline(always)]
            pub fn tocal(&self) -> TOCAL_R {
                TOCAL_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bit 3 - PHY Interface width"]
            #[inline(always)]
            pub fn phyif(&self) -> PHYIF_R {
                PHYIF_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - PHY Type"]
            #[inline(always)]
            pub fn phytype(&self) -> PHYTYPE_R {
                PHYTYPE_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Full speed interface"]
            #[inline(always)]
            pub fn fsif(&self) -> FSIF_R {
                FSIF_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Transceiver select"]
            #[inline(always)]
            pub fn physel(&self) -> PHYSEL_R {
                PHYSEL_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ULPI data rate"]
            #[inline(always)]
            pub fn ddrsel(&self) -> DDRSEL_R {
                DDRSEL_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - SRP-capable"]
            #[inline(always)]
            pub fn srpcap(&self) -> SRPCAP_R {
                SRPCAP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - HNP-capable"]
            #[inline(always)]
            pub fn hnpcap(&self) -> HNPCAP_R {
                HNPCAP_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bits 10:13 - USB turnaround time"]
            #[inline(always)]
            pub fn trdt(&self) -> TRDT_R {
                TRDT_R::new(((self.bits >> 10) & 0x0f) as u8)
            }
            #[doc = "Bit 15 - PHY Low-power clock select"]
            #[inline(always)]
            pub fn phylpcs(&self) -> PHYLPCS_R {
                PHYLPCS_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 17 - ULPI FS/LS select"]
            #[inline(always)]
            pub fn ulpifsls(&self) -> ULPIFSLS_R {
                ULPIFSLS_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - ULPI Auto-resume"]
            #[inline(always)]
            pub fn ulpiar(&self) -> ULPIAR_R {
                ULPIAR_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - ULPI Clock SuspendM"]
            #[inline(always)]
            pub fn ulpicsm(&self) -> ULPICSM_R {
                ULPICSM_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - ULPI External VBUS Drive"]
            #[inline(always)]
            pub fn ulpievbusd(&self) -> ULPIEVBUSD_R {
                ULPIEVBUSD_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - ULPI external VBUS indicator"]
            #[inline(always)]
            pub fn ulpievbusi(&self) -> ULPIEVBUSI_R {
                ULPIEVBUSI_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - TermSel DLine pulsing selection"]
            #[inline(always)]
            pub fn tsdps(&self) -> TSDPS_R {
                TSDPS_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Indicator complement"]
            #[inline(always)]
            pub fn pcci(&self) -> PCCI_R {
                PCCI_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Indicator pass through"]
            #[inline(always)]
            pub fn ptci(&self) -> PTCI_R {
                PTCI_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - ULPI interface protect disable"]
            #[inline(always)]
            pub fn ulpiipd(&self) -> ULPIIPD_R {
                ULPIIPD_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 29 - Forced host mode"]
            #[inline(always)]
            pub fn fhmod(&self) -> FHMOD_R {
                FHMOD_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Forced peripheral mode"]
            #[inline(always)]
            pub fn fdmod(&self) -> FDMOD_R {
                FDMOD_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Corrupt Tx packet"]
            #[inline(always)]
            pub fn ctxpkt(&self) -> CTXPKT_R {
                CTXPKT_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GUSBCFG")
                    .field("tocal", &format_args!("{}", self.tocal().bits()))
                    .field("phyif", &format_args!("{}", self.phyif().bit()))
                    .field("phytype", &format_args!("{}", self.phytype().bit()))
                    .field("fsif", &format_args!("{}", self.fsif().bit()))
                    .field("physel", &format_args!("{}", self.physel().bit()))
                    .field("ddrsel", &format_args!("{}", self.ddrsel().bit()))
                    .field("srpcap", &format_args!("{}", self.srpcap().bit()))
                    .field("hnpcap", &format_args!("{}", self.hnpcap().bit()))
                    .field("trdt", &format_args!("{}", self.trdt().bits()))
                    .field("phylpcs", &format_args!("{}", self.phylpcs().bit()))
                    .field("ulpifsls", &format_args!("{}", self.ulpifsls().bit()))
                    .field("ulpiar", &format_args!("{}", self.ulpiar().bit()))
                    .field("ulpicsm", &format_args!("{}", self.ulpicsm().bit()))
                    .field("ulpievbusd", &format_args!("{}", self.ulpievbusd().bit()))
                    .field("ulpievbusi", &format_args!("{}", self.ulpievbusi().bit()))
                    .field("tsdps", &format_args!("{}", self.tsdps().bit()))
                    .field("pcci", &format_args!("{}", self.pcci().bit()))
                    .field("ptci", &format_args!("{}", self.ptci().bit()))
                    .field("ulpiipd", &format_args!("{}", self.ulpiipd().bit()))
                    .field("fhmod", &format_args!("{}", self.fhmod().bit()))
                    .field("fdmod", &format_args!("{}", self.fdmod().bit()))
                    .field("ctxpkt", &format_args!("{}", self.ctxpkt().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GUSBCFG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - FS timeout calibration"]
            #[inline(always)]
            #[must_use]
            pub fn tocal(&mut self) -> TOCAL_W<GUSBCFG_SPEC, 0> {
                TOCAL_W::new(self)
            }
            #[doc = "Bit 3 - PHY Interface width"]
            #[inline(always)]
            #[must_use]
            pub fn phyif(&mut self) -> PHYIF_W<GUSBCFG_SPEC, 3> {
                PHYIF_W::new(self)
            }
            #[doc = "Bit 4 - PHY Type"]
            #[inline(always)]
            #[must_use]
            pub fn phytype(&mut self) -> PHYTYPE_W<GUSBCFG_SPEC, 4> {
                PHYTYPE_W::new(self)
            }
            #[doc = "Bit 5 - Full speed interface"]
            #[inline(always)]
            #[must_use]
            pub fn fsif(&mut self) -> FSIF_W<GUSBCFG_SPEC, 5> {
                FSIF_W::new(self)
            }
            #[doc = "Bit 6 - Transceiver select"]
            #[inline(always)]
            #[must_use]
            pub fn physel(&mut self) -> PHYSEL_W<GUSBCFG_SPEC, 6> {
                PHYSEL_W::new(self)
            }
            #[doc = "Bit 7 - ULPI data rate"]
            #[inline(always)]
            #[must_use]
            pub fn ddrsel(&mut self) -> DDRSEL_W<GUSBCFG_SPEC, 7> {
                DDRSEL_W::new(self)
            }
            #[doc = "Bit 8 - SRP-capable"]
            #[inline(always)]
            #[must_use]
            pub fn srpcap(&mut self) -> SRPCAP_W<GUSBCFG_SPEC, 8> {
                SRPCAP_W::new(self)
            }
            #[doc = "Bit 9 - HNP-capable"]
            #[inline(always)]
            #[must_use]
            pub fn hnpcap(&mut self) -> HNPCAP_W<GUSBCFG_SPEC, 9> {
                HNPCAP_W::new(self)
            }
            #[doc = "Bits 10:13 - USB turnaround time"]
            #[inline(always)]
            #[must_use]
            pub fn trdt(&mut self) -> TRDT_W<GUSBCFG_SPEC, 10> {
                TRDT_W::new(self)
            }
            #[doc = "Bit 15 - PHY Low-power clock select"]
            #[inline(always)]
            #[must_use]
            pub fn phylpcs(&mut self) -> PHYLPCS_W<GUSBCFG_SPEC, 15> {
                PHYLPCS_W::new(self)
            }
            #[doc = "Bit 17 - ULPI FS/LS select"]
            #[inline(always)]
            #[must_use]
            pub fn ulpifsls(&mut self) -> ULPIFSLS_W<GUSBCFG_SPEC, 17> {
                ULPIFSLS_W::new(self)
            }
            #[doc = "Bit 18 - ULPI Auto-resume"]
            #[inline(always)]
            #[must_use]
            pub fn ulpiar(&mut self) -> ULPIAR_W<GUSBCFG_SPEC, 18> {
                ULPIAR_W::new(self)
            }
            #[doc = "Bit 19 - ULPI Clock SuspendM"]
            #[inline(always)]
            #[must_use]
            pub fn ulpicsm(&mut self) -> ULPICSM_W<GUSBCFG_SPEC, 19> {
                ULPICSM_W::new(self)
            }
            #[doc = "Bit 20 - ULPI External VBUS Drive"]
            #[inline(always)]
            #[must_use]
            pub fn ulpievbusd(&mut self) -> ULPIEVBUSD_W<GUSBCFG_SPEC, 20> {
                ULPIEVBUSD_W::new(self)
            }
            #[doc = "Bit 21 - ULPI external VBUS indicator"]
            #[inline(always)]
            #[must_use]
            pub fn ulpievbusi(&mut self) -> ULPIEVBUSI_W<GUSBCFG_SPEC, 21> {
                ULPIEVBUSI_W::new(self)
            }
            #[doc = "Bit 22 - TermSel DLine pulsing selection"]
            #[inline(always)]
            #[must_use]
            pub fn tsdps(&mut self) -> TSDPS_W<GUSBCFG_SPEC, 22> {
                TSDPS_W::new(self)
            }
            #[doc = "Bit 23 - Indicator complement"]
            #[inline(always)]
            #[must_use]
            pub fn pcci(&mut self) -> PCCI_W<GUSBCFG_SPEC, 23> {
                PCCI_W::new(self)
            }
            #[doc = "Bit 24 - Indicator pass through"]
            #[inline(always)]
            #[must_use]
            pub fn ptci(&mut self) -> PTCI_W<GUSBCFG_SPEC, 24> {
                PTCI_W::new(self)
            }
            #[doc = "Bit 25 - ULPI interface protect disable"]
            #[inline(always)]
            #[must_use]
            pub fn ulpiipd(&mut self) -> ULPIIPD_W<GUSBCFG_SPEC, 25> {
                ULPIIPD_W::new(self)
            }
            #[doc = "Bit 29 - Forced host mode"]
            #[inline(always)]
            #[must_use]
            pub fn fhmod(&mut self) -> FHMOD_W<GUSBCFG_SPEC, 29> {
                FHMOD_W::new(self)
            }
            #[doc = "Bit 30 - Forced peripheral mode"]
            #[inline(always)]
            #[must_use]
            pub fn fdmod(&mut self) -> FDMOD_W<GUSBCFG_SPEC, 30> {
                FDMOD_W::new(self)
            }
            #[doc = "Bit 31 - Corrupt Tx packet"]
            #[inline(always)]
            #[must_use]
            pub fn ctxpkt(&mut self) -> CTXPKT_W<GUSBCFG_SPEC, 31> {
                CTXPKT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS USB configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gusbcfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gusbcfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GUSBCFG_SPEC;
        impl crate::RegisterSpec for GUSBCFG_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gusbcfg::R`](R) reader structure"]
        impl crate::Readable for GUSBCFG_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gusbcfg::W`](W) writer structure"]
        impl crate::Writable for GUSBCFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GUSBCFG to value 0x0a00"]
        impl crate::Resettable for GUSBCFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x0a00;
        }
    }
    #[doc = "GRSTCTL (rw) register accessor: OTG_HS reset register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grstctl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`grstctl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@grstctl`]
module"]
    pub type GRSTCTL = crate::Reg<grstctl::GRSTCTL_SPEC>;
    #[doc = "OTG_HS reset register"]
    pub mod grstctl {
        #[doc = "Register `GRSTCTL` reader"]
        pub type R = crate::R<GRSTCTL_SPEC>;
        #[doc = "Register `GRSTCTL` writer"]
        pub type W = crate::W<GRSTCTL_SPEC>;
        #[doc = "Field `CSRST` reader - Core soft reset"]
        pub type CSRST_R = crate::BitReader;
        #[doc = "Field `CSRST` writer - Core soft reset"]
        pub type CSRST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HSRST` reader - HCLK soft reset"]
        pub type HSRST_R = crate::BitReader;
        #[doc = "Field `HSRST` writer - HCLK soft reset"]
        pub type HSRST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FCRST` reader - Host frame counter reset"]
        pub type FCRST_R = crate::BitReader;
        #[doc = "Field `FCRST` writer - Host frame counter reset"]
        pub type FCRST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXFFLSH` reader - RxFIFO flush"]
        pub type RXFFLSH_R = crate::BitReader;
        #[doc = "Field `RXFFLSH` writer - RxFIFO flush"]
        pub type RXFFLSH_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXFFLSH` reader - TxFIFO flush"]
        pub type TXFFLSH_R = crate::BitReader;
        #[doc = "Field `TXFFLSH` writer - TxFIFO flush"]
        pub type TXFFLSH_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXFNUM` reader - TxFIFO number"]
        pub type TXFNUM_R = crate::FieldReader;
        #[doc = "Field `TXFNUM` writer - TxFIFO number"]
        pub type TXFNUM_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 5, O>;
        #[doc = "Field `DMAREQ` reader - DMA request signal"]
        pub type DMAREQ_R = crate::BitReader;
        #[doc = "Field `AHBIDL` reader - AHB master idle"]
        pub type AHBIDL_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Core soft reset"]
            #[inline(always)]
            pub fn csrst(&self) -> CSRST_R {
                CSRST_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - HCLK soft reset"]
            #[inline(always)]
            pub fn hsrst(&self) -> HSRST_R {
                HSRST_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Host frame counter reset"]
            #[inline(always)]
            pub fn fcrst(&self) -> FCRST_R {
                FCRST_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - RxFIFO flush"]
            #[inline(always)]
            pub fn rxfflsh(&self) -> RXFFLSH_R {
                RXFFLSH_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TxFIFO flush"]
            #[inline(always)]
            pub fn txfflsh(&self) -> TXFFLSH_R {
                TXFFLSH_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bits 6:10 - TxFIFO number"]
            #[inline(always)]
            pub fn txfnum(&self) -> TXFNUM_R {
                TXFNUM_R::new(((self.bits >> 6) & 0x1f) as u8)
            }
            #[doc = "Bit 30 - DMA request signal"]
            #[inline(always)]
            pub fn dmareq(&self) -> DMAREQ_R {
                DMAREQ_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - AHB master idle"]
            #[inline(always)]
            pub fn ahbidl(&self) -> AHBIDL_R {
                AHBIDL_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GRSTCTL")
                    .field("csrst", &format_args!("{}", self.csrst().bit()))
                    .field("hsrst", &format_args!("{}", self.hsrst().bit()))
                    .field("fcrst", &format_args!("{}", self.fcrst().bit()))
                    .field("rxfflsh", &format_args!("{}", self.rxfflsh().bit()))
                    .field("txfflsh", &format_args!("{}", self.txfflsh().bit()))
                    .field("txfnum", &format_args!("{}", self.txfnum().bits()))
                    .field("dmareq", &format_args!("{}", self.dmareq().bit()))
                    .field("ahbidl", &format_args!("{}", self.ahbidl().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GRSTCTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Core soft reset"]
            #[inline(always)]
            #[must_use]
            pub fn csrst(&mut self) -> CSRST_W<GRSTCTL_SPEC, 0> {
                CSRST_W::new(self)
            }
            #[doc = "Bit 1 - HCLK soft reset"]
            #[inline(always)]
            #[must_use]
            pub fn hsrst(&mut self) -> HSRST_W<GRSTCTL_SPEC, 1> {
                HSRST_W::new(self)
            }
            #[doc = "Bit 2 - Host frame counter reset"]
            #[inline(always)]
            #[must_use]
            pub fn fcrst(&mut self) -> FCRST_W<GRSTCTL_SPEC, 2> {
                FCRST_W::new(self)
            }
            #[doc = "Bit 4 - RxFIFO flush"]
            #[inline(always)]
            #[must_use]
            pub fn rxfflsh(&mut self) -> RXFFLSH_W<GRSTCTL_SPEC, 4> {
                RXFFLSH_W::new(self)
            }
            #[doc = "Bit 5 - TxFIFO flush"]
            #[inline(always)]
            #[must_use]
            pub fn txfflsh(&mut self) -> TXFFLSH_W<GRSTCTL_SPEC, 5> {
                TXFFLSH_W::new(self)
            }
            #[doc = "Bits 6:10 - TxFIFO number"]
            #[inline(always)]
            #[must_use]
            pub fn txfnum(&mut self) -> TXFNUM_W<GRSTCTL_SPEC, 6> {
                TXFNUM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS reset register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grstctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`grstctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GRSTCTL_SPEC;
        impl crate::RegisterSpec for GRSTCTL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`grstctl::R`](R) reader structure"]
        impl crate::Readable for GRSTCTL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`grstctl::W`](W) writer structure"]
        impl crate::Writable for GRSTCTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GRSTCTL to value 0x2000_0000"]
        impl crate::Resettable for GRSTCTL_SPEC {
            const RESET_VALUE: Self::Ux = 0x2000_0000;
        }
    }
    #[doc = "GINTSTS (rw) register accessor: OTG_HS core interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gintsts::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gintsts::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gintsts`]
module"]
    pub type GINTSTS = crate::Reg<gintsts::GINTSTS_SPEC>;
    #[doc = "OTG_HS core interrupt register"]
    pub mod gintsts {
        #[doc = "Register `GINTSTS` reader"]
        pub type R = crate::R<GINTSTS_SPEC>;
        #[doc = "Register `GINTSTS` writer"]
        pub type W = crate::W<GINTSTS_SPEC>;
        #[doc = "Field `CMOD` reader - Current mode of operation"]
        pub type CMOD_R = crate::BitReader;
        #[doc = "Field `MMIS` reader - Mode mismatch interrupt"]
        pub type MMIS_R = crate::BitReader;
        #[doc = "Field `MMIS` writer - Mode mismatch interrupt"]
        pub type MMIS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OTGINT` reader - OTG interrupt"]
        pub type OTGINT_R = crate::BitReader;
        #[doc = "Field `SOF` reader - Start of frame"]
        pub type SOF_R = crate::BitReader;
        #[doc = "Field `SOF` writer - Start of frame"]
        pub type SOF_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXFLVL` reader - RxFIFO nonempty"]
        pub type RXFLVL_R = crate::BitReader;
        #[doc = "Field `NPTXFE` reader - Nonperiodic TxFIFO empty"]
        pub type NPTXFE_R = crate::BitReader;
        #[doc = "Field `GINAKEFF` reader - Global IN nonperiodic NAK effective"]
        pub type GINAKEFF_R = crate::BitReader;
        #[doc = "Field `BOUTNAKEFF` reader - Global OUT NAK effective"]
        pub type BOUTNAKEFF_R = crate::BitReader;
        #[doc = "Field `ESUSP` reader - Early suspend"]
        pub type ESUSP_R = crate::BitReader;
        #[doc = "Field `ESUSP` writer - Early suspend"]
        pub type ESUSP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `USBSUSP` reader - USB suspend"]
        pub type USBSUSP_R = crate::BitReader;
        #[doc = "Field `USBSUSP` writer - USB suspend"]
        pub type USBSUSP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `USBRST` reader - USB reset"]
        pub type USBRST_R = crate::BitReader;
        #[doc = "Field `USBRST` writer - USB reset"]
        pub type USBRST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENUMDNE` reader - Enumeration done"]
        pub type ENUMDNE_R = crate::BitReader;
        #[doc = "Field `ENUMDNE` writer - Enumeration done"]
        pub type ENUMDNE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ISOODRP` reader - Isochronous OUT packet dropped interrupt"]
        pub type ISOODRP_R = crate::BitReader;
        #[doc = "Field `ISOODRP` writer - Isochronous OUT packet dropped interrupt"]
        pub type ISOODRP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EOPF` reader - End of periodic frame interrupt"]
        pub type EOPF_R = crate::BitReader;
        #[doc = "Field `EOPF` writer - End of periodic frame interrupt"]
        pub type EOPF_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `IEPINT` reader - IN endpoint interrupt"]
        pub type IEPINT_R = crate::BitReader;
        #[doc = "Field `OEPINT` reader - OUT endpoint interrupt"]
        pub type OEPINT_R = crate::BitReader;
        #[doc = "Field `IISOIXFR` reader - Incomplete isochronous IN transfer"]
        pub type IISOIXFR_R = crate::BitReader;
        #[doc = "Field `IISOIXFR` writer - Incomplete isochronous IN transfer"]
        pub type IISOIXFR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PXFR_INCOMPISOOUT` reader - Incomplete periodic transfer"]
        pub type PXFR_INCOMPISOOUT_R = crate::BitReader;
        #[doc = "Field `PXFR_INCOMPISOOUT` writer - Incomplete periodic transfer"]
        pub type PXFR_INCOMPISOOUT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DATAFSUSP` reader - Data fetch suspended"]
        pub type DATAFSUSP_R = crate::BitReader;
        #[doc = "Field `DATAFSUSP` writer - Data fetch suspended"]
        pub type DATAFSUSP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HPRTINT` reader - Host port interrupt"]
        pub type HPRTINT_R = crate::BitReader;
        #[doc = "Field `HCINT` reader - Host channels interrupt"]
        pub type HCINT_R = crate::BitReader;
        #[doc = "Field `PTXFE` reader - Periodic TxFIFO empty"]
        pub type PTXFE_R = crate::BitReader;
        #[doc = "Field `CIDSCHG` reader - Connector ID status change"]
        pub type CIDSCHG_R = crate::BitReader;
        #[doc = "Field `CIDSCHG` writer - Connector ID status change"]
        pub type CIDSCHG_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DISCINT` reader - Disconnect detected interrupt"]
        pub type DISCINT_R = crate::BitReader;
        #[doc = "Field `DISCINT` writer - Disconnect detected interrupt"]
        pub type DISCINT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SRQINT` reader - Session request/new session detected interrupt"]
        pub type SRQINT_R = crate::BitReader;
        #[doc = "Field `SRQINT` writer - Session request/new session detected interrupt"]
        pub type SRQINT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WKUINT` reader - Resume/remote wakeup detected interrupt"]
        pub type WKUINT_R = crate::BitReader;
        #[doc = "Field `WKUINT` writer - Resume/remote wakeup detected interrupt"]
        pub type WKUINT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Current mode of operation"]
            #[inline(always)]
            pub fn cmod(&self) -> CMOD_R {
                CMOD_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Mode mismatch interrupt"]
            #[inline(always)]
            pub fn mmis(&self) -> MMIS_R {
                MMIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - OTG interrupt"]
            #[inline(always)]
            pub fn otgint(&self) -> OTGINT_R {
                OTGINT_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Start of frame"]
            #[inline(always)]
            pub fn sof(&self) -> SOF_R {
                SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RxFIFO nonempty"]
            #[inline(always)]
            pub fn rxflvl(&self) -> RXFLVL_R {
                RXFLVL_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Nonperiodic TxFIFO empty"]
            #[inline(always)]
            pub fn nptxfe(&self) -> NPTXFE_R {
                NPTXFE_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Global IN nonperiodic NAK effective"]
            #[inline(always)]
            pub fn ginakeff(&self) -> GINAKEFF_R {
                GINAKEFF_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Global OUT NAK effective"]
            #[inline(always)]
            pub fn boutnakeff(&self) -> BOUTNAKEFF_R {
                BOUTNAKEFF_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 10 - Early suspend"]
            #[inline(always)]
            pub fn esusp(&self) -> ESUSP_R {
                ESUSP_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - USB suspend"]
            #[inline(always)]
            pub fn usbsusp(&self) -> USBSUSP_R {
                USBSUSP_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - USB reset"]
            #[inline(always)]
            pub fn usbrst(&self) -> USBRST_R {
                USBRST_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Enumeration done"]
            #[inline(always)]
            pub fn enumdne(&self) -> ENUMDNE_R {
                ENUMDNE_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Isochronous OUT packet dropped interrupt"]
            #[inline(always)]
            pub fn isoodrp(&self) -> ISOODRP_R {
                ISOODRP_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - End of periodic frame interrupt"]
            #[inline(always)]
            pub fn eopf(&self) -> EOPF_R {
                EOPF_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 18 - IN endpoint interrupt"]
            #[inline(always)]
            pub fn iepint(&self) -> IEPINT_R {
                IEPINT_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - OUT endpoint interrupt"]
            #[inline(always)]
            pub fn oepint(&self) -> OEPINT_R {
                OEPINT_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Incomplete isochronous IN transfer"]
            #[inline(always)]
            pub fn iisoixfr(&self) -> IISOIXFR_R {
                IISOIXFR_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Incomplete periodic transfer"]
            #[inline(always)]
            pub fn pxfr_incompisoout(&self) -> PXFR_INCOMPISOOUT_R {
                PXFR_INCOMPISOOUT_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Data fetch suspended"]
            #[inline(always)]
            pub fn datafsusp(&self) -> DATAFSUSP_R {
                DATAFSUSP_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 24 - Host port interrupt"]
            #[inline(always)]
            pub fn hprtint(&self) -> HPRTINT_R {
                HPRTINT_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Host channels interrupt"]
            #[inline(always)]
            pub fn hcint(&self) -> HCINT_R {
                HCINT_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Periodic TxFIFO empty"]
            #[inline(always)]
            pub fn ptxfe(&self) -> PTXFE_R {
                PTXFE_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 28 - Connector ID status change"]
            #[inline(always)]
            pub fn cidschg(&self) -> CIDSCHG_R {
                CIDSCHG_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Disconnect detected interrupt"]
            #[inline(always)]
            pub fn discint(&self) -> DISCINT_R {
                DISCINT_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Session request/new session detected interrupt"]
            #[inline(always)]
            pub fn srqint(&self) -> SRQINT_R {
                SRQINT_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Resume/remote wakeup detected interrupt"]
            #[inline(always)]
            pub fn wkuint(&self) -> WKUINT_R {
                WKUINT_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GINTSTS")
                    .field("cmod", &format_args!("{}", self.cmod().bit()))
                    .field("mmis", &format_args!("{}", self.mmis().bit()))
                    .field("otgint", &format_args!("{}", self.otgint().bit()))
                    .field("sof", &format_args!("{}", self.sof().bit()))
                    .field("rxflvl", &format_args!("{}", self.rxflvl().bit()))
                    .field("nptxfe", &format_args!("{}", self.nptxfe().bit()))
                    .field("ginakeff", &format_args!("{}", self.ginakeff().bit()))
                    .field("boutnakeff", &format_args!("{}", self.boutnakeff().bit()))
                    .field("esusp", &format_args!("{}", self.esusp().bit()))
                    .field("usbsusp", &format_args!("{}", self.usbsusp().bit()))
                    .field("usbrst", &format_args!("{}", self.usbrst().bit()))
                    .field("enumdne", &format_args!("{}", self.enumdne().bit()))
                    .field("isoodrp", &format_args!("{}", self.isoodrp().bit()))
                    .field("eopf", &format_args!("{}", self.eopf().bit()))
                    .field("iepint", &format_args!("{}", self.iepint().bit()))
                    .field("oepint", &format_args!("{}", self.oepint().bit()))
                    .field("iisoixfr", &format_args!("{}", self.iisoixfr().bit()))
                    .field(
                        "pxfr_incompisoout",
                        &format_args!("{}", self.pxfr_incompisoout().bit()),
                    )
                    .field("datafsusp", &format_args!("{}", self.datafsusp().bit()))
                    .field("hprtint", &format_args!("{}", self.hprtint().bit()))
                    .field("hcint", &format_args!("{}", self.hcint().bit()))
                    .field("ptxfe", &format_args!("{}", self.ptxfe().bit()))
                    .field("cidschg", &format_args!("{}", self.cidschg().bit()))
                    .field("discint", &format_args!("{}", self.discint().bit()))
                    .field("srqint", &format_args!("{}", self.srqint().bit()))
                    .field("wkuint", &format_args!("{}", self.wkuint().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GINTSTS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - Mode mismatch interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn mmis(&mut self) -> MMIS_W<GINTSTS_SPEC, 1> {
                MMIS_W::new(self)
            }
            #[doc = "Bit 3 - Start of frame"]
            #[inline(always)]
            #[must_use]
            pub fn sof(&mut self) -> SOF_W<GINTSTS_SPEC, 3> {
                SOF_W::new(self)
            }
            #[doc = "Bit 10 - Early suspend"]
            #[inline(always)]
            #[must_use]
            pub fn esusp(&mut self) -> ESUSP_W<GINTSTS_SPEC, 10> {
                ESUSP_W::new(self)
            }
            #[doc = "Bit 11 - USB suspend"]
            #[inline(always)]
            #[must_use]
            pub fn usbsusp(&mut self) -> USBSUSP_W<GINTSTS_SPEC, 11> {
                USBSUSP_W::new(self)
            }
            #[doc = "Bit 12 - USB reset"]
            #[inline(always)]
            #[must_use]
            pub fn usbrst(&mut self) -> USBRST_W<GINTSTS_SPEC, 12> {
                USBRST_W::new(self)
            }
            #[doc = "Bit 13 - Enumeration done"]
            #[inline(always)]
            #[must_use]
            pub fn enumdne(&mut self) -> ENUMDNE_W<GINTSTS_SPEC, 13> {
                ENUMDNE_W::new(self)
            }
            #[doc = "Bit 14 - Isochronous OUT packet dropped interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn isoodrp(&mut self) -> ISOODRP_W<GINTSTS_SPEC, 14> {
                ISOODRP_W::new(self)
            }
            #[doc = "Bit 15 - End of periodic frame interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn eopf(&mut self) -> EOPF_W<GINTSTS_SPEC, 15> {
                EOPF_W::new(self)
            }
            #[doc = "Bit 20 - Incomplete isochronous IN transfer"]
            #[inline(always)]
            #[must_use]
            pub fn iisoixfr(&mut self) -> IISOIXFR_W<GINTSTS_SPEC, 20> {
                IISOIXFR_W::new(self)
            }
            #[doc = "Bit 21 - Incomplete periodic transfer"]
            #[inline(always)]
            #[must_use]
            pub fn pxfr_incompisoout(&mut self) -> PXFR_INCOMPISOOUT_W<GINTSTS_SPEC, 21> {
                PXFR_INCOMPISOOUT_W::new(self)
            }
            #[doc = "Bit 22 - Data fetch suspended"]
            #[inline(always)]
            #[must_use]
            pub fn datafsusp(&mut self) -> DATAFSUSP_W<GINTSTS_SPEC, 22> {
                DATAFSUSP_W::new(self)
            }
            #[doc = "Bit 28 - Connector ID status change"]
            #[inline(always)]
            #[must_use]
            pub fn cidschg(&mut self) -> CIDSCHG_W<GINTSTS_SPEC, 28> {
                CIDSCHG_W::new(self)
            }
            #[doc = "Bit 29 - Disconnect detected interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn discint(&mut self) -> DISCINT_W<GINTSTS_SPEC, 29> {
                DISCINT_W::new(self)
            }
            #[doc = "Bit 30 - Session request/new session detected interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn srqint(&mut self) -> SRQINT_W<GINTSTS_SPEC, 30> {
                SRQINT_W::new(self)
            }
            #[doc = "Bit 31 - Resume/remote wakeup detected interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn wkuint(&mut self) -> WKUINT_W<GINTSTS_SPEC, 31> {
                WKUINT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS core interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gintsts::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gintsts::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GINTSTS_SPEC;
        impl crate::RegisterSpec for GINTSTS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gintsts::R`](R) reader structure"]
        impl crate::Readable for GINTSTS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gintsts::W`](W) writer structure"]
        impl crate::Writable for GINTSTS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GINTSTS to value 0x0400_0020"]
        impl crate::Resettable for GINTSTS_SPEC {
            const RESET_VALUE: Self::Ux = 0x0400_0020;
        }
    }
    #[doc = "GINTMSK (rw) register accessor: OTG_HS interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gintmsk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gintmsk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gintmsk`]
module"]
    pub type GINTMSK = crate::Reg<gintmsk::GINTMSK_SPEC>;
    #[doc = "OTG_HS interrupt mask register"]
    pub mod gintmsk {
        #[doc = "Register `GINTMSK` reader"]
        pub type R = crate::R<GINTMSK_SPEC>;
        #[doc = "Register `GINTMSK` writer"]
        pub type W = crate::W<GINTMSK_SPEC>;
        #[doc = "Field `MMISM` reader - Mode mismatch interrupt mask"]
        pub type MMISM_R = crate::BitReader;
        #[doc = "Field `MMISM` writer - Mode mismatch interrupt mask"]
        pub type MMISM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OTGINT` reader - OTG interrupt mask"]
        pub type OTGINT_R = crate::BitReader;
        #[doc = "Field `OTGINT` writer - OTG interrupt mask"]
        pub type OTGINT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SOFM` reader - Start of frame mask"]
        pub type SOFM_R = crate::BitReader;
        #[doc = "Field `SOFM` writer - Start of frame mask"]
        pub type SOFM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXFLVLM` reader - Receive FIFO nonempty mask"]
        pub type RXFLVLM_R = crate::BitReader;
        #[doc = "Field `RXFLVLM` writer - Receive FIFO nonempty mask"]
        pub type RXFLVLM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `NPTXFEM` reader - Nonperiodic TxFIFO empty mask"]
        pub type NPTXFEM_R = crate::BitReader;
        #[doc = "Field `NPTXFEM` writer - Nonperiodic TxFIFO empty mask"]
        pub type NPTXFEM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GINAKEFFM` reader - Global nonperiodic IN NAK effective mask"]
        pub type GINAKEFFM_R = crate::BitReader;
        #[doc = "Field `GINAKEFFM` writer - Global nonperiodic IN NAK effective mask"]
        pub type GINAKEFFM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GONAKEFFM` reader - Global OUT NAK effective mask"]
        pub type GONAKEFFM_R = crate::BitReader;
        #[doc = "Field `GONAKEFFM` writer - Global OUT NAK effective mask"]
        pub type GONAKEFFM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ESUSPM` reader - Early suspend mask"]
        pub type ESUSPM_R = crate::BitReader;
        #[doc = "Field `ESUSPM` writer - Early suspend mask"]
        pub type ESUSPM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `USBSUSPM` reader - USB suspend mask"]
        pub type USBSUSPM_R = crate::BitReader;
        #[doc = "Field `USBSUSPM` writer - USB suspend mask"]
        pub type USBSUSPM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `USBRST` reader - USB reset mask"]
        pub type USBRST_R = crate::BitReader;
        #[doc = "Field `USBRST` writer - USB reset mask"]
        pub type USBRST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENUMDNEM` reader - Enumeration done mask"]
        pub type ENUMDNEM_R = crate::BitReader;
        #[doc = "Field `ENUMDNEM` writer - Enumeration done mask"]
        pub type ENUMDNEM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ISOODRPM` reader - Isochronous OUT packet dropped interrupt mask"]
        pub type ISOODRPM_R = crate::BitReader;
        #[doc = "Field `ISOODRPM` writer - Isochronous OUT packet dropped interrupt mask"]
        pub type ISOODRPM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EOPFM` reader - End of periodic frame interrupt mask"]
        pub type EOPFM_R = crate::BitReader;
        #[doc = "Field `EOPFM` writer - End of periodic frame interrupt mask"]
        pub type EOPFM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EPMISM` reader - Endpoint mismatch interrupt mask"]
        pub type EPMISM_R = crate::BitReader;
        #[doc = "Field `EPMISM` writer - Endpoint mismatch interrupt mask"]
        pub type EPMISM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `IEPINT` reader - IN endpoints interrupt mask"]
        pub type IEPINT_R = crate::BitReader;
        #[doc = "Field `IEPINT` writer - IN endpoints interrupt mask"]
        pub type IEPINT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OEPINT` reader - OUT endpoints interrupt mask"]
        pub type OEPINT_R = crate::BitReader;
        #[doc = "Field `OEPINT` writer - OUT endpoints interrupt mask"]
        pub type OEPINT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `IISOIXFRM` reader - Incomplete isochronous IN transfer mask"]
        pub type IISOIXFRM_R = crate::BitReader;
        #[doc = "Field `IISOIXFRM` writer - Incomplete isochronous IN transfer mask"]
        pub type IISOIXFRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PXFRM_IISOOXFRM` reader - Incomplete periodic transfer mask"]
        pub type PXFRM_IISOOXFRM_R = crate::BitReader;
        #[doc = "Field `PXFRM_IISOOXFRM` writer - Incomplete periodic transfer mask"]
        pub type PXFRM_IISOOXFRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `FSUSPM` reader - Data fetch suspended mask"]
        pub type FSUSPM_R = crate::BitReader;
        #[doc = "Field `FSUSPM` writer - Data fetch suspended mask"]
        pub type FSUSPM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PRTIM` reader - Host port interrupt mask"]
        pub type PRTIM_R = crate::BitReader;
        #[doc = "Field `HCIM` reader - Host channels interrupt mask"]
        pub type HCIM_R = crate::BitReader;
        #[doc = "Field `HCIM` writer - Host channels interrupt mask"]
        pub type HCIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PTXFEM` reader - Periodic TxFIFO empty mask"]
        pub type PTXFEM_R = crate::BitReader;
        #[doc = "Field `PTXFEM` writer - Periodic TxFIFO empty mask"]
        pub type PTXFEM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CIDSCHGM` reader - Connector ID status change mask"]
        pub type CIDSCHGM_R = crate::BitReader;
        #[doc = "Field `CIDSCHGM` writer - Connector ID status change mask"]
        pub type CIDSCHGM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DISCINT` reader - Disconnect detected interrupt mask"]
        pub type DISCINT_R = crate::BitReader;
        #[doc = "Field `DISCINT` writer - Disconnect detected interrupt mask"]
        pub type DISCINT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SRQIM` reader - Session request/new session detected interrupt mask"]
        pub type SRQIM_R = crate::BitReader;
        #[doc = "Field `SRQIM` writer - Session request/new session detected interrupt mask"]
        pub type SRQIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WUIM` reader - Resume/remote wakeup detected interrupt mask"]
        pub type WUIM_R = crate::BitReader;
        #[doc = "Field `WUIM` writer - Resume/remote wakeup detected interrupt mask"]
        pub type WUIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 1 - Mode mismatch interrupt mask"]
            #[inline(always)]
            pub fn mmism(&self) -> MMISM_R {
                MMISM_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - OTG interrupt mask"]
            #[inline(always)]
            pub fn otgint(&self) -> OTGINT_R {
                OTGINT_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Start of frame mask"]
            #[inline(always)]
            pub fn sofm(&self) -> SOFM_R {
                SOFM_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Receive FIFO nonempty mask"]
            #[inline(always)]
            pub fn rxflvlm(&self) -> RXFLVLM_R {
                RXFLVLM_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Nonperiodic TxFIFO empty mask"]
            #[inline(always)]
            pub fn nptxfem(&self) -> NPTXFEM_R {
                NPTXFEM_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Global nonperiodic IN NAK effective mask"]
            #[inline(always)]
            pub fn ginakeffm(&self) -> GINAKEFFM_R {
                GINAKEFFM_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Global OUT NAK effective mask"]
            #[inline(always)]
            pub fn gonakeffm(&self) -> GONAKEFFM_R {
                GONAKEFFM_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 10 - Early suspend mask"]
            #[inline(always)]
            pub fn esuspm(&self) -> ESUSPM_R {
                ESUSPM_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - USB suspend mask"]
            #[inline(always)]
            pub fn usbsuspm(&self) -> USBSUSPM_R {
                USBSUSPM_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - USB reset mask"]
            #[inline(always)]
            pub fn usbrst(&self) -> USBRST_R {
                USBRST_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Enumeration done mask"]
            #[inline(always)]
            pub fn enumdnem(&self) -> ENUMDNEM_R {
                ENUMDNEM_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Isochronous OUT packet dropped interrupt mask"]
            #[inline(always)]
            pub fn isoodrpm(&self) -> ISOODRPM_R {
                ISOODRPM_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - End of periodic frame interrupt mask"]
            #[inline(always)]
            pub fn eopfm(&self) -> EOPFM_R {
                EOPFM_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 17 - Endpoint mismatch interrupt mask"]
            #[inline(always)]
            pub fn epmism(&self) -> EPMISM_R {
                EPMISM_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - IN endpoints interrupt mask"]
            #[inline(always)]
            pub fn iepint(&self) -> IEPINT_R {
                IEPINT_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - OUT endpoints interrupt mask"]
            #[inline(always)]
            pub fn oepint(&self) -> OEPINT_R {
                OEPINT_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Incomplete isochronous IN transfer mask"]
            #[inline(always)]
            pub fn iisoixfrm(&self) -> IISOIXFRM_R {
                IISOIXFRM_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Incomplete periodic transfer mask"]
            #[inline(always)]
            pub fn pxfrm_iisooxfrm(&self) -> PXFRM_IISOOXFRM_R {
                PXFRM_IISOOXFRM_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Data fetch suspended mask"]
            #[inline(always)]
            pub fn fsuspm(&self) -> FSUSPM_R {
                FSUSPM_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 24 - Host port interrupt mask"]
            #[inline(always)]
            pub fn prtim(&self) -> PRTIM_R {
                PRTIM_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Host channels interrupt mask"]
            #[inline(always)]
            pub fn hcim(&self) -> HCIM_R {
                HCIM_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Periodic TxFIFO empty mask"]
            #[inline(always)]
            pub fn ptxfem(&self) -> PTXFEM_R {
                PTXFEM_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 28 - Connector ID status change mask"]
            #[inline(always)]
            pub fn cidschgm(&self) -> CIDSCHGM_R {
                CIDSCHGM_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Disconnect detected interrupt mask"]
            #[inline(always)]
            pub fn discint(&self) -> DISCINT_R {
                DISCINT_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Session request/new session detected interrupt mask"]
            #[inline(always)]
            pub fn srqim(&self) -> SRQIM_R {
                SRQIM_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Resume/remote wakeup detected interrupt mask"]
            #[inline(always)]
            pub fn wuim(&self) -> WUIM_R {
                WUIM_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GINTMSK")
                    .field("mmism", &format_args!("{}", self.mmism().bit()))
                    .field("otgint", &format_args!("{}", self.otgint().bit()))
                    .field("sofm", &format_args!("{}", self.sofm().bit()))
                    .field("rxflvlm", &format_args!("{}", self.rxflvlm().bit()))
                    .field("nptxfem", &format_args!("{}", self.nptxfem().bit()))
                    .field("ginakeffm", &format_args!("{}", self.ginakeffm().bit()))
                    .field("gonakeffm", &format_args!("{}", self.gonakeffm().bit()))
                    .field("esuspm", &format_args!("{}", self.esuspm().bit()))
                    .field("usbsuspm", &format_args!("{}", self.usbsuspm().bit()))
                    .field("usbrst", &format_args!("{}", self.usbrst().bit()))
                    .field("enumdnem", &format_args!("{}", self.enumdnem().bit()))
                    .field("isoodrpm", &format_args!("{}", self.isoodrpm().bit()))
                    .field("eopfm", &format_args!("{}", self.eopfm().bit()))
                    .field("epmism", &format_args!("{}", self.epmism().bit()))
                    .field("iepint", &format_args!("{}", self.iepint().bit()))
                    .field("oepint", &format_args!("{}", self.oepint().bit()))
                    .field("iisoixfrm", &format_args!("{}", self.iisoixfrm().bit()))
                    .field(
                        "pxfrm_iisooxfrm",
                        &format_args!("{}", self.pxfrm_iisooxfrm().bit()),
                    )
                    .field("fsuspm", &format_args!("{}", self.fsuspm().bit()))
                    .field("prtim", &format_args!("{}", self.prtim().bit()))
                    .field("hcim", &format_args!("{}", self.hcim().bit()))
                    .field("ptxfem", &format_args!("{}", self.ptxfem().bit()))
                    .field("cidschgm", &format_args!("{}", self.cidschgm().bit()))
                    .field("discint", &format_args!("{}", self.discint().bit()))
                    .field("srqim", &format_args!("{}", self.srqim().bit()))
                    .field("wuim", &format_args!("{}", self.wuim().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GINTMSK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - Mode mismatch interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn mmism(&mut self) -> MMISM_W<GINTMSK_SPEC, 1> {
                MMISM_W::new(self)
            }
            #[doc = "Bit 2 - OTG interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn otgint(&mut self) -> OTGINT_W<GINTMSK_SPEC, 2> {
                OTGINT_W::new(self)
            }
            #[doc = "Bit 3 - Start of frame mask"]
            #[inline(always)]
            #[must_use]
            pub fn sofm(&mut self) -> SOFM_W<GINTMSK_SPEC, 3> {
                SOFM_W::new(self)
            }
            #[doc = "Bit 4 - Receive FIFO nonempty mask"]
            #[inline(always)]
            #[must_use]
            pub fn rxflvlm(&mut self) -> RXFLVLM_W<GINTMSK_SPEC, 4> {
                RXFLVLM_W::new(self)
            }
            #[doc = "Bit 5 - Nonperiodic TxFIFO empty mask"]
            #[inline(always)]
            #[must_use]
            pub fn nptxfem(&mut self) -> NPTXFEM_W<GINTMSK_SPEC, 5> {
                NPTXFEM_W::new(self)
            }
            #[doc = "Bit 6 - Global nonperiodic IN NAK effective mask"]
            #[inline(always)]
            #[must_use]
            pub fn ginakeffm(&mut self) -> GINAKEFFM_W<GINTMSK_SPEC, 6> {
                GINAKEFFM_W::new(self)
            }
            #[doc = "Bit 7 - Global OUT NAK effective mask"]
            #[inline(always)]
            #[must_use]
            pub fn gonakeffm(&mut self) -> GONAKEFFM_W<GINTMSK_SPEC, 7> {
                GONAKEFFM_W::new(self)
            }
            #[doc = "Bit 10 - Early suspend mask"]
            #[inline(always)]
            #[must_use]
            pub fn esuspm(&mut self) -> ESUSPM_W<GINTMSK_SPEC, 10> {
                ESUSPM_W::new(self)
            }
            #[doc = "Bit 11 - USB suspend mask"]
            #[inline(always)]
            #[must_use]
            pub fn usbsuspm(&mut self) -> USBSUSPM_W<GINTMSK_SPEC, 11> {
                USBSUSPM_W::new(self)
            }
            #[doc = "Bit 12 - USB reset mask"]
            #[inline(always)]
            #[must_use]
            pub fn usbrst(&mut self) -> USBRST_W<GINTMSK_SPEC, 12> {
                USBRST_W::new(self)
            }
            #[doc = "Bit 13 - Enumeration done mask"]
            #[inline(always)]
            #[must_use]
            pub fn enumdnem(&mut self) -> ENUMDNEM_W<GINTMSK_SPEC, 13> {
                ENUMDNEM_W::new(self)
            }
            #[doc = "Bit 14 - Isochronous OUT packet dropped interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn isoodrpm(&mut self) -> ISOODRPM_W<GINTMSK_SPEC, 14> {
                ISOODRPM_W::new(self)
            }
            #[doc = "Bit 15 - End of periodic frame interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn eopfm(&mut self) -> EOPFM_W<GINTMSK_SPEC, 15> {
                EOPFM_W::new(self)
            }
            #[doc = "Bit 17 - Endpoint mismatch interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn epmism(&mut self) -> EPMISM_W<GINTMSK_SPEC, 17> {
                EPMISM_W::new(self)
            }
            #[doc = "Bit 18 - IN endpoints interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn iepint(&mut self) -> IEPINT_W<GINTMSK_SPEC, 18> {
                IEPINT_W::new(self)
            }
            #[doc = "Bit 19 - OUT endpoints interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn oepint(&mut self) -> OEPINT_W<GINTMSK_SPEC, 19> {
                OEPINT_W::new(self)
            }
            #[doc = "Bit 20 - Incomplete isochronous IN transfer mask"]
            #[inline(always)]
            #[must_use]
            pub fn iisoixfrm(&mut self) -> IISOIXFRM_W<GINTMSK_SPEC, 20> {
                IISOIXFRM_W::new(self)
            }
            #[doc = "Bit 21 - Incomplete periodic transfer mask"]
            #[inline(always)]
            #[must_use]
            pub fn pxfrm_iisooxfrm(&mut self) -> PXFRM_IISOOXFRM_W<GINTMSK_SPEC, 21> {
                PXFRM_IISOOXFRM_W::new(self)
            }
            #[doc = "Bit 22 - Data fetch suspended mask"]
            #[inline(always)]
            #[must_use]
            pub fn fsuspm(&mut self) -> FSUSPM_W<GINTMSK_SPEC, 22> {
                FSUSPM_W::new(self)
            }
            #[doc = "Bit 25 - Host channels interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn hcim(&mut self) -> HCIM_W<GINTMSK_SPEC, 25> {
                HCIM_W::new(self)
            }
            #[doc = "Bit 26 - Periodic TxFIFO empty mask"]
            #[inline(always)]
            #[must_use]
            pub fn ptxfem(&mut self) -> PTXFEM_W<GINTMSK_SPEC, 26> {
                PTXFEM_W::new(self)
            }
            #[doc = "Bit 28 - Connector ID status change mask"]
            #[inline(always)]
            #[must_use]
            pub fn cidschgm(&mut self) -> CIDSCHGM_W<GINTMSK_SPEC, 28> {
                CIDSCHGM_W::new(self)
            }
            #[doc = "Bit 29 - Disconnect detected interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn discint(&mut self) -> DISCINT_W<GINTMSK_SPEC, 29> {
                DISCINT_W::new(self)
            }
            #[doc = "Bit 30 - Session request/new session detected interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn srqim(&mut self) -> SRQIM_W<GINTMSK_SPEC, 30> {
                SRQIM_W::new(self)
            }
            #[doc = "Bit 31 - Resume/remote wakeup detected interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn wuim(&mut self) -> WUIM_W<GINTMSK_SPEC, 31> {
                WUIM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gintmsk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gintmsk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GINTMSK_SPEC;
        impl crate::RegisterSpec for GINTMSK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gintmsk::R`](R) reader structure"]
        impl crate::Readable for GINTMSK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gintmsk::W`](W) writer structure"]
        impl crate::Writable for GINTMSK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GINTMSK to value 0"]
        impl crate::Resettable for GINTMSK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "GRXSTSR_Host (r) register accessor: OTG_HS Receive status debug read register (host mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxstsr_host::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@grxstsr_host`]
module"]
    pub type GRXSTSR_HOST = crate::Reg<grxstsr_host::GRXSTSR_HOST_SPEC>;
    #[doc = "OTG_HS Receive status debug read register (host mode)"]
    pub mod grxstsr_host {
        #[doc = "Register `GRXSTSR_Host` reader"]
        pub type R = crate::R<GRXSTSR_HOST_SPEC>;
        #[doc = "Field `CHNUM` reader - Channel number"]
        pub type CHNUM_R = crate::FieldReader;
        #[doc = "Field `BCNT` reader - Byte count"]
        pub type BCNT_R = crate::FieldReader<u16>;
        #[doc = "Field `DPID` reader - Data PID"]
        pub type DPID_R = crate::FieldReader;
        #[doc = "Field `PKTSTS` reader - Packet status"]
        pub type PKTSTS_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:3 - Channel number"]
            #[inline(always)]
            pub fn chnum(&self) -> CHNUM_R {
                CHNUM_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:14 - Byte count"]
            #[inline(always)]
            pub fn bcnt(&self) -> BCNT_R {
                BCNT_R::new(((self.bits >> 4) & 0x07ff) as u16)
            }
            #[doc = "Bits 15:16 - Data PID"]
            #[inline(always)]
            pub fn dpid(&self) -> DPID_R {
                DPID_R::new(((self.bits >> 15) & 3) as u8)
            }
            #[doc = "Bits 17:20 - Packet status"]
            #[inline(always)]
            pub fn pktsts(&self) -> PKTSTS_R {
                PKTSTS_R::new(((self.bits >> 17) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GRXSTSR_Host")
                    .field("chnum", &format_args!("{}", self.chnum().bits()))
                    .field("bcnt", &format_args!("{}", self.bcnt().bits()))
                    .field("dpid", &format_args!("{}", self.dpid().bits()))
                    .field("pktsts", &format_args!("{}", self.pktsts().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GRXSTSR_HOST_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS Receive status debug read register (host mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxstsr_host::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GRXSTSR_HOST_SPEC;
        impl crate::RegisterSpec for GRXSTSR_HOST_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`grxstsr_host::R`](R) reader structure"]
        impl crate::Readable for GRXSTSR_HOST_SPEC {}
        #[doc = "`reset()` method sets GRXSTSR_Host to value 0"]
        impl crate::Resettable for GRXSTSR_HOST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "GRXSTSP_Host (r) register accessor: OTG_HS status read and pop register (host mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxstsp_host::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@grxstsp_host`]
module"]
    pub type GRXSTSP_HOST = crate::Reg<grxstsp_host::GRXSTSP_HOST_SPEC>;
    #[doc = "OTG_HS status read and pop register (host mode)"]
    pub mod grxstsp_host {
        #[doc = "Register `GRXSTSP_Host` reader"]
        pub type R = crate::R<GRXSTSP_HOST_SPEC>;
        #[doc = "Field `CHNUM` reader - Channel number"]
        pub type CHNUM_R = crate::FieldReader;
        #[doc = "Field `BCNT` reader - Byte count"]
        pub type BCNT_R = crate::FieldReader<u16>;
        #[doc = "Field `DPID` reader - Data PID"]
        pub type DPID_R = crate::FieldReader;
        #[doc = "Field `PKTSTS` reader - Packet status"]
        pub type PKTSTS_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:3 - Channel number"]
            #[inline(always)]
            pub fn chnum(&self) -> CHNUM_R {
                CHNUM_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:14 - Byte count"]
            #[inline(always)]
            pub fn bcnt(&self) -> BCNT_R {
                BCNT_R::new(((self.bits >> 4) & 0x07ff) as u16)
            }
            #[doc = "Bits 15:16 - Data PID"]
            #[inline(always)]
            pub fn dpid(&self) -> DPID_R {
                DPID_R::new(((self.bits >> 15) & 3) as u8)
            }
            #[doc = "Bits 17:20 - Packet status"]
            #[inline(always)]
            pub fn pktsts(&self) -> PKTSTS_R {
                PKTSTS_R::new(((self.bits >> 17) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GRXSTSP_Host")
                    .field("chnum", &format_args!("{}", self.chnum().bits()))
                    .field("bcnt", &format_args!("{}", self.bcnt().bits()))
                    .field("dpid", &format_args!("{}", self.dpid().bits()))
                    .field("pktsts", &format_args!("{}", self.pktsts().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GRXSTSP_HOST_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS status read and pop register (host mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxstsp_host::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GRXSTSP_HOST_SPEC;
        impl crate::RegisterSpec for GRXSTSP_HOST_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`grxstsp_host::R`](R) reader structure"]
        impl crate::Readable for GRXSTSP_HOST_SPEC {}
        #[doc = "`reset()` method sets GRXSTSP_Host to value 0"]
        impl crate::Resettable for GRXSTSP_HOST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "GRXFSIZ (rw) register accessor: OTG_HS Receive FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxfsiz::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`grxfsiz::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@grxfsiz`]
module"]
    pub type GRXFSIZ = crate::Reg<grxfsiz::GRXFSIZ_SPEC>;
    #[doc = "OTG_HS Receive FIFO size register"]
    pub mod grxfsiz {
        #[doc = "Register `GRXFSIZ` reader"]
        pub type R = crate::R<GRXFSIZ_SPEC>;
        #[doc = "Register `GRXFSIZ` writer"]
        pub type W = crate::W<GRXFSIZ_SPEC>;
        #[doc = "Field `RXFD` reader - RxFIFO depth"]
        pub type RXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `RXFD` writer - RxFIFO depth"]
        pub type RXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - RxFIFO depth"]
            #[inline(always)]
            pub fn rxfd(&self) -> RXFD_R {
                RXFD_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GRXFSIZ")
                    .field("rxfd", &format_args!("{}", self.rxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GRXFSIZ_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn rxfd(&mut self) -> RXFD_W<GRXFSIZ_SPEC, 0> {
                RXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS Receive FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxfsiz::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`grxfsiz::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GRXFSIZ_SPEC;
        impl crate::RegisterSpec for GRXFSIZ_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`grxfsiz::R`](R) reader structure"]
        impl crate::Readable for GRXFSIZ_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`grxfsiz::W`](W) writer structure"]
        impl crate::Writable for GRXFSIZ_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GRXFSIZ to value 0x0200"]
        impl crate::Resettable for GRXFSIZ_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200;
        }
    }
    #[doc = "GNPTXFSIZ_Host (rw) register accessor: OTG_HS nonperiodic transmit FIFO size register (host mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gnptxfsiz_host::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gnptxfsiz_host::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gnptxfsiz_host`]
module"]
    pub type GNPTXFSIZ_HOST = crate::Reg<gnptxfsiz_host::GNPTXFSIZ_HOST_SPEC>;
    #[doc = "OTG_HS nonperiodic transmit FIFO size register (host mode)"]
    pub mod gnptxfsiz_host {
        #[doc = "Register `GNPTXFSIZ_Host` reader"]
        pub type R = crate::R<GNPTXFSIZ_HOST_SPEC>;
        #[doc = "Register `GNPTXFSIZ_Host` writer"]
        pub type W = crate::W<GNPTXFSIZ_HOST_SPEC>;
        #[doc = "Field `NPTXFSA` reader - Nonperiodic transmit RAM start address"]
        pub type NPTXFSA_R = crate::FieldReader<u16>;
        #[doc = "Field `NPTXFSA` writer - Nonperiodic transmit RAM start address"]
        pub type NPTXFSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `NPTXFD` reader - Nonperiodic TxFIFO depth"]
        pub type NPTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `NPTXFD` writer - Nonperiodic TxFIFO depth"]
        pub type NPTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Nonperiodic transmit RAM start address"]
            #[inline(always)]
            pub fn nptxfsa(&self) -> NPTXFSA_R {
                NPTXFSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Nonperiodic TxFIFO depth"]
            #[inline(always)]
            pub fn nptxfd(&self) -> NPTXFD_R {
                NPTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GNPTXFSIZ_Host")
                    .field("nptxfsa", &format_args!("{}", self.nptxfsa().bits()))
                    .field("nptxfd", &format_args!("{}", self.nptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GNPTXFSIZ_HOST_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Nonperiodic transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn nptxfsa(&mut self) -> NPTXFSA_W<GNPTXFSIZ_HOST_SPEC, 0> {
                NPTXFSA_W::new(self)
            }
            #[doc = "Bits 16:31 - Nonperiodic TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn nptxfd(&mut self) -> NPTXFD_W<GNPTXFSIZ_HOST_SPEC, 16> {
                NPTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS nonperiodic transmit FIFO size register (host mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gnptxfsiz_host::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gnptxfsiz_host::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GNPTXFSIZ_HOST_SPEC;
        impl crate::RegisterSpec for GNPTXFSIZ_HOST_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gnptxfsiz_host::R`](R) reader structure"]
        impl crate::Readable for GNPTXFSIZ_HOST_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gnptxfsiz_host::W`](W) writer structure"]
        impl crate::Writable for GNPTXFSIZ_HOST_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GNPTXFSIZ_Host to value 0x0200"]
        impl crate::Resettable for GNPTXFSIZ_HOST_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200;
        }
    }
    #[doc = "TX0FSIZ_Peripheral (rw) register accessor: Endpoint 0 transmit FIFO size (peripheral mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx0fsiz_peripheral::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx0fsiz_peripheral::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx0fsiz_peripheral`]
module"]
    pub type TX0FSIZ_PERIPHERAL = crate::Reg<tx0fsiz_peripheral::TX0FSIZ_PERIPHERAL_SPEC>;
    #[doc = "Endpoint 0 transmit FIFO size (peripheral mode)"]
    pub mod tx0fsiz_peripheral {
        #[doc = "Register `TX0FSIZ_Peripheral` reader"]
        pub type R = crate::R<TX0FSIZ_PERIPHERAL_SPEC>;
        #[doc = "Register `TX0FSIZ_Peripheral` writer"]
        pub type W = crate::W<TX0FSIZ_PERIPHERAL_SPEC>;
        #[doc = "Field `TX0FSA` reader - Endpoint 0 transmit RAM start address"]
        pub type TX0FSA_R = crate::FieldReader<u16>;
        #[doc = "Field `TX0FSA` writer - Endpoint 0 transmit RAM start address"]
        pub type TX0FSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `TX0FD` reader - Endpoint 0 TxFIFO depth"]
        pub type TX0FD_R = crate::FieldReader<u16>;
        #[doc = "Field `TX0FD` writer - Endpoint 0 TxFIFO depth"]
        pub type TX0FD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Endpoint 0 transmit RAM start address"]
            #[inline(always)]
            pub fn tx0fsa(&self) -> TX0FSA_R {
                TX0FSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Endpoint 0 TxFIFO depth"]
            #[inline(always)]
            pub fn tx0fd(&self) -> TX0FD_R {
                TX0FD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TX0FSIZ_Peripheral")
                    .field("tx0fsa", &format_args!("{}", self.tx0fsa().bits()))
                    .field("tx0fd", &format_args!("{}", self.tx0fd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<TX0FSIZ_PERIPHERAL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Endpoint 0 transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn tx0fsa(&mut self) -> TX0FSA_W<TX0FSIZ_PERIPHERAL_SPEC, 0> {
                TX0FSA_W::new(self)
            }
            #[doc = "Bits 16:31 - Endpoint 0 TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn tx0fd(&mut self) -> TX0FD_W<TX0FSIZ_PERIPHERAL_SPEC, 16> {
                TX0FD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Endpoint 0 transmit FIFO size (peripheral mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx0fsiz_peripheral::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx0fsiz_peripheral::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TX0FSIZ_PERIPHERAL_SPEC;
        impl crate::RegisterSpec for TX0FSIZ_PERIPHERAL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tx0fsiz_peripheral::R`](R) reader structure"]
        impl crate::Readable for TX0FSIZ_PERIPHERAL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`tx0fsiz_peripheral::W`](W) writer structure"]
        impl crate::Writable for TX0FSIZ_PERIPHERAL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets TX0FSIZ_Peripheral to value 0x0200"]
        impl crate::Resettable for TX0FSIZ_PERIPHERAL_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200;
        }
    }
    #[doc = "GNPTXSTS (r) register accessor: OTG_HS nonperiodic transmit FIFO/queue status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gnptxsts::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gnptxsts`]
module"]
    pub type GNPTXSTS = crate::Reg<gnptxsts::GNPTXSTS_SPEC>;
    #[doc = "OTG_HS nonperiodic transmit FIFO/queue status register"]
    pub mod gnptxsts {
        #[doc = "Register `GNPTXSTS` reader"]
        pub type R = crate::R<GNPTXSTS_SPEC>;
        #[doc = "Field `NPTXFSAV` reader - Nonperiodic TxFIFO space available"]
        pub type NPTXFSAV_R = crate::FieldReader<u16>;
        #[doc = "Field `NPTQXSAV` reader - Nonperiodic transmit request queue space available"]
        pub type NPTQXSAV_R = crate::FieldReader;
        #[doc = "Field `NPTXQTOP` reader - Top of the nonperiodic transmit request queue"]
        pub type NPTXQTOP_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:15 - Nonperiodic TxFIFO space available"]
            #[inline(always)]
            pub fn nptxfsav(&self) -> NPTXFSAV_R {
                NPTXFSAV_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:23 - Nonperiodic transmit request queue space available"]
            #[inline(always)]
            pub fn nptqxsav(&self) -> NPTQXSAV_R {
                NPTQXSAV_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:30 - Top of the nonperiodic transmit request queue"]
            #[inline(always)]
            pub fn nptxqtop(&self) -> NPTXQTOP_R {
                NPTXQTOP_R::new(((self.bits >> 24) & 0x7f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GNPTXSTS")
                    .field("nptxfsav", &format_args!("{}", self.nptxfsav().bits()))
                    .field("nptqxsav", &format_args!("{}", self.nptqxsav().bits()))
                    .field("nptxqtop", &format_args!("{}", self.nptxqtop().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GNPTXSTS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS nonperiodic transmit FIFO/queue status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gnptxsts::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GNPTXSTS_SPEC;
        impl crate::RegisterSpec for GNPTXSTS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gnptxsts::R`](R) reader structure"]
        impl crate::Readable for GNPTXSTS_SPEC {}
        #[doc = "`reset()` method sets GNPTXSTS to value 0x0008_0200"]
        impl crate::Resettable for GNPTXSTS_SPEC {
            const RESET_VALUE: Self::Ux = 0x0008_0200;
        }
    }
    #[doc = "GCCFG (rw) register accessor: OTG_HS general core configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gccfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gccfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gccfg`]
module"]
    pub type GCCFG = crate::Reg<gccfg::GCCFG_SPEC>;
    #[doc = "OTG_HS general core configuration register"]
    pub mod gccfg {
        #[doc = "Register `GCCFG` reader"]
        pub type R = crate::R<GCCFG_SPEC>;
        #[doc = "Register `GCCFG` writer"]
        pub type W = crate::W<GCCFG_SPEC>;
        #[doc = "Field `PWRDWN` reader - Power down"]
        pub type PWRDWN_R = crate::BitReader;
        #[doc = "Field `PWRDWN` writer - Power down"]
        pub type PWRDWN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `I2CPADEN` reader - Enable I2C bus connection for the external I2C PHY interface"]
        pub type I2CPADEN_R = crate::BitReader;
        #[doc = "Field `I2CPADEN` writer - Enable I2C bus connection for the external I2C PHY interface"]
        pub type I2CPADEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `VBUSASEN` reader - Enable the VBUS sensing device"]
        pub type VBUSASEN_R = crate::BitReader;
        #[doc = "Field `VBUSASEN` writer - Enable the VBUS sensing device"]
        pub type VBUSASEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `VBUSBSEN` reader - Enable the VBUS sensing device"]
        pub type VBUSBSEN_R = crate::BitReader;
        #[doc = "Field `VBUSBSEN` writer - Enable the VBUS sensing device"]
        pub type VBUSBSEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SOFOUTEN` reader - SOF output enable"]
        pub type SOFOUTEN_R = crate::BitReader;
        #[doc = "Field `SOFOUTEN` writer - SOF output enable"]
        pub type SOFOUTEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `NOVBUSSENS` reader - VBUS sensing disable option"]
        pub type NOVBUSSENS_R = crate::BitReader;
        #[doc = "Field `NOVBUSSENS` writer - VBUS sensing disable option"]
        pub type NOVBUSSENS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 16 - Power down"]
            #[inline(always)]
            pub fn pwrdwn(&self) -> PWRDWN_R {
                PWRDWN_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Enable I2C bus connection for the external I2C PHY interface"]
            #[inline(always)]
            pub fn i2cpaden(&self) -> I2CPADEN_R {
                I2CPADEN_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Enable the VBUS sensing device"]
            #[inline(always)]
            pub fn vbusasen(&self) -> VBUSASEN_R {
                VBUSASEN_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Enable the VBUS sensing device"]
            #[inline(always)]
            pub fn vbusbsen(&self) -> VBUSBSEN_R {
                VBUSBSEN_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - SOF output enable"]
            #[inline(always)]
            pub fn sofouten(&self) -> SOFOUTEN_R {
                SOFOUTEN_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - VBUS sensing disable option"]
            #[inline(always)]
            pub fn novbussens(&self) -> NOVBUSSENS_R {
                NOVBUSSENS_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GCCFG")
                    .field("pwrdwn", &format_args!("{}", self.pwrdwn().bit()))
                    .field("i2cpaden", &format_args!("{}", self.i2cpaden().bit()))
                    .field("vbusasen", &format_args!("{}", self.vbusasen().bit()))
                    .field("vbusbsen", &format_args!("{}", self.vbusbsen().bit()))
                    .field("sofouten", &format_args!("{}", self.sofouten().bit()))
                    .field("novbussens", &format_args!("{}", self.novbussens().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GCCFG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 16 - Power down"]
            #[inline(always)]
            #[must_use]
            pub fn pwrdwn(&mut self) -> PWRDWN_W<GCCFG_SPEC, 16> {
                PWRDWN_W::new(self)
            }
            #[doc = "Bit 17 - Enable I2C bus connection for the external I2C PHY interface"]
            #[inline(always)]
            #[must_use]
            pub fn i2cpaden(&mut self) -> I2CPADEN_W<GCCFG_SPEC, 17> {
                I2CPADEN_W::new(self)
            }
            #[doc = "Bit 18 - Enable the VBUS sensing device"]
            #[inline(always)]
            #[must_use]
            pub fn vbusasen(&mut self) -> VBUSASEN_W<GCCFG_SPEC, 18> {
                VBUSASEN_W::new(self)
            }
            #[doc = "Bit 19 - Enable the VBUS sensing device"]
            #[inline(always)]
            #[must_use]
            pub fn vbusbsen(&mut self) -> VBUSBSEN_W<GCCFG_SPEC, 19> {
                VBUSBSEN_W::new(self)
            }
            #[doc = "Bit 20 - SOF output enable"]
            #[inline(always)]
            #[must_use]
            pub fn sofouten(&mut self) -> SOFOUTEN_W<GCCFG_SPEC, 20> {
                SOFOUTEN_W::new(self)
            }
            #[doc = "Bit 21 - VBUS sensing disable option"]
            #[inline(always)]
            #[must_use]
            pub fn novbussens(&mut self) -> NOVBUSSENS_W<GCCFG_SPEC, 21> {
                NOVBUSSENS_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS general core configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gccfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gccfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GCCFG_SPEC;
        impl crate::RegisterSpec for GCCFG_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gccfg::R`](R) reader structure"]
        impl crate::Readable for GCCFG_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`gccfg::W`](W) writer structure"]
        impl crate::Writable for GCCFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets GCCFG to value 0"]
        impl crate::Resettable for GCCFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CID (rw) register accessor: OTG_HS core ID register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cid::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cid::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cid`]
module"]
    pub type CID = crate::Reg<cid::CID_SPEC>;
    #[doc = "OTG_HS core ID register"]
    pub mod cid {
        #[doc = "Register `CID` reader"]
        pub type R = crate::R<CID_SPEC>;
        #[doc = "Register `CID` writer"]
        pub type W = crate::W<CID_SPEC>;
        #[doc = "Field `PRODUCT_ID` reader - Product ID field"]
        pub type PRODUCT_ID_R = crate::FieldReader<u32>;
        #[doc = "Field `PRODUCT_ID` writer - Product ID field"]
        pub type PRODUCT_ID_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 32, O, u32>;
        impl R {
            #[doc = "Bits 0:31 - Product ID field"]
            #[inline(always)]
            pub fn product_id(&self) -> PRODUCT_ID_R {
                PRODUCT_ID_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CID")
                    .field("product_id", &format_args!("{}", self.product_id().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CID_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Product ID field"]
            #[inline(always)]
            #[must_use]
            pub fn product_id(&mut self) -> PRODUCT_ID_W<CID_SPEC, 0> {
                PRODUCT_ID_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS core ID register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cid::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cid::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CID_SPEC;
        impl crate::RegisterSpec for CID_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cid::R`](R) reader structure"]
        impl crate::Readable for CID_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cid::W`](W) writer structure"]
        impl crate::Writable for CID_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CID to value 0x1200"]
        impl crate::Resettable for CID_SPEC {
            const RESET_VALUE: Self::Ux = 0x1200;
        }
    }
    #[doc = "VID (r) register accessor: OTG_HS vendor ID register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vid::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vid`]
module"]
    pub type VID = crate::Reg<vid::VID_SPEC>;
    #[doc = "OTG_HS vendor ID register"]
    pub mod vid {
        #[doc = "Register `VID` reader"]
        pub type R = crate::R<VID_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<VID_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS vendor ID register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vid::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct VID_SPEC;
        impl crate::RegisterSpec for VID_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vid::R`](R) reader structure"]
        impl crate::Readable for VID_SPEC {}
    }
    #[doc = "HW_DIRECTION (r) register accessor: Direction\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hw_direction::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hw_direction`]
module"]
    pub type HW_DIRECTION = crate::Reg<hw_direction::HW_DIRECTION_SPEC>;
    #[doc = "Direction"]
    pub mod hw_direction {
        #[doc = "Register `HW_DIRECTION` reader"]
        pub type R = crate::R<HW_DIRECTION_SPEC>;
        #[doc = "Field `DIRECTION[0-15]` reader - Direction %s"]
        pub type DIRECTION_R = crate::FieldReader<DIRECTION_A>;
        #[doc = "Direction %s"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIRECTION_A {
            #[doc = "0: `0`"]
            BIDIR = 0,
            #[doc = "1: `1`"]
            IN = 1,
            #[doc = "2: `10`"]
            OUT = 2,
        }
        impl From<DIRECTION_A> for u8 {
            #[inline(always)]
            fn from(variant: DIRECTION_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIRECTION_A {
            type Ux = u8;
        }
        impl DIRECTION_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIRECTION_A> {
                match self.bits {
                    0 => Some(DIRECTION_A::BIDIR),
                    1 => Some(DIRECTION_A::IN),
                    2 => Some(DIRECTION_A::OUT),
                    _ => None,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_bidir(&self) -> bool {
                *self == DIRECTION_A::BIDIR
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_in(&self) -> bool {
                *self == DIRECTION_A::IN
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_out(&self) -> bool {
                *self == DIRECTION_A::OUT
            }
        }
        impl R {
            #[doc = "Direction [0-15]"]
            #[inline(always)]
            pub unsafe fn direction(&self, n: u8) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> (n * 2)) & 3) as u8)
            }
            #[doc = "Bits 0:1 - Direction 0"]
            #[inline(always)]
            pub fn direction0(&self) -> DIRECTION_R {
                DIRECTION_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Direction 1"]
            #[inline(always)]
            pub fn direction1(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Direction 2"]
            #[inline(always)]
            pub fn direction2(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Direction 3"]
            #[inline(always)]
            pub fn direction3(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Direction 4"]
            #[inline(always)]
            pub fn direction4(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Direction 5"]
            #[inline(always)]
            pub fn direction5(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Direction 6"]
            #[inline(always)]
            pub fn direction6(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Direction 7"]
            #[inline(always)]
            pub fn direction7(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 14) & 3) as u8)
            }
            #[doc = "Bits 16:17 - Direction 8"]
            #[inline(always)]
            pub fn direction8(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bits 18:19 - Direction 9"]
            #[inline(always)]
            pub fn direction9(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 18) & 3) as u8)
            }
            #[doc = "Bits 20:21 - Direction 10"]
            #[inline(always)]
            pub fn direction10(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 20) & 3) as u8)
            }
            #[doc = "Bits 22:23 - Direction 11"]
            #[inline(always)]
            pub fn direction11(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 22) & 3) as u8)
            }
            #[doc = "Bits 24:25 - Direction 12"]
            #[inline(always)]
            pub fn direction12(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 24) & 3) as u8)
            }
            #[doc = "Bits 26:27 - Direction 13"]
            #[inline(always)]
            pub fn direction13(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 26) & 3) as u8)
            }
            #[doc = "Bits 28:29 - Direction 14"]
            #[inline(always)]
            pub fn direction14(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 28) & 3) as u8)
            }
            #[doc = "Bits 30:31 - Direction 15"]
            #[inline(always)]
            pub fn direction15(&self) -> DIRECTION_R {
                DIRECTION_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HW_DIRECTION")
                    .field("direction0", &format_args!("{}", self.direction0().bits()))
                    .field("direction1", &format_args!("{}", self.direction1().bits()))
                    .field("direction2", &format_args!("{}", self.direction2().bits()))
                    .field("direction3", &format_args!("{}", self.direction3().bits()))
                    .field("direction4", &format_args!("{}", self.direction4().bits()))
                    .field("direction5", &format_args!("{}", self.direction5().bits()))
                    .field("direction6", &format_args!("{}", self.direction6().bits()))
                    .field("direction7", &format_args!("{}", self.direction7().bits()))
                    .field("direction8", &format_args!("{}", self.direction8().bits()))
                    .field("direction9", &format_args!("{}", self.direction9().bits()))
                    .field(
                        "direction10",
                        &format_args!("{}", self.direction10().bits()),
                    )
                    .field(
                        "direction11",
                        &format_args!("{}", self.direction11().bits()),
                    )
                    .field(
                        "direction12",
                        &format_args!("{}", self.direction12().bits()),
                    )
                    .field(
                        "direction13",
                        &format_args!("{}", self.direction13().bits()),
                    )
                    .field(
                        "direction14",
                        &format_args!("{}", self.direction14().bits()),
                    )
                    .field(
                        "direction15",
                        &format_args!("{}", self.direction15().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HW_DIRECTION_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Direction\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hw_direction::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HW_DIRECTION_SPEC;
        impl crate::RegisterSpec for HW_DIRECTION_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hw_direction::R`](R) reader structure"]
        impl crate::Readable for HW_DIRECTION_SPEC {}
    }
    #[doc = "HW_CONFIG0 (r) register accessor: Hardware Config 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hw_config0::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hw_config0`]
module"]
    pub type HW_CONFIG0 = crate::Reg<hw_config0::HW_CONFIG0_SPEC>;
    #[doc = "Hardware Config 0"]
    pub mod hw_config0 {
        #[doc = "Register `HW_CONFIG0` reader"]
        pub type R = crate::R<HW_CONFIG0_SPEC>;
        #[doc = "Field `OPERATING_MODE` reader - Operating Mode"]
        pub type OPERATING_MODE_R = crate::FieldReader<OPERATING_MODE_A>;
        #[doc = "Operating Mode"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OPERATING_MODE_A {
            #[doc = "0: `0`"]
            HNP_SRP_CAPABLE = 0,
            #[doc = "1: `1`"]
            SRP_ONLY_CAPABLE = 1,
            #[doc = "2: `10`"]
            NO_HNP_SRP_CAPABLE = 2,
            #[doc = "3: `11`"]
            SRP_CAPABLE_DEVICE = 3,
            #[doc = "4: `100`"]
            NO_SRP_CAPABLE_DEVICE = 4,
            #[doc = "5: `101`"]
            SRP_CAPABLE_HOST = 5,
            #[doc = "6: `110`"]
            NO_SRP_CAPABLE_HOST = 6,
        }
        impl From<OPERATING_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: OPERATING_MODE_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for OPERATING_MODE_A {
            type Ux = u8;
        }
        impl OPERATING_MODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<OPERATING_MODE_A> {
                match self.bits {
                    0 => Some(OPERATING_MODE_A::HNP_SRP_CAPABLE),
                    1 => Some(OPERATING_MODE_A::SRP_ONLY_CAPABLE),
                    2 => Some(OPERATING_MODE_A::NO_HNP_SRP_CAPABLE),
                    3 => Some(OPERATING_MODE_A::SRP_CAPABLE_DEVICE),
                    4 => Some(OPERATING_MODE_A::NO_SRP_CAPABLE_DEVICE),
                    5 => Some(OPERATING_MODE_A::SRP_CAPABLE_HOST),
                    6 => Some(OPERATING_MODE_A::NO_SRP_CAPABLE_HOST),
                    _ => None,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_hnp_srp_capable(&self) -> bool {
                *self == OPERATING_MODE_A::HNP_SRP_CAPABLE
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_srp_only_capable(&self) -> bool {
                *self == OPERATING_MODE_A::SRP_ONLY_CAPABLE
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_no_hnp_srp_capable(&self) -> bool {
                *self == OPERATING_MODE_A::NO_HNP_SRP_CAPABLE
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_srp_capable_device(&self) -> bool {
                *self == OPERATING_MODE_A::SRP_CAPABLE_DEVICE
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn is_no_srp_capable_device(&self) -> bool {
                *self == OPERATING_MODE_A::NO_SRP_CAPABLE_DEVICE
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn is_srp_capable_host(&self) -> bool {
                *self == OPERATING_MODE_A::SRP_CAPABLE_HOST
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn is_no_srp_capable_host(&self) -> bool {
                *self == OPERATING_MODE_A::NO_SRP_CAPABLE_HOST
            }
        }
        #[doc = "Field `ARCHITECTURE` reader - Architecture"]
        pub type ARCHITECTURE_R = crate::FieldReader<ARCHITECTURE_A>;
        #[doc = "Architecture"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ARCHITECTURE_A {
            #[doc = "0: `0`"]
            SLAVE_ONLY = 0,
            #[doc = "1: `1`"]
            EXTERNAL_DMA = 1,
            #[doc = "2: `10`"]
            INTERNAL_DMA = 2,
        }
        impl From<ARCHITECTURE_A> for u8 {
            #[inline(always)]
            fn from(variant: ARCHITECTURE_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ARCHITECTURE_A {
            type Ux = u8;
        }
        impl ARCHITECTURE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<ARCHITECTURE_A> {
                match self.bits {
                    0 => Some(ARCHITECTURE_A::SLAVE_ONLY),
                    1 => Some(ARCHITECTURE_A::EXTERNAL_DMA),
                    2 => Some(ARCHITECTURE_A::INTERNAL_DMA),
                    _ => None,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_slave_only(&self) -> bool {
                *self == ARCHITECTURE_A::SLAVE_ONLY
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_external_dma(&self) -> bool {
                *self == ARCHITECTURE_A::EXTERNAL_DMA
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_internal_dma(&self) -> bool {
                *self == ARCHITECTURE_A::INTERNAL_DMA
            }
        }
        #[doc = "Field `POINT_TO_POINT` reader - Point to Point"]
        pub type POINT_TO_POINT_R = crate::BitReader;
        #[doc = "Field `HIGH_SPEED_PHY` reader - High Speed Physical"]
        pub type HIGH_SPEED_PHY_R = crate::FieldReader<HIGH_SPEED_PHY_A>;
        #[doc = "High Speed Physical"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum HIGH_SPEED_PHY_A {
            #[doc = "0: `0`"]
            NOT_SUPPORTED = 0,
            #[doc = "1: `1`"]
            UTMI = 1,
            #[doc = "2: `10`"]
            ULPI = 2,
            #[doc = "3: `11`"]
            UTMI_ULPI = 3,
        }
        impl From<HIGH_SPEED_PHY_A> for u8 {
            #[inline(always)]
            fn from(variant: HIGH_SPEED_PHY_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for HIGH_SPEED_PHY_A {
            type Ux = u8;
        }
        impl HIGH_SPEED_PHY_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> HIGH_SPEED_PHY_A {
                match self.bits {
                    0 => HIGH_SPEED_PHY_A::NOT_SUPPORTED,
                    1 => HIGH_SPEED_PHY_A::UTMI,
                    2 => HIGH_SPEED_PHY_A::ULPI,
                    3 => HIGH_SPEED_PHY_A::UTMI_ULPI,
                    _ => unreachable!(),
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_not_supported(&self) -> bool {
                *self == HIGH_SPEED_PHY_A::NOT_SUPPORTED
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_utmi(&self) -> bool {
                *self == HIGH_SPEED_PHY_A::UTMI
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_ulpi(&self) -> bool {
                *self == HIGH_SPEED_PHY_A::ULPI
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_utmi_ulpi(&self) -> bool {
                *self == HIGH_SPEED_PHY_A::UTMI_ULPI
            }
        }
        #[doc = "Field `FULL_SPEED_PHY` reader - Full Speed Physical"]
        pub type FULL_SPEED_PHY_R = crate::FieldReader<FULL_SPEED_PHY_A>;
        #[doc = "Full Speed Physical"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FULL_SPEED_PHY_A {
            #[doc = "0: `0`"]
            PHY0 = 0,
            #[doc = "1: `1`"]
            DEDICATED = 1,
            #[doc = "2: `10`"]
            PHY2 = 2,
            #[doc = "3: `11`"]
            PHY3 = 3,
        }
        impl From<FULL_SPEED_PHY_A> for u8 {
            #[inline(always)]
            fn from(variant: FULL_SPEED_PHY_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FULL_SPEED_PHY_A {
            type Ux = u8;
        }
        impl FULL_SPEED_PHY_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FULL_SPEED_PHY_A {
                match self.bits {
                    0 => FULL_SPEED_PHY_A::PHY0,
                    1 => FULL_SPEED_PHY_A::DEDICATED,
                    2 => FULL_SPEED_PHY_A::PHY2,
                    3 => FULL_SPEED_PHY_A::PHY3,
                    _ => unreachable!(),
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_phy0(&self) -> bool {
                *self == FULL_SPEED_PHY_A::PHY0
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_dedicated(&self) -> bool {
                *self == FULL_SPEED_PHY_A::DEDICATED
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_phy2(&self) -> bool {
                *self == FULL_SPEED_PHY_A::PHY2
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_phy3(&self) -> bool {
                *self == FULL_SPEED_PHY_A::PHY3
            }
        }
        #[doc = "Field `DEVICE_END_POINT_COUNT` reader - Device end point count"]
        pub type DEVICE_END_POINT_COUNT_R = crate::FieldReader;
        #[doc = "Field `HOST_CHANNEL_COUNT` reader - Host channel count"]
        pub type HOST_CHANNEL_COUNT_R = crate::FieldReader;
        #[doc = "Field `SUPPORTS_PERIODIC_ENDPOINTS` reader - Supports periodic endpoints"]
        pub type SUPPORTS_PERIODIC_ENDPOINTS_R = crate::BitReader;
        #[doc = "Field `DYNAMIC_FIFO` reader - Dynamic FIFO"]
        pub type DYNAMIC_FIFO_R = crate::BitReader;
        #[doc = "Field `MULTI_PROC_INT` reader - Multi proc int"]
        pub type MULTI_PROC_INT_R = crate::BitReader;
        #[doc = "Field `NON_PERIODIC_QUEUE_DEPTH` reader - Non periodic queue depth"]
        pub type NON_PERIODIC_QUEUE_DEPTH_R = crate::FieldReader;
        #[doc = "Field `HOST_PERIODIC_QUEUE_DEPTH` reader - Host periodic queue depth"]
        pub type HOST_PERIODIC_QUEUE_DEPTH_R = crate::FieldReader;
        #[doc = "Field `DEVICE_TOKEN_QUEUE_DEPTH` reader - Device token queue depth"]
        pub type DEVICE_TOKEN_QUEUE_DEPTH_R = crate::FieldReader;
        #[doc = "Field `ENABLE_IC_USB` reader - Enable IC USB"]
        pub type ENABLE_IC_USB_R = crate::BitReader;
        impl R {
            #[doc = "Bits 0:2 - Operating Mode"]
            #[inline(always)]
            pub fn operating_mode(&self) -> OPERATING_MODE_R {
                OPERATING_MODE_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:4 - Architecture"]
            #[inline(always)]
            pub fn architecture(&self) -> ARCHITECTURE_R {
                ARCHITECTURE_R::new(((self.bits >> 3) & 3) as u8)
            }
            #[doc = "Bit 5 - Point to Point"]
            #[inline(always)]
            pub fn point_to_point(&self) -> POINT_TO_POINT_R {
                POINT_TO_POINT_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bits 6:7 - High Speed Physical"]
            #[inline(always)]
            pub fn high_speed_phy(&self) -> HIGH_SPEED_PHY_R {
                HIGH_SPEED_PHY_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Full Speed Physical"]
            #[inline(always)]
            pub fn full_speed_phy(&self) -> FULL_SPEED_PHY_R {
                FULL_SPEED_PHY_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:13 - Device end point count"]
            #[inline(always)]
            pub fn device_end_point_count(&self) -> DEVICE_END_POINT_COUNT_R {
                DEVICE_END_POINT_COUNT_R::new(((self.bits >> 10) & 0x0f) as u8)
            }
            #[doc = "Bits 14:17 - Host channel count"]
            #[inline(always)]
            pub fn host_channel_count(&self) -> HOST_CHANNEL_COUNT_R {
                HOST_CHANNEL_COUNT_R::new(((self.bits >> 14) & 0x0f) as u8)
            }
            #[doc = "Bit 18 - Supports periodic endpoints"]
            #[inline(always)]
            pub fn supports_periodic_endpoints(&self) -> SUPPORTS_PERIODIC_ENDPOINTS_R {
                SUPPORTS_PERIODIC_ENDPOINTS_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Dynamic FIFO"]
            #[inline(always)]
            pub fn dynamic_fifo(&self) -> DYNAMIC_FIFO_R {
                DYNAMIC_FIFO_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Multi proc int"]
            #[inline(always)]
            pub fn multi_proc_int(&self) -> MULTI_PROC_INT_R {
                MULTI_PROC_INT_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bits 22:23 - Non periodic queue depth"]
            #[inline(always)]
            pub fn non_periodic_queue_depth(&self) -> NON_PERIODIC_QUEUE_DEPTH_R {
                NON_PERIODIC_QUEUE_DEPTH_R::new(((self.bits >> 22) & 3) as u8)
            }
            #[doc = "Bits 24:25 - Host periodic queue depth"]
            #[inline(always)]
            pub fn host_periodic_queue_depth(&self) -> HOST_PERIODIC_QUEUE_DEPTH_R {
                HOST_PERIODIC_QUEUE_DEPTH_R::new(((self.bits >> 24) & 3) as u8)
            }
            #[doc = "Bits 26:30 - Device token queue depth"]
            #[inline(always)]
            pub fn device_token_queue_depth(&self) -> DEVICE_TOKEN_QUEUE_DEPTH_R {
                DEVICE_TOKEN_QUEUE_DEPTH_R::new(((self.bits >> 26) & 0x1f) as u8)
            }
            #[doc = "Bit 31 - Enable IC USB"]
            #[inline(always)]
            pub fn enable_ic_usb(&self) -> ENABLE_IC_USB_R {
                ENABLE_IC_USB_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HW_CONFIG0")
                    .field(
                        "operating_mode",
                        &format_args!("{}", self.operating_mode().bits()),
                    )
                    .field(
                        "architecture",
                        &format_args!("{}", self.architecture().bits()),
                    )
                    .field(
                        "point_to_point",
                        &format_args!("{}", self.point_to_point().bit()),
                    )
                    .field(
                        "high_speed_phy",
                        &format_args!("{}", self.high_speed_phy().bits()),
                    )
                    .field(
                        "full_speed_phy",
                        &format_args!("{}", self.full_speed_phy().bits()),
                    )
                    .field(
                        "device_end_point_count",
                        &format_args!("{}", self.device_end_point_count().bits()),
                    )
                    .field(
                        "host_channel_count",
                        &format_args!("{}", self.host_channel_count().bits()),
                    )
                    .field(
                        "supports_periodic_endpoints",
                        &format_args!("{}", self.supports_periodic_endpoints().bit()),
                    )
                    .field(
                        "dynamic_fifo",
                        &format_args!("{}", self.dynamic_fifo().bit()),
                    )
                    .field(
                        "multi_proc_int",
                        &format_args!("{}", self.multi_proc_int().bit()),
                    )
                    .field(
                        "non_periodic_queue_depth",
                        &format_args!("{}", self.non_periodic_queue_depth().bits()),
                    )
                    .field(
                        "host_periodic_queue_depth",
                        &format_args!("{}", self.host_periodic_queue_depth().bits()),
                    )
                    .field(
                        "device_token_queue_depth",
                        &format_args!("{}", self.device_token_queue_depth().bits()),
                    )
                    .field(
                        "enable_ic_usb",
                        &format_args!("{}", self.enable_ic_usb().bit()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HW_CONFIG0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "Hardware Config 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hw_config0::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HW_CONFIG0_SPEC;
        impl crate::RegisterSpec for HW_CONFIG0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hw_config0::R`](R) reader structure"]
        impl crate::Readable for HW_CONFIG0_SPEC {}
    }
    #[doc = "HPTXFSIZ (rw) register accessor: OTG_HS Host periodic transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hptxfsiz::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hptxfsiz::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hptxfsiz`]
module"]
    pub type HPTXFSIZ = crate::Reg<hptxfsiz::HPTXFSIZ_SPEC>;
    #[doc = "OTG_HS Host periodic transmit FIFO size register"]
    pub mod hptxfsiz {
        #[doc = "Register `HPTXFSIZ` reader"]
        pub type R = crate::R<HPTXFSIZ_SPEC>;
        #[doc = "Register `HPTXFSIZ` writer"]
        pub type W = crate::W<HPTXFSIZ_SPEC>;
        #[doc = "Field `PTXSA` reader - Host periodic TxFIFO start address"]
        pub type PTXSA_R = crate::FieldReader<u16>;
        #[doc = "Field `PTXSA` writer - Host periodic TxFIFO start address"]
        pub type PTXSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `PTXFD` reader - Host periodic TxFIFO depth"]
        pub type PTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `PTXFD` writer - Host periodic TxFIFO depth"]
        pub type PTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Host periodic TxFIFO start address"]
            #[inline(always)]
            pub fn ptxsa(&self) -> PTXSA_R {
                PTXSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Host periodic TxFIFO depth"]
            #[inline(always)]
            pub fn ptxfd(&self) -> PTXFD_R {
                PTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HPTXFSIZ")
                    .field("ptxsa", &format_args!("{}", self.ptxsa().bits()))
                    .field("ptxfd", &format_args!("{}", self.ptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HPTXFSIZ_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Host periodic TxFIFO start address"]
            #[inline(always)]
            #[must_use]
            pub fn ptxsa(&mut self) -> PTXSA_W<HPTXFSIZ_SPEC, 0> {
                PTXSA_W::new(self)
            }
            #[doc = "Bits 16:31 - Host periodic TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn ptxfd(&mut self) -> PTXFD_W<HPTXFSIZ_SPEC, 16> {
                PTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS Host periodic transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hptxfsiz::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hptxfsiz::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HPTXFSIZ_SPEC;
        impl crate::RegisterSpec for HPTXFSIZ_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hptxfsiz::R`](R) reader structure"]
        impl crate::Readable for HPTXFSIZ_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`hptxfsiz::W`](W) writer structure"]
        impl crate::Writable for HPTXFSIZ_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets HPTXFSIZ to value 0x0200_0600"]
        impl crate::Resettable for HPTXFSIZ_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200_0600;
        }
    }
    #[doc = "DIEPTXF1 (rw) register accessor: OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptxf1`]
module"]
    pub type DIEPTXF1 = crate::Reg<dieptxf1::DIEPTXF1_SPEC>;
    #[doc = "OTG_HS device IN endpoint transmit FIFO size register"]
    pub mod dieptxf1 {
        #[doc = "Register `DIEPTXF1` reader"]
        pub type R = crate::R<DIEPTXF1_SPEC>;
        #[doc = "Register `DIEPTXF1` writer"]
        pub type W = crate::W<DIEPTXF1_SPEC>;
        #[doc = "Field `INEPTXSA` reader - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXSA` writer - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            pub fn ineptxsa(&self) -> INEPTXSA_R {
                INEPTXSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            pub fn ineptxfd(&self) -> INEPTXFD_R {
                INEPTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPTXF1")
                    .field("ineptxsa", &format_args!("{}", self.ineptxsa().bits()))
                    .field("ineptxfd", &format_args!("{}", self.ineptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPTXF1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxsa(&mut self) -> INEPTXSA_W<DIEPTXF1_SPEC, 0> {
                INEPTXSA_W::new(self)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxfd(&mut self) -> INEPTXFD_W<DIEPTXF1_SPEC, 16> {
                INEPTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPTXF1_SPEC;
        impl crate::RegisterSpec for DIEPTXF1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dieptxf1::R`](R) reader structure"]
        impl crate::Readable for DIEPTXF1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dieptxf1::W`](W) writer structure"]
        impl crate::Writable for DIEPTXF1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPTXF1 to value 0x0200_0400"]
        impl crate::Resettable for DIEPTXF1_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200_0400;
        }
    }
    #[doc = "DIEPTXF2 (rw) register accessor: OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptxf2`]
module"]
    pub type DIEPTXF2 = crate::Reg<dieptxf2::DIEPTXF2_SPEC>;
    #[doc = "OTG_HS device IN endpoint transmit FIFO size register"]
    pub mod dieptxf2 {
        #[doc = "Register `DIEPTXF2` reader"]
        pub type R = crate::R<DIEPTXF2_SPEC>;
        #[doc = "Register `DIEPTXF2` writer"]
        pub type W = crate::W<DIEPTXF2_SPEC>;
        #[doc = "Field `INEPTXSA` reader - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXSA` writer - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            pub fn ineptxsa(&self) -> INEPTXSA_R {
                INEPTXSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            pub fn ineptxfd(&self) -> INEPTXFD_R {
                INEPTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPTXF2")
                    .field("ineptxsa", &format_args!("{}", self.ineptxsa().bits()))
                    .field("ineptxfd", &format_args!("{}", self.ineptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPTXF2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxsa(&mut self) -> INEPTXSA_W<DIEPTXF2_SPEC, 0> {
                INEPTXSA_W::new(self)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxfd(&mut self) -> INEPTXFD_W<DIEPTXF2_SPEC, 16> {
                INEPTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPTXF2_SPEC;
        impl crate::RegisterSpec for DIEPTXF2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dieptxf2::R`](R) reader structure"]
        impl crate::Readable for DIEPTXF2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dieptxf2::W`](W) writer structure"]
        impl crate::Writable for DIEPTXF2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPTXF2 to value 0x0200_0400"]
        impl crate::Resettable for DIEPTXF2_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200_0400;
        }
    }
    #[doc = "DIEPTXF3 (rw) register accessor: OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptxf3`]
module"]
    pub type DIEPTXF3 = crate::Reg<dieptxf3::DIEPTXF3_SPEC>;
    #[doc = "OTG_HS device IN endpoint transmit FIFO size register"]
    pub mod dieptxf3 {
        #[doc = "Register `DIEPTXF3` reader"]
        pub type R = crate::R<DIEPTXF3_SPEC>;
        #[doc = "Register `DIEPTXF3` writer"]
        pub type W = crate::W<DIEPTXF3_SPEC>;
        #[doc = "Field `INEPTXSA` reader - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXSA` writer - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            pub fn ineptxsa(&self) -> INEPTXSA_R {
                INEPTXSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            pub fn ineptxfd(&self) -> INEPTXFD_R {
                INEPTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPTXF3")
                    .field("ineptxsa", &format_args!("{}", self.ineptxsa().bits()))
                    .field("ineptxfd", &format_args!("{}", self.ineptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPTXF3_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxsa(&mut self) -> INEPTXSA_W<DIEPTXF3_SPEC, 0> {
                INEPTXSA_W::new(self)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxfd(&mut self) -> INEPTXFD_W<DIEPTXF3_SPEC, 16> {
                INEPTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPTXF3_SPEC;
        impl crate::RegisterSpec for DIEPTXF3_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dieptxf3::R`](R) reader structure"]
        impl crate::Readable for DIEPTXF3_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dieptxf3::W`](W) writer structure"]
        impl crate::Writable for DIEPTXF3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPTXF3 to value 0x0200_0400"]
        impl crate::Resettable for DIEPTXF3_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200_0400;
        }
    }
    #[doc = "DIEPTXF4 (rw) register accessor: OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptxf4`]
module"]
    pub type DIEPTXF4 = crate::Reg<dieptxf4::DIEPTXF4_SPEC>;
    #[doc = "OTG_HS device IN endpoint transmit FIFO size register"]
    pub mod dieptxf4 {
        #[doc = "Register `DIEPTXF4` reader"]
        pub type R = crate::R<DIEPTXF4_SPEC>;
        #[doc = "Register `DIEPTXF4` writer"]
        pub type W = crate::W<DIEPTXF4_SPEC>;
        #[doc = "Field `INEPTXSA` reader - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXSA` writer - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            pub fn ineptxsa(&self) -> INEPTXSA_R {
                INEPTXSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            pub fn ineptxfd(&self) -> INEPTXFD_R {
                INEPTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPTXF4")
                    .field("ineptxsa", &format_args!("{}", self.ineptxsa().bits()))
                    .field("ineptxfd", &format_args!("{}", self.ineptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPTXF4_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxsa(&mut self) -> INEPTXSA_W<DIEPTXF4_SPEC, 0> {
                INEPTXSA_W::new(self)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxfd(&mut self) -> INEPTXFD_W<DIEPTXF4_SPEC, 16> {
                INEPTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPTXF4_SPEC;
        impl crate::RegisterSpec for DIEPTXF4_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dieptxf4::R`](R) reader structure"]
        impl crate::Readable for DIEPTXF4_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dieptxf4::W`](W) writer structure"]
        impl crate::Writable for DIEPTXF4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPTXF4 to value 0x0200_0400"]
        impl crate::Resettable for DIEPTXF4_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200_0400;
        }
    }
    #[doc = "DIEPTXF5 (rw) register accessor: OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptxf5`]
module"]
    pub type DIEPTXF5 = crate::Reg<dieptxf5::DIEPTXF5_SPEC>;
    #[doc = "OTG_HS device IN endpoint transmit FIFO size register"]
    pub mod dieptxf5 {
        #[doc = "Register `DIEPTXF5` reader"]
        pub type R = crate::R<DIEPTXF5_SPEC>;
        #[doc = "Register `DIEPTXF5` writer"]
        pub type W = crate::W<DIEPTXF5_SPEC>;
        #[doc = "Field `INEPTXSA` reader - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXSA` writer - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            pub fn ineptxsa(&self) -> INEPTXSA_R {
                INEPTXSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            pub fn ineptxfd(&self) -> INEPTXFD_R {
                INEPTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPTXF5")
                    .field("ineptxsa", &format_args!("{}", self.ineptxsa().bits()))
                    .field("ineptxfd", &format_args!("{}", self.ineptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPTXF5_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxsa(&mut self) -> INEPTXSA_W<DIEPTXF5_SPEC, 0> {
                INEPTXSA_W::new(self)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxfd(&mut self) -> INEPTXFD_W<DIEPTXF5_SPEC, 16> {
                INEPTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPTXF5_SPEC;
        impl crate::RegisterSpec for DIEPTXF5_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dieptxf5::R`](R) reader structure"]
        impl crate::Readable for DIEPTXF5_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dieptxf5::W`](W) writer structure"]
        impl crate::Writable for DIEPTXF5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPTXF5 to value 0x0200_0400"]
        impl crate::Resettable for DIEPTXF5_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200_0400;
        }
    }
    #[doc = "DIEPTXF6 (rw) register accessor: OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptxf6`]
module"]
    pub type DIEPTXF6 = crate::Reg<dieptxf6::DIEPTXF6_SPEC>;
    #[doc = "OTG_HS device IN endpoint transmit FIFO size register"]
    pub mod dieptxf6 {
        #[doc = "Register `DIEPTXF6` reader"]
        pub type R = crate::R<DIEPTXF6_SPEC>;
        #[doc = "Register `DIEPTXF6` writer"]
        pub type W = crate::W<DIEPTXF6_SPEC>;
        #[doc = "Field `INEPTXSA` reader - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXSA` writer - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            pub fn ineptxsa(&self) -> INEPTXSA_R {
                INEPTXSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            pub fn ineptxfd(&self) -> INEPTXFD_R {
                INEPTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPTXF6")
                    .field("ineptxsa", &format_args!("{}", self.ineptxsa().bits()))
                    .field("ineptxfd", &format_args!("{}", self.ineptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPTXF6_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxsa(&mut self) -> INEPTXSA_W<DIEPTXF6_SPEC, 0> {
                INEPTXSA_W::new(self)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxfd(&mut self) -> INEPTXFD_W<DIEPTXF6_SPEC, 16> {
                INEPTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPTXF6_SPEC;
        impl crate::RegisterSpec for DIEPTXF6_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dieptxf6::R`](R) reader structure"]
        impl crate::Readable for DIEPTXF6_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dieptxf6::W`](W) writer structure"]
        impl crate::Writable for DIEPTXF6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPTXF6 to value 0x0200_0400"]
        impl crate::Resettable for DIEPTXF6_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200_0400;
        }
    }
    #[doc = "DIEPTXF7 (rw) register accessor: OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptxf7`]
module"]
    pub type DIEPTXF7 = crate::Reg<dieptxf7::DIEPTXF7_SPEC>;
    #[doc = "OTG_HS device IN endpoint transmit FIFO size register"]
    pub mod dieptxf7 {
        #[doc = "Register `DIEPTXF7` reader"]
        pub type R = crate::R<DIEPTXF7_SPEC>;
        #[doc = "Register `DIEPTXF7` writer"]
        pub type W = crate::W<DIEPTXF7_SPEC>;
        #[doc = "Field `INEPTXSA` reader - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXSA` writer - IN endpoint FIFOx transmit RAM start address"]
        pub type INEPTXSA_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"]
        pub type INEPTXFD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            pub fn ineptxsa(&self) -> INEPTXSA_R {
                INEPTXSA_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            pub fn ineptxfd(&self) -> INEPTXFD_R {
                INEPTXFD_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPTXF7")
                    .field("ineptxsa", &format_args!("{}", self.ineptxsa().bits()))
                    .field("ineptxfd", &format_args!("{}", self.ineptxfd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPTXF7_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxsa(&mut self) -> INEPTXSA_W<DIEPTXF7_SPEC, 0> {
                INEPTXSA_W::new(self)
            }
            #[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxfd(&mut self) -> INEPTXFD_W<DIEPTXF7_SPEC, 16> {
                INEPTXFD_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint transmit FIFO size register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptxf7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptxf7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPTXF7_SPEC;
        impl crate::RegisterSpec for DIEPTXF7_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dieptxf7::R`](R) reader structure"]
        impl crate::Readable for DIEPTXF7_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dieptxf7::W`](W) writer structure"]
        impl crate::Writable for DIEPTXF7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPTXF7 to value 0x0200_0400"]
        impl crate::Resettable for DIEPTXF7_SPEC {
            const RESET_VALUE: Self::Ux = 0x0200_0400;
        }
    }
    #[doc = "GRXSTSR_Peripheral (r) register accessor: OTG_HS Receive status debug read register (peripheral mode mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxstsr_peripheral::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@grxstsr_peripheral`]
module"]
    pub type GRXSTSR_PERIPHERAL = crate::Reg<grxstsr_peripheral::GRXSTSR_PERIPHERAL_SPEC>;
    #[doc = "OTG_HS Receive status debug read register (peripheral mode mode)"]
    pub mod grxstsr_peripheral {
        #[doc = "Register `GRXSTSR_Peripheral` reader"]
        pub type R = crate::R<GRXSTSR_PERIPHERAL_SPEC>;
        #[doc = "Field `EPNUM` reader - Endpoint number"]
        pub type EPNUM_R = crate::FieldReader;
        #[doc = "Field `BCNT` reader - Byte count"]
        pub type BCNT_R = crate::FieldReader<u16>;
        #[doc = "Field `DPID` reader - Data PID"]
        pub type DPID_R = crate::FieldReader;
        #[doc = "Field `PKTSTS` reader - Packet status"]
        pub type PKTSTS_R = crate::FieldReader;
        #[doc = "Field `FRMNUM` reader - Frame number"]
        pub type FRMNUM_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:3 - Endpoint number"]
            #[inline(always)]
            pub fn epnum(&self) -> EPNUM_R {
                EPNUM_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:14 - Byte count"]
            #[inline(always)]
            pub fn bcnt(&self) -> BCNT_R {
                BCNT_R::new(((self.bits >> 4) & 0x07ff) as u16)
            }
            #[doc = "Bits 15:16 - Data PID"]
            #[inline(always)]
            pub fn dpid(&self) -> DPID_R {
                DPID_R::new(((self.bits >> 15) & 3) as u8)
            }
            #[doc = "Bits 17:20 - Packet status"]
            #[inline(always)]
            pub fn pktsts(&self) -> PKTSTS_R {
                PKTSTS_R::new(((self.bits >> 17) & 0x0f) as u8)
            }
            #[doc = "Bits 21:24 - Frame number"]
            #[inline(always)]
            pub fn frmnum(&self) -> FRMNUM_R {
                FRMNUM_R::new(((self.bits >> 21) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GRXSTSR_Peripheral")
                    .field("epnum", &format_args!("{}", self.epnum().bits()))
                    .field("bcnt", &format_args!("{}", self.bcnt().bits()))
                    .field("dpid", &format_args!("{}", self.dpid().bits()))
                    .field("pktsts", &format_args!("{}", self.pktsts().bits()))
                    .field("frmnum", &format_args!("{}", self.frmnum().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GRXSTSR_PERIPHERAL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS Receive status debug read register (peripheral mode mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxstsr_peripheral::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GRXSTSR_PERIPHERAL_SPEC;
        impl crate::RegisterSpec for GRXSTSR_PERIPHERAL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`grxstsr_peripheral::R`](R) reader structure"]
        impl crate::Readable for GRXSTSR_PERIPHERAL_SPEC {}
        #[doc = "`reset()` method sets GRXSTSR_Peripheral to value 0"]
        impl crate::Resettable for GRXSTSR_PERIPHERAL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "GRXSTSP_Peripheral (r) register accessor: OTG_HS status read and pop register (peripheral mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxstsp_peripheral::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@grxstsp_peripheral`]
module"]
    pub type GRXSTSP_PERIPHERAL = crate::Reg<grxstsp_peripheral::GRXSTSP_PERIPHERAL_SPEC>;
    #[doc = "OTG_HS status read and pop register (peripheral mode)"]
    pub mod grxstsp_peripheral {
        #[doc = "Register `GRXSTSP_Peripheral` reader"]
        pub type R = crate::R<GRXSTSP_PERIPHERAL_SPEC>;
        #[doc = "Field `EPNUM` reader - Endpoint number"]
        pub type EPNUM_R = crate::FieldReader;
        #[doc = "Field `BCNT` reader - Byte count"]
        pub type BCNT_R = crate::FieldReader<u16>;
        #[doc = "Field `DPID` reader - Data PID"]
        pub type DPID_R = crate::FieldReader;
        #[doc = "Field `PKTSTS` reader - Packet status"]
        pub type PKTSTS_R = crate::FieldReader;
        #[doc = "Field `FRMNUM` reader - Frame number"]
        pub type FRMNUM_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:3 - Endpoint number"]
            #[inline(always)]
            pub fn epnum(&self) -> EPNUM_R {
                EPNUM_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:14 - Byte count"]
            #[inline(always)]
            pub fn bcnt(&self) -> BCNT_R {
                BCNT_R::new(((self.bits >> 4) & 0x07ff) as u16)
            }
            #[doc = "Bits 15:16 - Data PID"]
            #[inline(always)]
            pub fn dpid(&self) -> DPID_R {
                DPID_R::new(((self.bits >> 15) & 3) as u8)
            }
            #[doc = "Bits 17:20 - Packet status"]
            #[inline(always)]
            pub fn pktsts(&self) -> PKTSTS_R {
                PKTSTS_R::new(((self.bits >> 17) & 0x0f) as u8)
            }
            #[doc = "Bits 21:24 - Frame number"]
            #[inline(always)]
            pub fn frmnum(&self) -> FRMNUM_R {
                FRMNUM_R::new(((self.bits >> 21) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GRXSTSP_Peripheral")
                    .field("epnum", &format_args!("{}", self.epnum().bits()))
                    .field("bcnt", &format_args!("{}", self.bcnt().bits()))
                    .field("dpid", &format_args!("{}", self.dpid().bits()))
                    .field("pktsts", &format_args!("{}", self.pktsts().bits()))
                    .field("frmnum", &format_args!("{}", self.frmnum().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<GRXSTSP_PERIPHERAL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS status read and pop register (peripheral mode)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`grxstsp_peripheral::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GRXSTSP_PERIPHERAL_SPEC;
        impl crate::RegisterSpec for GRXSTSP_PERIPHERAL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`grxstsp_peripheral::R`](R) reader structure"]
        impl crate::Readable for GRXSTSP_PERIPHERAL_SPEC {}
        #[doc = "`reset()` method sets GRXSTSP_Peripheral to value 0"]
        impl crate::Resettable for GRXSTSP_PERIPHERAL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "USB on the go high speed"]
pub struct USB_OTG_HOST {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB_OTG_HOST {}
impl USB_OTG_HOST {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb_otg_host::RegisterBlock = 0x2098_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb_otg_host::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB_OTG_HOST {
    type Target = usb_otg_host::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB_OTG_HOST {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB_OTG_HOST").finish()
    }
}
#[doc = "USB on the go high speed"]
pub mod usb_otg_host {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - OTG_HS host configuration register"]
        pub hcfg: HCFG,
        #[doc = "0x04 - OTG_HS Host frame interval register"]
        pub hfir: HFIR,
        #[doc = "0x08 - OTG_HS host frame number/frame time remaining register"]
        pub hfnum: HFNUM,
        _reserved3: [u8; 0x04],
        #[doc = "0x10 - Host periodic transmit FIFO/queue status register"]
        pub hptxsts: HPTXSTS,
        #[doc = "0x14 - OTG_HS Host all channels interrupt register"]
        pub haint: HAINT,
        #[doc = "0x18 - OTG_HS host all channels interrupt mask register"]
        pub haintmsk: HAINTMSK,
        _reserved6: [u8; 0x24],
        #[doc = "0x40 - OTG_HS host port control and status register"]
        pub hprt: HPRT,
        _reserved7: [u8; 0xbc],
        #[doc = "0x100..0x118 - Host channel %s"]
        pub host_channel0: HOST_CHANNEL,
        _reserved8: [u8; 0x08],
        #[doc = "0x120..0x138 - Host channel %s"]
        pub host_channel1: HOST_CHANNEL,
        _reserved9: [u8; 0x08],
        #[doc = "0x140..0x158 - Host channel %s"]
        pub host_channel2: HOST_CHANNEL,
        _reserved10: [u8; 0x08],
        #[doc = "0x160..0x178 - Host channel %s"]
        pub host_channel3: HOST_CHANNEL,
        _reserved11: [u8; 0x08],
        #[doc = "0x180..0x198 - Host channel %s"]
        pub host_channel4: HOST_CHANNEL,
        _reserved12: [u8; 0x08],
        #[doc = "0x1a0..0x1b8 - Host channel %s"]
        pub host_channel5: HOST_CHANNEL,
        _reserved13: [u8; 0x08],
        #[doc = "0x1c0..0x1d8 - Host channel %s"]
        pub host_channel6: HOST_CHANNEL,
        _reserved14: [u8; 0x08],
        #[doc = "0x1e0..0x1f8 - Host channel %s"]
        pub host_channel7: HOST_CHANNEL,
        _reserved15: [u8; 0x08],
        #[doc = "0x200..0x218 - Host channel %s"]
        pub host_channel8: HOST_CHANNEL,
        _reserved16: [u8; 0x08],
        #[doc = "0x220..0x238 - Host channel %s"]
        pub host_channel9: HOST_CHANNEL,
        _reserved17: [u8; 0x08],
        #[doc = "0x240..0x258 - Host channel %s"]
        pub host_channel10: HOST_CHANNEL,
        _reserved18: [u8; 0x08],
        #[doc = "0x260..0x278 - Host channel %s"]
        pub host_channel11: HOST_CHANNEL,
    }
    #[doc = "HCFG (rw) register accessor: OTG_HS host configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hcfg`]
module"]
    pub type HCFG = crate::Reg<hcfg::HCFG_SPEC>;
    #[doc = "OTG_HS host configuration register"]
    pub mod hcfg {
        #[doc = "Register `HCFG` reader"]
        pub type R = crate::R<HCFG_SPEC>;
        #[doc = "Register `HCFG` writer"]
        pub type W = crate::W<HCFG_SPEC>;
        #[doc = "Field `FSLSPCS` reader - FS/LS PHY clock select"]
        pub type FSLSPCS_R = crate::FieldReader;
        #[doc = "Field `FSLSPCS` writer - FS/LS PHY clock select"]
        pub type FSLSPCS_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        #[doc = "Field `FSLSS` reader - FS- and LS-only support"]
        pub type FSLSS_R = crate::BitReader;
        impl R {
            #[doc = "Bits 0:1 - FS/LS PHY clock select"]
            #[inline(always)]
            pub fn fslspcs(&self) -> FSLSPCS_R {
                FSLSPCS_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - FS- and LS-only support"]
            #[inline(always)]
            pub fn fslss(&self) -> FSLSS_R {
                FSLSS_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HCFG")
                    .field("fslspcs", &format_args!("{}", self.fslspcs().bits()))
                    .field("fslss", &format_args!("{}", self.fslss().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HCFG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - FS/LS PHY clock select"]
            #[inline(always)]
            #[must_use]
            pub fn fslspcs(&mut self) -> FSLSPCS_W<HCFG_SPEC, 0> {
                FSLSPCS_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS host configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HCFG_SPEC;
        impl crate::RegisterSpec for HCFG_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hcfg::R`](R) reader structure"]
        impl crate::Readable for HCFG_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`hcfg::W`](W) writer structure"]
        impl crate::Writable for HCFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets HCFG to value 0"]
        impl crate::Resettable for HCFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "HFIR (rw) register accessor: OTG_HS Host frame interval register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hfir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hfir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hfir`]
module"]
    pub type HFIR = crate::Reg<hfir::HFIR_SPEC>;
    #[doc = "OTG_HS Host frame interval register"]
    pub mod hfir {
        #[doc = "Register `HFIR` reader"]
        pub type R = crate::R<HFIR_SPEC>;
        #[doc = "Register `HFIR` writer"]
        pub type W = crate::W<HFIR_SPEC>;
        #[doc = "Field `FRIVL` reader - Frame interval"]
        pub type FRIVL_R = crate::FieldReader<u16>;
        #[doc = "Field `FRIVL` writer - Frame interval"]
        pub type FRIVL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Frame interval"]
            #[inline(always)]
            pub fn frivl(&self) -> FRIVL_R {
                FRIVL_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HFIR")
                    .field("frivl", &format_args!("{}", self.frivl().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HFIR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Frame interval"]
            #[inline(always)]
            #[must_use]
            pub fn frivl(&mut self) -> FRIVL_W<HFIR_SPEC, 0> {
                FRIVL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS Host frame interval register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hfir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hfir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HFIR_SPEC;
        impl crate::RegisterSpec for HFIR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hfir::R`](R) reader structure"]
        impl crate::Readable for HFIR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`hfir::W`](W) writer structure"]
        impl crate::Writable for HFIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets HFIR to value 0xea60"]
        impl crate::Resettable for HFIR_SPEC {
            const RESET_VALUE: Self::Ux = 0xea60;
        }
    }
    #[doc = "HFNUM (r) register accessor: OTG_HS host frame number/frame time remaining register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hfnum::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hfnum`]
module"]
    pub type HFNUM = crate::Reg<hfnum::HFNUM_SPEC>;
    #[doc = "OTG_HS host frame number/frame time remaining register"]
    pub mod hfnum {
        #[doc = "Register `HFNUM` reader"]
        pub type R = crate::R<HFNUM_SPEC>;
        #[doc = "Field `FRNUM` reader - Frame number"]
        pub type FRNUM_R = crate::FieldReader<u16>;
        #[doc = "Field `FTREM` reader - Frame time remaining"]
        pub type FTREM_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - Frame number"]
            #[inline(always)]
            pub fn frnum(&self) -> FRNUM_R {
                FRNUM_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Frame time remaining"]
            #[inline(always)]
            pub fn ftrem(&self) -> FTREM_R {
                FTREM_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HFNUM")
                    .field("frnum", &format_args!("{}", self.frnum().bits()))
                    .field("ftrem", &format_args!("{}", self.ftrem().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HFNUM_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS host frame number/frame time remaining register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hfnum::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HFNUM_SPEC;
        impl crate::RegisterSpec for HFNUM_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hfnum::R`](R) reader structure"]
        impl crate::Readable for HFNUM_SPEC {}
        #[doc = "`reset()` method sets HFNUM to value 0x3fff"]
        impl crate::Resettable for HFNUM_SPEC {
            const RESET_VALUE: Self::Ux = 0x3fff;
        }
    }
    #[doc = "HPTXSTS (rw) register accessor: Host periodic transmit FIFO/queue status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hptxsts::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hptxsts::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hptxsts`]
module"]
    pub type HPTXSTS = crate::Reg<hptxsts::HPTXSTS_SPEC>;
    #[doc = "Host periodic transmit FIFO/queue status register"]
    pub mod hptxsts {
        #[doc = "Register `HPTXSTS` reader"]
        pub type R = crate::R<HPTXSTS_SPEC>;
        #[doc = "Register `HPTXSTS` writer"]
        pub type W = crate::W<HPTXSTS_SPEC>;
        #[doc = "Field `PTXFSAVL` reader - Periodic transmit data FIFO space available"]
        pub type PTXFSAVL_R = crate::FieldReader<u16>;
        #[doc = "Field `PTXFSAVL` writer - Periodic transmit data FIFO space available"]
        pub type PTXFSAVL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `PTXQSAV` reader - Periodic transmit request queue space available"]
        pub type PTXQSAV_R = crate::FieldReader;
        #[doc = "Field `PTXQTOP` reader - Top of the periodic transmit request queue"]
        pub type PTXQTOP_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:15 - Periodic transmit data FIFO space available"]
            #[inline(always)]
            pub fn ptxfsavl(&self) -> PTXFSAVL_R {
                PTXFSAVL_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:23 - Periodic transmit request queue space available"]
            #[inline(always)]
            pub fn ptxqsav(&self) -> PTXQSAV_R {
                PTXQSAV_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - Top of the periodic transmit request queue"]
            #[inline(always)]
            pub fn ptxqtop(&self) -> PTXQTOP_R {
                PTXQTOP_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HPTXSTS")
                    .field("ptxfsavl", &format_args!("{}", self.ptxfsavl().bits()))
                    .field("ptxqsav", &format_args!("{}", self.ptxqsav().bits()))
                    .field("ptxqtop", &format_args!("{}", self.ptxqtop().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HPTXSTS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Periodic transmit data FIFO space available"]
            #[inline(always)]
            #[must_use]
            pub fn ptxfsavl(&mut self) -> PTXFSAVL_W<HPTXSTS_SPEC, 0> {
                PTXFSAVL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Host periodic transmit FIFO/queue status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hptxsts::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hptxsts::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HPTXSTS_SPEC;
        impl crate::RegisterSpec for HPTXSTS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hptxsts::R`](R) reader structure"]
        impl crate::Readable for HPTXSTS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`hptxsts::W`](W) writer structure"]
        impl crate::Writable for HPTXSTS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets HPTXSTS to value 0x0008_0100"]
        impl crate::Resettable for HPTXSTS_SPEC {
            const RESET_VALUE: Self::Ux = 0x0008_0100;
        }
    }
    #[doc = "HAINT (r) register accessor: OTG_HS Host all channels interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`haint::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@haint`]
module"]
    pub type HAINT = crate::Reg<haint::HAINT_SPEC>;
    #[doc = "OTG_HS Host all channels interrupt register"]
    pub mod haint {
        #[doc = "Register `HAINT` reader"]
        pub type R = crate::R<HAINT_SPEC>;
        #[doc = "Field `HAINT` reader - Channel interrupts"]
        pub type HAINT_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel interrupts"]
            #[inline(always)]
            pub fn haint(&self) -> HAINT_R {
                HAINT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HAINT")
                    .field("haint", &format_args!("{}", self.haint().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HAINT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS Host all channels interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`haint::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HAINT_SPEC;
        impl crate::RegisterSpec for HAINT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`haint::R`](R) reader structure"]
        impl crate::Readable for HAINT_SPEC {}
        #[doc = "`reset()` method sets HAINT to value 0"]
        impl crate::Resettable for HAINT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "HAINTMSK (rw) register accessor: OTG_HS host all channels interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`haintmsk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`haintmsk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@haintmsk`]
module"]
    pub type HAINTMSK = crate::Reg<haintmsk::HAINTMSK_SPEC>;
    #[doc = "OTG_HS host all channels interrupt mask register"]
    pub mod haintmsk {
        #[doc = "Register `HAINTMSK` reader"]
        pub type R = crate::R<HAINTMSK_SPEC>;
        #[doc = "Register `HAINTMSK` writer"]
        pub type W = crate::W<HAINTMSK_SPEC>;
        #[doc = "Field `HAINTM` reader - Channel interrupt mask"]
        pub type HAINTM_R = crate::FieldReader<u16>;
        #[doc = "Field `HAINTM` writer - Channel interrupt mask"]
        pub type HAINTM_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Channel interrupt mask"]
            #[inline(always)]
            pub fn haintm(&self) -> HAINTM_R {
                HAINTM_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HAINTMSK")
                    .field("haintm", &format_args!("{}", self.haintm().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HAINTMSK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Channel interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn haintm(&mut self) -> HAINTM_W<HAINTMSK_SPEC, 0> {
                HAINTM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS host all channels interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`haintmsk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`haintmsk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HAINTMSK_SPEC;
        impl crate::RegisterSpec for HAINTMSK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`haintmsk::R`](R) reader structure"]
        impl crate::Readable for HAINTMSK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`haintmsk::W`](W) writer structure"]
        impl crate::Writable for HAINTMSK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets HAINTMSK to value 0"]
        impl crate::Resettable for HAINTMSK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "HPRT (rw) register accessor: OTG_HS host port control and status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hprt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hprt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hprt`]
module"]
    pub type HPRT = crate::Reg<hprt::HPRT_SPEC>;
    #[doc = "OTG_HS host port control and status register"]
    pub mod hprt {
        #[doc = "Register `HPRT` reader"]
        pub type R = crate::R<HPRT_SPEC>;
        #[doc = "Register `HPRT` writer"]
        pub type W = crate::W<HPRT_SPEC>;
        #[doc = "Field `PCSTS` reader - Port connect status"]
        pub type PCSTS_R = crate::BitReader;
        #[doc = "Field `PCDET` reader - Port connect detected"]
        pub type PCDET_R = crate::BitReader;
        #[doc = "Field `PCDET` writer - Port connect detected"]
        pub type PCDET_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PENA` reader - Port enable"]
        pub type PENA_R = crate::BitReader;
        #[doc = "Field `PENA` writer - Port enable"]
        pub type PENA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PENCHNG` reader - Port enable/disable change"]
        pub type PENCHNG_R = crate::BitReader;
        #[doc = "Field `PENCHNG` writer - Port enable/disable change"]
        pub type PENCHNG_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `POCA` reader - Port overcurrent active"]
        pub type POCA_R = crate::BitReader;
        #[doc = "Field `POCCHNG` reader - Port overcurrent change"]
        pub type POCCHNG_R = crate::BitReader;
        #[doc = "Field `POCCHNG` writer - Port overcurrent change"]
        pub type POCCHNG_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PRES` reader - Port resume"]
        pub type PRES_R = crate::BitReader;
        #[doc = "Field `PRES` writer - Port resume"]
        pub type PRES_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PSUSP` reader - Port suspend"]
        pub type PSUSP_R = crate::BitReader;
        #[doc = "Field `PSUSP` writer - Port suspend"]
        pub type PSUSP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PRST` reader - Port reset"]
        pub type PRST_R = crate::BitReader;
        #[doc = "Field `PRST` writer - Port reset"]
        pub type PRST_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PLSTS` reader - Port line status"]
        pub type PLSTS_R = crate::FieldReader;
        #[doc = "Field `PPWR` reader - Port power"]
        pub type PPWR_R = crate::BitReader;
        #[doc = "Field `PPWR` writer - Port power"]
        pub type PPWR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PTCTL` reader - Port test control"]
        pub type PTCTL_R = crate::FieldReader;
        #[doc = "Field `PTCTL` writer - Port test control"]
        pub type PTCTL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        #[doc = "Field `PSPD` reader - Port speed"]
        pub type PSPD_R = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - Port connect status"]
            #[inline(always)]
            pub fn pcsts(&self) -> PCSTS_R {
                PCSTS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Port connect detected"]
            #[inline(always)]
            pub fn pcdet(&self) -> PCDET_R {
                PCDET_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Port enable"]
            #[inline(always)]
            pub fn pena(&self) -> PENA_R {
                PENA_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Port enable/disable change"]
            #[inline(always)]
            pub fn penchng(&self) -> PENCHNG_R {
                PENCHNG_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Port overcurrent active"]
            #[inline(always)]
            pub fn poca(&self) -> POCA_R {
                POCA_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Port overcurrent change"]
            #[inline(always)]
            pub fn pocchng(&self) -> POCCHNG_R {
                POCCHNG_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Port resume"]
            #[inline(always)]
            pub fn pres(&self) -> PRES_R {
                PRES_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Port suspend"]
            #[inline(always)]
            pub fn psusp(&self) -> PSUSP_R {
                PSUSP_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Port reset"]
            #[inline(always)]
            pub fn prst(&self) -> PRST_R {
                PRST_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bits 10:11 - Port line status"]
            #[inline(always)]
            pub fn plsts(&self) -> PLSTS_R {
                PLSTS_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bit 12 - Port power"]
            #[inline(always)]
            pub fn ppwr(&self) -> PPWR_R {
                PPWR_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bits 13:16 - Port test control"]
            #[inline(always)]
            pub fn ptctl(&self) -> PTCTL_R {
                PTCTL_R::new(((self.bits >> 13) & 0x0f) as u8)
            }
            #[doc = "Bits 17:18 - Port speed"]
            #[inline(always)]
            pub fn pspd(&self) -> PSPD_R {
                PSPD_R::new(((self.bits >> 17) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HPRT")
                    .field("pcsts", &format_args!("{}", self.pcsts().bit()))
                    .field("pcdet", &format_args!("{}", self.pcdet().bit()))
                    .field("pena", &format_args!("{}", self.pena().bit()))
                    .field("penchng", &format_args!("{}", self.penchng().bit()))
                    .field("poca", &format_args!("{}", self.poca().bit()))
                    .field("pocchng", &format_args!("{}", self.pocchng().bit()))
                    .field("pres", &format_args!("{}", self.pres().bit()))
                    .field("psusp", &format_args!("{}", self.psusp().bit()))
                    .field("prst", &format_args!("{}", self.prst().bit()))
                    .field("plsts", &format_args!("{}", self.plsts().bits()))
                    .field("ppwr", &format_args!("{}", self.ppwr().bit()))
                    .field("ptctl", &format_args!("{}", self.ptctl().bits()))
                    .field("pspd", &format_args!("{}", self.pspd().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<HPRT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - Port connect detected"]
            #[inline(always)]
            #[must_use]
            pub fn pcdet(&mut self) -> PCDET_W<HPRT_SPEC, 1> {
                PCDET_W::new(self)
            }
            #[doc = "Bit 2 - Port enable"]
            #[inline(always)]
            #[must_use]
            pub fn pena(&mut self) -> PENA_W<HPRT_SPEC, 2> {
                PENA_W::new(self)
            }
            #[doc = "Bit 3 - Port enable/disable change"]
            #[inline(always)]
            #[must_use]
            pub fn penchng(&mut self) -> PENCHNG_W<HPRT_SPEC, 3> {
                PENCHNG_W::new(self)
            }
            #[doc = "Bit 5 - Port overcurrent change"]
            #[inline(always)]
            #[must_use]
            pub fn pocchng(&mut self) -> POCCHNG_W<HPRT_SPEC, 5> {
                POCCHNG_W::new(self)
            }
            #[doc = "Bit 6 - Port resume"]
            #[inline(always)]
            #[must_use]
            pub fn pres(&mut self) -> PRES_W<HPRT_SPEC, 6> {
                PRES_W::new(self)
            }
            #[doc = "Bit 7 - Port suspend"]
            #[inline(always)]
            #[must_use]
            pub fn psusp(&mut self) -> PSUSP_W<HPRT_SPEC, 7> {
                PSUSP_W::new(self)
            }
            #[doc = "Bit 8 - Port reset"]
            #[inline(always)]
            #[must_use]
            pub fn prst(&mut self) -> PRST_W<HPRT_SPEC, 8> {
                PRST_W::new(self)
            }
            #[doc = "Bit 12 - Port power"]
            #[inline(always)]
            #[must_use]
            pub fn ppwr(&mut self) -> PPWR_W<HPRT_SPEC, 12> {
                PPWR_W::new(self)
            }
            #[doc = "Bits 13:16 - Port test control"]
            #[inline(always)]
            #[must_use]
            pub fn ptctl(&mut self) -> PTCTL_W<HPRT_SPEC, 13> {
                PTCTL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS host port control and status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hprt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hprt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HPRT_SPEC;
        impl crate::RegisterSpec for HPRT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`hprt::R`](R) reader structure"]
        impl crate::Readable for HPRT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`hprt::W`](W) writer structure"]
        impl crate::Writable for HPRT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets HPRT to value 0"]
        impl crate::Resettable for HPRT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "Host channel %s"]
    pub use self::host_channel::HOST_CHANNEL;
    #[doc = r"Cluster"]
    #[doc = "Host channel %s"]
    pub mod host_channel {
        #[doc = r"Register block"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct HOST_CHANNEL {
            #[doc = "0x00 - Characteristics register"]
            pub hcchar: HCCHAR,
            #[doc = "0x04 - Split control register"]
            pub hcsplt: HCSPLT,
            #[doc = "0x08 - Interrupt register"]
            pub hcint: HCINT,
            #[doc = "0x0c - Interrupt mask"]
            pub hcintmsk: HCINTMSK,
            #[doc = "0x10 - Transfer size"]
            pub hctsiz: HCTSIZ,
            #[doc = "0x14 - DMA address"]
            pub hcdma: HCDMA,
        }
        #[doc = "HCCHAR (rw) register accessor: Characteristics register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcchar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcchar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hcchar`]
module"]
        pub type HCCHAR = crate::Reg<hcchar::HCCHAR_SPEC>;
        #[doc = "Characteristics register"]
        pub mod hcchar {
            #[doc = "Register `HCCHAR` reader"]
            pub type R = crate::R<HCCHAR_SPEC>;
            #[doc = "Register `HCCHAR` writer"]
            pub type W = crate::W<HCCHAR_SPEC>;
            #[doc = "Field `MPSIZ` reader - Maximum packet size"]
            pub type MPSIZ_R = crate::FieldReader<u16>;
            #[doc = "Field `MPSIZ` writer - Maximum packet size"]
            pub type MPSIZ_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 11, O, u16>;
            #[doc = "Field `EPNUM` reader - Endpoint number"]
            pub type EPNUM_R = crate::FieldReader;
            #[doc = "Field `EPNUM` writer - Endpoint number"]
            pub type EPNUM_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
            #[doc = "Field `EPDIR` reader - Endpoint direction"]
            pub type EPDIR_R = crate::BitReader;
            #[doc = "Field `EPDIR` writer - Endpoint direction"]
            pub type EPDIR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `LSDEV` reader - Low-speed device"]
            pub type LSDEV_R = crate::BitReader;
            #[doc = "Field `LSDEV` writer - Low-speed device"]
            pub type LSDEV_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `EPTYP` reader - Endpoint type"]
            pub type EPTYP_R = crate::FieldReader;
            #[doc = "Field `EPTYP` writer - Endpoint type"]
            pub type EPTYP_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
            #[doc = "Field `MC` reader - Multi Count (MC) / Error Count (EC)"]
            pub type MC_R = crate::FieldReader;
            #[doc = "Field `MC` writer - Multi Count (MC) / Error Count (EC)"]
            pub type MC_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
            #[doc = "Field `DAD` reader - Device address"]
            pub type DAD_R = crate::FieldReader;
            #[doc = "Field `DAD` writer - Device address"]
            pub type DAD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 7, O>;
            #[doc = "Field `ODDFRM` reader - Odd frame"]
            pub type ODDFRM_R = crate::BitReader;
            #[doc = "Field `ODDFRM` writer - Odd frame"]
            pub type ODDFRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `CHDIS` reader - Channel disable"]
            pub type CHDIS_R = crate::BitReader;
            #[doc = "Field `CHDIS` writer - Channel disable"]
            pub type CHDIS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `CHENA` reader - Channel enable"]
            pub type CHENA_R = crate::BitReader;
            #[doc = "Field `CHENA` writer - Channel enable"]
            pub type CHENA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            impl R {
                #[doc = "Bits 0:10 - Maximum packet size"]
                #[inline(always)]
                pub fn mpsiz(&self) -> MPSIZ_R {
                    MPSIZ_R::new((self.bits & 0x07ff) as u16)
                }
                #[doc = "Bits 11:14 - Endpoint number"]
                #[inline(always)]
                pub fn epnum(&self) -> EPNUM_R {
                    EPNUM_R::new(((self.bits >> 11) & 0x0f) as u8)
                }
                #[doc = "Bit 15 - Endpoint direction"]
                #[inline(always)]
                pub fn epdir(&self) -> EPDIR_R {
                    EPDIR_R::new(((self.bits >> 15) & 1) != 0)
                }
                #[doc = "Bit 17 - Low-speed device"]
                #[inline(always)]
                pub fn lsdev(&self) -> LSDEV_R {
                    LSDEV_R::new(((self.bits >> 17) & 1) != 0)
                }
                #[doc = "Bits 18:19 - Endpoint type"]
                #[inline(always)]
                pub fn eptyp(&self) -> EPTYP_R {
                    EPTYP_R::new(((self.bits >> 18) & 3) as u8)
                }
                #[doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)"]
                #[inline(always)]
                pub fn mc(&self) -> MC_R {
                    MC_R::new(((self.bits >> 20) & 3) as u8)
                }
                #[doc = "Bits 22:28 - Device address"]
                #[inline(always)]
                pub fn dad(&self) -> DAD_R {
                    DAD_R::new(((self.bits >> 22) & 0x7f) as u8)
                }
                #[doc = "Bit 29 - Odd frame"]
                #[inline(always)]
                pub fn oddfrm(&self) -> ODDFRM_R {
                    ODDFRM_R::new(((self.bits >> 29) & 1) != 0)
                }
                #[doc = "Bit 30 - Channel disable"]
                #[inline(always)]
                pub fn chdis(&self) -> CHDIS_R {
                    CHDIS_R::new(((self.bits >> 30) & 1) != 0)
                }
                #[doc = "Bit 31 - Channel enable"]
                #[inline(always)]
                pub fn chena(&self) -> CHENA_R {
                    CHENA_R::new(((self.bits >> 31) & 1) != 0)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("HCCHAR")
                        .field("mpsiz", &format_args!("{}", self.mpsiz().bits()))
                        .field("epnum", &format_args!("{}", self.epnum().bits()))
                        .field("epdir", &format_args!("{}", self.epdir().bit()))
                        .field("lsdev", &format_args!("{}", self.lsdev().bit()))
                        .field("eptyp", &format_args!("{}", self.eptyp().bits()))
                        .field("mc", &format_args!("{}", self.mc().bits()))
                        .field("dad", &format_args!("{}", self.dad().bits()))
                        .field("oddfrm", &format_args!("{}", self.oddfrm().bit()))
                        .field("chdis", &format_args!("{}", self.chdis().bit()))
                        .field("chena", &format_args!("{}", self.chena().bit()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<HCCHAR_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:10 - Maximum packet size"]
                #[inline(always)]
                #[must_use]
                pub fn mpsiz(&mut self) -> MPSIZ_W<HCCHAR_SPEC, 0> {
                    MPSIZ_W::new(self)
                }
                #[doc = "Bits 11:14 - Endpoint number"]
                #[inline(always)]
                #[must_use]
                pub fn epnum(&mut self) -> EPNUM_W<HCCHAR_SPEC, 11> {
                    EPNUM_W::new(self)
                }
                #[doc = "Bit 15 - Endpoint direction"]
                #[inline(always)]
                #[must_use]
                pub fn epdir(&mut self) -> EPDIR_W<HCCHAR_SPEC, 15> {
                    EPDIR_W::new(self)
                }
                #[doc = "Bit 17 - Low-speed device"]
                #[inline(always)]
                #[must_use]
                pub fn lsdev(&mut self) -> LSDEV_W<HCCHAR_SPEC, 17> {
                    LSDEV_W::new(self)
                }
                #[doc = "Bits 18:19 - Endpoint type"]
                #[inline(always)]
                #[must_use]
                pub fn eptyp(&mut self) -> EPTYP_W<HCCHAR_SPEC, 18> {
                    EPTYP_W::new(self)
                }
                #[doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)"]
                #[inline(always)]
                #[must_use]
                pub fn mc(&mut self) -> MC_W<HCCHAR_SPEC, 20> {
                    MC_W::new(self)
                }
                #[doc = "Bits 22:28 - Device address"]
                #[inline(always)]
                #[must_use]
                pub fn dad(&mut self) -> DAD_W<HCCHAR_SPEC, 22> {
                    DAD_W::new(self)
                }
                #[doc = "Bit 29 - Odd frame"]
                #[inline(always)]
                #[must_use]
                pub fn oddfrm(&mut self) -> ODDFRM_W<HCCHAR_SPEC, 29> {
                    ODDFRM_W::new(self)
                }
                #[doc = "Bit 30 - Channel disable"]
                #[inline(always)]
                #[must_use]
                pub fn chdis(&mut self) -> CHDIS_W<HCCHAR_SPEC, 30> {
                    CHDIS_W::new(self)
                }
                #[doc = "Bit 31 - Channel enable"]
                #[inline(always)]
                #[must_use]
                pub fn chena(&mut self) -> CHENA_W<HCCHAR_SPEC, 31> {
                    CHENA_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Characteristics register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcchar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcchar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct HCCHAR_SPEC;
            impl crate::RegisterSpec for HCCHAR_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`hcchar::R`](R) reader structure"]
            impl crate::Readable for HCCHAR_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`hcchar::W`](W) writer structure"]
            impl crate::Writable for HCCHAR_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets HCCHAR to value 0"]
            impl crate::Resettable for HCCHAR_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "HCSPLT (rw) register accessor: Split control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcsplt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcsplt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hcsplt`]
module"]
        pub type HCSPLT = crate::Reg<hcsplt::HCSPLT_SPEC>;
        #[doc = "Split control register"]
        pub mod hcsplt {
            #[doc = "Register `HCSPLT` reader"]
            pub type R = crate::R<HCSPLT_SPEC>;
            #[doc = "Register `HCSPLT` writer"]
            pub type W = crate::W<HCSPLT_SPEC>;
            #[doc = "Field `PRTADDR` reader - Port address"]
            pub type PRTADDR_R = crate::FieldReader;
            #[doc = "Field `PRTADDR` writer - Port address"]
            pub type PRTADDR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 7, O>;
            #[doc = "Field `HUBADDR` reader - Hub address"]
            pub type HUBADDR_R = crate::FieldReader;
            #[doc = "Field `HUBADDR` writer - Hub address"]
            pub type HUBADDR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 7, O>;
            #[doc = "Field `XACTPOS` reader - XACTPOS"]
            pub type XACTPOS_R = crate::FieldReader;
            #[doc = "Field `XACTPOS` writer - XACTPOS"]
            pub type XACTPOS_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
            #[doc = "Field `COMPLSPLT` reader - Do complete split"]
            pub type COMPLSPLT_R = crate::BitReader;
            #[doc = "Field `COMPLSPLT` writer - Do complete split"]
            pub type COMPLSPLT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `SPLITEN` reader - Split enable"]
            pub type SPLITEN_R = crate::BitReader;
            #[doc = "Field `SPLITEN` writer - Split enable"]
            pub type SPLITEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            impl R {
                #[doc = "Bits 0:6 - Port address"]
                #[inline(always)]
                pub fn prtaddr(&self) -> PRTADDR_R {
                    PRTADDR_R::new((self.bits & 0x7f) as u8)
                }
                #[doc = "Bits 7:13 - Hub address"]
                #[inline(always)]
                pub fn hubaddr(&self) -> HUBADDR_R {
                    HUBADDR_R::new(((self.bits >> 7) & 0x7f) as u8)
                }
                #[doc = "Bits 14:15 - XACTPOS"]
                #[inline(always)]
                pub fn xactpos(&self) -> XACTPOS_R {
                    XACTPOS_R::new(((self.bits >> 14) & 3) as u8)
                }
                #[doc = "Bit 16 - Do complete split"]
                #[inline(always)]
                pub fn complsplt(&self) -> COMPLSPLT_R {
                    COMPLSPLT_R::new(((self.bits >> 16) & 1) != 0)
                }
                #[doc = "Bit 31 - Split enable"]
                #[inline(always)]
                pub fn spliten(&self) -> SPLITEN_R {
                    SPLITEN_R::new(((self.bits >> 31) & 1) != 0)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("HCSPLT")
                        .field("prtaddr", &format_args!("{}", self.prtaddr().bits()))
                        .field("hubaddr", &format_args!("{}", self.hubaddr().bits()))
                        .field("xactpos", &format_args!("{}", self.xactpos().bits()))
                        .field("complsplt", &format_args!("{}", self.complsplt().bit()))
                        .field("spliten", &format_args!("{}", self.spliten().bit()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<HCSPLT_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:6 - Port address"]
                #[inline(always)]
                #[must_use]
                pub fn prtaddr(&mut self) -> PRTADDR_W<HCSPLT_SPEC, 0> {
                    PRTADDR_W::new(self)
                }
                #[doc = "Bits 7:13 - Hub address"]
                #[inline(always)]
                #[must_use]
                pub fn hubaddr(&mut self) -> HUBADDR_W<HCSPLT_SPEC, 7> {
                    HUBADDR_W::new(self)
                }
                #[doc = "Bits 14:15 - XACTPOS"]
                #[inline(always)]
                #[must_use]
                pub fn xactpos(&mut self) -> XACTPOS_W<HCSPLT_SPEC, 14> {
                    XACTPOS_W::new(self)
                }
                #[doc = "Bit 16 - Do complete split"]
                #[inline(always)]
                #[must_use]
                pub fn complsplt(&mut self) -> COMPLSPLT_W<HCSPLT_SPEC, 16> {
                    COMPLSPLT_W::new(self)
                }
                #[doc = "Bit 31 - Split enable"]
                #[inline(always)]
                #[must_use]
                pub fn spliten(&mut self) -> SPLITEN_W<HCSPLT_SPEC, 31> {
                    SPLITEN_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Split control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcsplt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcsplt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct HCSPLT_SPEC;
            impl crate::RegisterSpec for HCSPLT_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`hcsplt::R`](R) reader structure"]
            impl crate::Readable for HCSPLT_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`hcsplt::W`](W) writer structure"]
            impl crate::Writable for HCSPLT_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets HCSPLT to value 0"]
            impl crate::Resettable for HCSPLT_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "HCINT (rw) register accessor: Interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcint::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcint::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hcint`]
module"]
        pub type HCINT = crate::Reg<hcint::HCINT_SPEC>;
        #[doc = "Interrupt register"]
        pub mod hcint {
            #[doc = "Register `HCINT` reader"]
            pub type R = crate::R<HCINT_SPEC>;
            #[doc = "Register `HCINT` writer"]
            pub type W = crate::W<HCINT_SPEC>;
            #[doc = "Field `XFRC` reader - Transfer completed"]
            pub type XFRC_R = crate::BitReader;
            #[doc = "Field `XFRC` writer - Transfer completed"]
            pub type XFRC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `CHH` reader - Channel halted"]
            pub type CHH_R = crate::BitReader;
            #[doc = "Field `CHH` writer - Channel halted"]
            pub type CHH_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `AHBERR` reader - AHB error"]
            pub type AHBERR_R = crate::BitReader;
            #[doc = "Field `AHBERR` writer - AHB error"]
            pub type AHBERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `STALL` reader - STALL response received interrupt"]
            pub type STALL_R = crate::BitReader;
            #[doc = "Field `STALL` writer - STALL response received interrupt"]
            pub type STALL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `NAK` reader - NAK response received interrupt"]
            pub type NAK_R = crate::BitReader;
            #[doc = "Field `NAK` writer - NAK response received interrupt"]
            pub type NAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"]
            pub type ACK_R = crate::BitReader;
            #[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"]
            pub type ACK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `NYET` reader - Response received interrupt"]
            pub type NYET_R = crate::BitReader;
            #[doc = "Field `NYET` writer - Response received interrupt"]
            pub type NYET_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `TXERR` reader - Transaction error"]
            pub type TXERR_R = crate::BitReader;
            #[doc = "Field `TXERR` writer - Transaction error"]
            pub type TXERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `BBERR` reader - Babble error"]
            pub type BBERR_R = crate::BitReader;
            #[doc = "Field `BBERR` writer - Babble error"]
            pub type BBERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `FRMOR` reader - Frame overrun"]
            pub type FRMOR_R = crate::BitReader;
            #[doc = "Field `FRMOR` writer - Frame overrun"]
            pub type FRMOR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `DTERR` reader - Data toggle error"]
            pub type DTERR_R = crate::BitReader;
            #[doc = "Field `DTERR` writer - Data toggle error"]
            pub type DTERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            impl R {
                #[doc = "Bit 0 - Transfer completed"]
                #[inline(always)]
                pub fn xfrc(&self) -> XFRC_R {
                    XFRC_R::new((self.bits & 1) != 0)
                }
                #[doc = "Bit 1 - Channel halted"]
                #[inline(always)]
                pub fn chh(&self) -> CHH_R {
                    CHH_R::new(((self.bits >> 1) & 1) != 0)
                }
                #[doc = "Bit 2 - AHB error"]
                #[inline(always)]
                pub fn ahberr(&self) -> AHBERR_R {
                    AHBERR_R::new(((self.bits >> 2) & 1) != 0)
                }
                #[doc = "Bit 3 - STALL response received interrupt"]
                #[inline(always)]
                pub fn stall(&self) -> STALL_R {
                    STALL_R::new(((self.bits >> 3) & 1) != 0)
                }
                #[doc = "Bit 4 - NAK response received interrupt"]
                #[inline(always)]
                pub fn nak(&self) -> NAK_R {
                    NAK_R::new(((self.bits >> 4) & 1) != 0)
                }
                #[doc = "Bit 5 - ACK response received/transmitted interrupt"]
                #[inline(always)]
                pub fn ack(&self) -> ACK_R {
                    ACK_R::new(((self.bits >> 5) & 1) != 0)
                }
                #[doc = "Bit 6 - Response received interrupt"]
                #[inline(always)]
                pub fn nyet(&self) -> NYET_R {
                    NYET_R::new(((self.bits >> 6) & 1) != 0)
                }
                #[doc = "Bit 7 - Transaction error"]
                #[inline(always)]
                pub fn txerr(&self) -> TXERR_R {
                    TXERR_R::new(((self.bits >> 7) & 1) != 0)
                }
                #[doc = "Bit 8 - Babble error"]
                #[inline(always)]
                pub fn bberr(&self) -> BBERR_R {
                    BBERR_R::new(((self.bits >> 8) & 1) != 0)
                }
                #[doc = "Bit 9 - Frame overrun"]
                #[inline(always)]
                pub fn frmor(&self) -> FRMOR_R {
                    FRMOR_R::new(((self.bits >> 9) & 1) != 0)
                }
                #[doc = "Bit 10 - Data toggle error"]
                #[inline(always)]
                pub fn dterr(&self) -> DTERR_R {
                    DTERR_R::new(((self.bits >> 10) & 1) != 0)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("HCINT")
                        .field("xfrc", &format_args!("{}", self.xfrc().bit()))
                        .field("chh", &format_args!("{}", self.chh().bit()))
                        .field("ahberr", &format_args!("{}", self.ahberr().bit()))
                        .field("stall", &format_args!("{}", self.stall().bit()))
                        .field("nak", &format_args!("{}", self.nak().bit()))
                        .field("ack", &format_args!("{}", self.ack().bit()))
                        .field("nyet", &format_args!("{}", self.nyet().bit()))
                        .field("txerr", &format_args!("{}", self.txerr().bit()))
                        .field("bberr", &format_args!("{}", self.bberr().bit()))
                        .field("frmor", &format_args!("{}", self.frmor().bit()))
                        .field("dterr", &format_args!("{}", self.dterr().bit()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<HCINT_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bit 0 - Transfer completed"]
                #[inline(always)]
                #[must_use]
                pub fn xfrc(&mut self) -> XFRC_W<HCINT_SPEC, 0> {
                    XFRC_W::new(self)
                }
                #[doc = "Bit 1 - Channel halted"]
                #[inline(always)]
                #[must_use]
                pub fn chh(&mut self) -> CHH_W<HCINT_SPEC, 1> {
                    CHH_W::new(self)
                }
                #[doc = "Bit 2 - AHB error"]
                #[inline(always)]
                #[must_use]
                pub fn ahberr(&mut self) -> AHBERR_W<HCINT_SPEC, 2> {
                    AHBERR_W::new(self)
                }
                #[doc = "Bit 3 - STALL response received interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn stall(&mut self) -> STALL_W<HCINT_SPEC, 3> {
                    STALL_W::new(self)
                }
                #[doc = "Bit 4 - NAK response received interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn nak(&mut self) -> NAK_W<HCINT_SPEC, 4> {
                    NAK_W::new(self)
                }
                #[doc = "Bit 5 - ACK response received/transmitted interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn ack(&mut self) -> ACK_W<HCINT_SPEC, 5> {
                    ACK_W::new(self)
                }
                #[doc = "Bit 6 - Response received interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn nyet(&mut self) -> NYET_W<HCINT_SPEC, 6> {
                    NYET_W::new(self)
                }
                #[doc = "Bit 7 - Transaction error"]
                #[inline(always)]
                #[must_use]
                pub fn txerr(&mut self) -> TXERR_W<HCINT_SPEC, 7> {
                    TXERR_W::new(self)
                }
                #[doc = "Bit 8 - Babble error"]
                #[inline(always)]
                #[must_use]
                pub fn bberr(&mut self) -> BBERR_W<HCINT_SPEC, 8> {
                    BBERR_W::new(self)
                }
                #[doc = "Bit 9 - Frame overrun"]
                #[inline(always)]
                #[must_use]
                pub fn frmor(&mut self) -> FRMOR_W<HCINT_SPEC, 9> {
                    FRMOR_W::new(self)
                }
                #[doc = "Bit 10 - Data toggle error"]
                #[inline(always)]
                #[must_use]
                pub fn dterr(&mut self) -> DTERR_W<HCINT_SPEC, 10> {
                    DTERR_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcint::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcint::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct HCINT_SPEC;
            impl crate::RegisterSpec for HCINT_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`hcint::R`](R) reader structure"]
            impl crate::Readable for HCINT_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`hcint::W`](W) writer structure"]
            impl crate::Writable for HCINT_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets HCINT to value 0"]
            impl crate::Resettable for HCINT_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "HCINTMSK (rw) register accessor: Interrupt mask\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcintmsk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcintmsk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hcintmsk`]
module"]
        pub type HCINTMSK = crate::Reg<hcintmsk::HCINTMSK_SPEC>;
        #[doc = "Interrupt mask"]
        pub mod hcintmsk {
            #[doc = "Register `HCINTMSK` reader"]
            pub type R = crate::R<HCINTMSK_SPEC>;
            #[doc = "Register `HCINTMSK` writer"]
            pub type W = crate::W<HCINTMSK_SPEC>;
            #[doc = "Field `XFRCM` reader - Transfer completed mask"]
            pub type XFRCM_R = crate::BitReader;
            #[doc = "Field `XFRCM` writer - Transfer completed mask"]
            pub type XFRCM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `CHHM` reader - Channel halted mask"]
            pub type CHHM_R = crate::BitReader;
            #[doc = "Field `CHHM` writer - Channel halted mask"]
            pub type CHHM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `AHBERR` reader - AHB error"]
            pub type AHBERR_R = crate::BitReader;
            #[doc = "Field `AHBERR` writer - AHB error"]
            pub type AHBERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `STALLM` reader - STALL response received interrupt mask"]
            pub type STALLM_R = crate::BitReader;
            #[doc = "Field `STALLM` writer - STALL response received interrupt mask"]
            pub type STALLM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `NAKM` reader - NAK response received interrupt mask"]
            pub type NAKM_R = crate::BitReader;
            #[doc = "Field `NAKM` writer - NAK response received interrupt mask"]
            pub type NAKM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"]
            pub type ACKM_R = crate::BitReader;
            #[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"]
            pub type ACKM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `NYET` reader - response received interrupt mask"]
            pub type NYET_R = crate::BitReader;
            #[doc = "Field `NYET` writer - response received interrupt mask"]
            pub type NYET_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `TXERRM` reader - Transaction error mask"]
            pub type TXERRM_R = crate::BitReader;
            #[doc = "Field `TXERRM` writer - Transaction error mask"]
            pub type TXERRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `BBERRM` reader - Babble error mask"]
            pub type BBERRM_R = crate::BitReader;
            #[doc = "Field `BBERRM` writer - Babble error mask"]
            pub type BBERRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `FRMORM` reader - Frame overrun mask"]
            pub type FRMORM_R = crate::BitReader;
            #[doc = "Field `FRMORM` writer - Frame overrun mask"]
            pub type FRMORM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `DTERRM` reader - Data toggle error mask"]
            pub type DTERRM_R = crate::BitReader;
            #[doc = "Field `DTERRM` writer - Data toggle error mask"]
            pub type DTERRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            impl R {
                #[doc = "Bit 0 - Transfer completed mask"]
                #[inline(always)]
                pub fn xfrcm(&self) -> XFRCM_R {
                    XFRCM_R::new((self.bits & 1) != 0)
                }
                #[doc = "Bit 1 - Channel halted mask"]
                #[inline(always)]
                pub fn chhm(&self) -> CHHM_R {
                    CHHM_R::new(((self.bits >> 1) & 1) != 0)
                }
                #[doc = "Bit 2 - AHB error"]
                #[inline(always)]
                pub fn ahberr(&self) -> AHBERR_R {
                    AHBERR_R::new(((self.bits >> 2) & 1) != 0)
                }
                #[doc = "Bit 3 - STALL response received interrupt mask"]
                #[inline(always)]
                pub fn stallm(&self) -> STALLM_R {
                    STALLM_R::new(((self.bits >> 3) & 1) != 0)
                }
                #[doc = "Bit 4 - NAK response received interrupt mask"]
                #[inline(always)]
                pub fn nakm(&self) -> NAKM_R {
                    NAKM_R::new(((self.bits >> 4) & 1) != 0)
                }
                #[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
                #[inline(always)]
                pub fn ackm(&self) -> ACKM_R {
                    ACKM_R::new(((self.bits >> 5) & 1) != 0)
                }
                #[doc = "Bit 6 - response received interrupt mask"]
                #[inline(always)]
                pub fn nyet(&self) -> NYET_R {
                    NYET_R::new(((self.bits >> 6) & 1) != 0)
                }
                #[doc = "Bit 7 - Transaction error mask"]
                #[inline(always)]
                pub fn txerrm(&self) -> TXERRM_R {
                    TXERRM_R::new(((self.bits >> 7) & 1) != 0)
                }
                #[doc = "Bit 8 - Babble error mask"]
                #[inline(always)]
                pub fn bberrm(&self) -> BBERRM_R {
                    BBERRM_R::new(((self.bits >> 8) & 1) != 0)
                }
                #[doc = "Bit 9 - Frame overrun mask"]
                #[inline(always)]
                pub fn frmorm(&self) -> FRMORM_R {
                    FRMORM_R::new(((self.bits >> 9) & 1) != 0)
                }
                #[doc = "Bit 10 - Data toggle error mask"]
                #[inline(always)]
                pub fn dterrm(&self) -> DTERRM_R {
                    DTERRM_R::new(((self.bits >> 10) & 1) != 0)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("HCINTMSK")
                        .field("xfrcm", &format_args!("{}", self.xfrcm().bit()))
                        .field("chhm", &format_args!("{}", self.chhm().bit()))
                        .field("ahberr", &format_args!("{}", self.ahberr().bit()))
                        .field("stallm", &format_args!("{}", self.stallm().bit()))
                        .field("nakm", &format_args!("{}", self.nakm().bit()))
                        .field("ackm", &format_args!("{}", self.ackm().bit()))
                        .field("nyet", &format_args!("{}", self.nyet().bit()))
                        .field("txerrm", &format_args!("{}", self.txerrm().bit()))
                        .field("bberrm", &format_args!("{}", self.bberrm().bit()))
                        .field("frmorm", &format_args!("{}", self.frmorm().bit()))
                        .field("dterrm", &format_args!("{}", self.dterrm().bit()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<HCINTMSK_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bit 0 - Transfer completed mask"]
                #[inline(always)]
                #[must_use]
                pub fn xfrcm(&mut self) -> XFRCM_W<HCINTMSK_SPEC, 0> {
                    XFRCM_W::new(self)
                }
                #[doc = "Bit 1 - Channel halted mask"]
                #[inline(always)]
                #[must_use]
                pub fn chhm(&mut self) -> CHHM_W<HCINTMSK_SPEC, 1> {
                    CHHM_W::new(self)
                }
                #[doc = "Bit 2 - AHB error"]
                #[inline(always)]
                #[must_use]
                pub fn ahberr(&mut self) -> AHBERR_W<HCINTMSK_SPEC, 2> {
                    AHBERR_W::new(self)
                }
                #[doc = "Bit 3 - STALL response received interrupt mask"]
                #[inline(always)]
                #[must_use]
                pub fn stallm(&mut self) -> STALLM_W<HCINTMSK_SPEC, 3> {
                    STALLM_W::new(self)
                }
                #[doc = "Bit 4 - NAK response received interrupt mask"]
                #[inline(always)]
                #[must_use]
                pub fn nakm(&mut self) -> NAKM_W<HCINTMSK_SPEC, 4> {
                    NAKM_W::new(self)
                }
                #[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
                #[inline(always)]
                #[must_use]
                pub fn ackm(&mut self) -> ACKM_W<HCINTMSK_SPEC, 5> {
                    ACKM_W::new(self)
                }
                #[doc = "Bit 6 - response received interrupt mask"]
                #[inline(always)]
                #[must_use]
                pub fn nyet(&mut self) -> NYET_W<HCINTMSK_SPEC, 6> {
                    NYET_W::new(self)
                }
                #[doc = "Bit 7 - Transaction error mask"]
                #[inline(always)]
                #[must_use]
                pub fn txerrm(&mut self) -> TXERRM_W<HCINTMSK_SPEC, 7> {
                    TXERRM_W::new(self)
                }
                #[doc = "Bit 8 - Babble error mask"]
                #[inline(always)]
                #[must_use]
                pub fn bberrm(&mut self) -> BBERRM_W<HCINTMSK_SPEC, 8> {
                    BBERRM_W::new(self)
                }
                #[doc = "Bit 9 - Frame overrun mask"]
                #[inline(always)]
                #[must_use]
                pub fn frmorm(&mut self) -> FRMORM_W<HCINTMSK_SPEC, 9> {
                    FRMORM_W::new(self)
                }
                #[doc = "Bit 10 - Data toggle error mask"]
                #[inline(always)]
                #[must_use]
                pub fn dterrm(&mut self) -> DTERRM_W<HCINTMSK_SPEC, 10> {
                    DTERRM_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Interrupt mask\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcintmsk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcintmsk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct HCINTMSK_SPEC;
            impl crate::RegisterSpec for HCINTMSK_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`hcintmsk::R`](R) reader structure"]
            impl crate::Readable for HCINTMSK_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`hcintmsk::W`](W) writer structure"]
            impl crate::Writable for HCINTMSK_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets HCINTMSK to value 0"]
            impl crate::Resettable for HCINTMSK_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "HCTSIZ (rw) register accessor: Transfer size\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hctsiz::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hctsiz::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hctsiz`]
module"]
        pub type HCTSIZ = crate::Reg<hctsiz::HCTSIZ_SPEC>;
        #[doc = "Transfer size"]
        pub mod hctsiz {
            #[doc = "Register `HCTSIZ` reader"]
            pub type R = crate::R<HCTSIZ_SPEC>;
            #[doc = "Register `HCTSIZ` writer"]
            pub type W = crate::W<HCTSIZ_SPEC>;
            #[doc = "Field `XFRSIZ` reader - Transfer size"]
            pub type XFRSIZ_R = crate::FieldReader<u32>;
            #[doc = "Field `XFRSIZ` writer - Transfer size"]
            pub type XFRSIZ_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 19, O, u32>;
            #[doc = "Field `PKTCNT` reader - Packet count"]
            pub type PKTCNT_R = crate::FieldReader<u16>;
            #[doc = "Field `PKTCNT` writer - Packet count"]
            pub type PKTCNT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 10, O, u16>;
            #[doc = "Field `DPID` reader - Data PID"]
            pub type DPID_R = crate::FieldReader;
            #[doc = "Field `DPID` writer - Data PID"]
            pub type DPID_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
            impl R {
                #[doc = "Bits 0:18 - Transfer size"]
                #[inline(always)]
                pub fn xfrsiz(&self) -> XFRSIZ_R {
                    XFRSIZ_R::new(self.bits & 0x0007_ffff)
                }
                #[doc = "Bits 19:28 - Packet count"]
                #[inline(always)]
                pub fn pktcnt(&self) -> PKTCNT_R {
                    PKTCNT_R::new(((self.bits >> 19) & 0x03ff) as u16)
                }
                #[doc = "Bits 29:30 - Data PID"]
                #[inline(always)]
                pub fn dpid(&self) -> DPID_R {
                    DPID_R::new(((self.bits >> 29) & 3) as u8)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("HCTSIZ")
                        .field("xfrsiz", &format_args!("{}", self.xfrsiz().bits()))
                        .field("pktcnt", &format_args!("{}", self.pktcnt().bits()))
                        .field("dpid", &format_args!("{}", self.dpid().bits()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<HCTSIZ_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:18 - Transfer size"]
                #[inline(always)]
                #[must_use]
                pub fn xfrsiz(&mut self) -> XFRSIZ_W<HCTSIZ_SPEC, 0> {
                    XFRSIZ_W::new(self)
                }
                #[doc = "Bits 19:28 - Packet count"]
                #[inline(always)]
                #[must_use]
                pub fn pktcnt(&mut self) -> PKTCNT_W<HCTSIZ_SPEC, 19> {
                    PKTCNT_W::new(self)
                }
                #[doc = "Bits 29:30 - Data PID"]
                #[inline(always)]
                #[must_use]
                pub fn dpid(&mut self) -> DPID_W<HCTSIZ_SPEC, 29> {
                    DPID_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Transfer size\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hctsiz::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hctsiz::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct HCTSIZ_SPEC;
            impl crate::RegisterSpec for HCTSIZ_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`hctsiz::R`](R) reader structure"]
            impl crate::Readable for HCTSIZ_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`hctsiz::W`](W) writer structure"]
            impl crate::Writable for HCTSIZ_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets HCTSIZ to value 0"]
            impl crate::Resettable for HCTSIZ_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "HCDMA (rw) register accessor: DMA address\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcdma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcdma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hcdma`]
module"]
        pub type HCDMA = crate::Reg<hcdma::HCDMA_SPEC>;
        #[doc = "DMA address"]
        pub mod hcdma {
            #[doc = "Register `HCDMA` reader"]
            pub type R = crate::R<HCDMA_SPEC>;
            #[doc = "Register `HCDMA` writer"]
            pub type W = crate::W<HCDMA_SPEC>;
            #[doc = "Field `DMAADDR` reader - DMA address"]
            pub type DMAADDR_R = crate::FieldReader<u32>;
            #[doc = "Field `DMAADDR` writer - DMA address"]
            pub type DMAADDR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 32, O, u32>;
            impl R {
                #[doc = "Bits 0:31 - DMA address"]
                #[inline(always)]
                pub fn dmaaddr(&self) -> DMAADDR_R {
                    DMAADDR_R::new(self.bits)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("HCDMA")
                        .field("dmaaddr", &format_args!("{}", self.dmaaddr().bits()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<HCDMA_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:31 - DMA address"]
                #[inline(always)]
                #[must_use]
                pub fn dmaaddr(&mut self) -> DMAADDR_W<HCDMA_SPEC, 0> {
                    DMAADDR_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "DMA address\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hcdma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hcdma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct HCDMA_SPEC;
            impl crate::RegisterSpec for HCDMA_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`hcdma::R`](R) reader structure"]
            impl crate::Readable for HCDMA_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`hcdma::W`](W) writer structure"]
            impl crate::Writable for HCDMA_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets HCDMA to value 0"]
            impl crate::Resettable for HCDMA_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
    }
}
#[doc = "USB on the go high speed"]
pub struct USB_OTG_DEVICE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB_OTG_DEVICE {}
impl USB_OTG_DEVICE {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb_otg_device::RegisterBlock = 0x2098_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb_otg_device::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB_OTG_DEVICE {
    type Target = usb_otg_device::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB_OTG_DEVICE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB_OTG_DEVICE").finish()
    }
}
#[doc = "USB on the go high speed"]
pub mod usb_otg_device {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - OTG_HS device configuration register"]
        pub dcfg: DCFG,
        #[doc = "0x04 - OTG_HS device control register"]
        pub dctl: DCTL,
        #[doc = "0x08 - OTG_HS device status register"]
        pub dsts: DSTS,
        _reserved3: [u8; 0x04],
        #[doc = "0x10 - OTG_HS device IN endpoint common interrupt mask register"]
        pub diepmsk: DIEPMSK,
        #[doc = "0x14 - OTG_HS device OUT endpoint common interrupt mask register"]
        pub doepmsk: DOEPMSK,
        #[doc = "0x18 - OTG_HS device all endpoints interrupt register"]
        pub daint: DAINT,
        #[doc = "0x1c - OTG_HS all endpoints interrupt mask register"]
        pub daintmsk: DAINTMSK,
        _reserved7: [u8; 0x08],
        #[doc = "0x28 - OTG_HS device VBUS discharge time register"]
        pub dvbusdis: DVBUSDIS,
        #[doc = "0x2c - OTG_HS device VBUS pulsing time register"]
        pub dvbuspulse: DVBUSPULSE,
        #[doc = "0x30 - OTG_HS Device threshold control register"]
        pub dthrctl: DTHRCTL,
        #[doc = "0x34 - OTG_HS device IN endpoint FIFO empty interrupt mask register"]
        pub diepempmsk: DIEPEMPMSK,
        #[doc = "0x38 - OTG_HS device each endpoint interrupt register"]
        pub deachint: DEACHINT,
        #[doc = "0x3c - OTG_HS device each endpoint interrupt register mask"]
        pub deachintmsk: DEACHINTMSK,
        #[doc = "0x40 - OTG_HS device each in endpoint-1 interrupt register"]
        pub diepeachmsk1: DIEPEACHMSK1,
        _reserved14: [u8; 0x3c],
        #[doc = "0x80 - OTG_HS device each OUT endpoint-1 interrupt register"]
        pub doepeachmsk1: DOEPEACHMSK1,
        _reserved15: [u8; 0x7c],
        #[doc = "0x100..0x11c - IN Endpoint %s"]
        pub in_endpoint0: IN_ENDPOINT,
        _reserved16: [u8; 0x04],
        #[doc = "0x120..0x13c - IN Endpoint %s"]
        pub in_endpoint1: IN_ENDPOINT,
        _reserved17: [u8; 0x04],
        #[doc = "0x140..0x15c - IN Endpoint %s"]
        pub in_endpoint2: IN_ENDPOINT,
        _reserved18: [u8; 0x04],
        #[doc = "0x160..0x17c - IN Endpoint %s"]
        pub in_endpoint3: IN_ENDPOINT,
        _reserved19: [u8; 0x04],
        #[doc = "0x180..0x19c - IN Endpoint %s"]
        pub in_endpoint4: IN_ENDPOINT,
        _reserved20: [u8; 0x04],
        #[doc = "0x1a0..0x1bc - IN Endpoint %s"]
        pub in_endpoint5: IN_ENDPOINT,
        _reserved21: [u8; 0x04],
        #[doc = "0x1c0..0x1dc - IN Endpoint %s"]
        pub in_endpoint6: IN_ENDPOINT,
        _reserved22: [u8; 0x04],
        #[doc = "0x1e0..0x1fc - IN Endpoint %s"]
        pub in_endpoint7: IN_ENDPOINT,
        _reserved23: [u8; 0x04],
        #[doc = "0x200..0x21c - IN Endpoint %s"]
        pub in_endpoint8: IN_ENDPOINT,
        _reserved24: [u8; 0x04],
        #[doc = "0x220..0x23c - IN Endpoint %s"]
        pub in_endpoint9: IN_ENDPOINT,
        _reserved25: [u8; 0x04],
        #[doc = "0x240..0x25c - IN Endpoint %s"]
        pub in_endpoint10: IN_ENDPOINT,
        _reserved26: [u8; 0x04],
        #[doc = "0x260..0x27c - IN Endpoint %s"]
        pub in_endpoint11: IN_ENDPOINT,
        _reserved27: [u8; 0x84],
        #[doc = "0x300..0x318 - OUT Endpoint %s"]
        pub out_endpoint0: OUT_ENDPOINT,
        _reserved28: [u8; 0x08],
        #[doc = "0x320..0x338 - OUT Endpoint %s"]
        pub out_endpoint1: OUT_ENDPOINT,
        _reserved29: [u8; 0x08],
        #[doc = "0x340..0x358 - OUT Endpoint %s"]
        pub out_endpoint2: OUT_ENDPOINT,
        _reserved30: [u8; 0x08],
        #[doc = "0x360..0x378 - OUT Endpoint %s"]
        pub out_endpoint3: OUT_ENDPOINT,
        _reserved31: [u8; 0x08],
        #[doc = "0x380..0x398 - OUT Endpoint %s"]
        pub out_endpoint4: OUT_ENDPOINT,
        _reserved32: [u8; 0x08],
        #[doc = "0x3a0..0x3b8 - OUT Endpoint %s"]
        pub out_endpoint5: OUT_ENDPOINT,
        _reserved33: [u8; 0x08],
        #[doc = "0x3c0..0x3d8 - OUT Endpoint %s"]
        pub out_endpoint6: OUT_ENDPOINT,
        _reserved34: [u8; 0x08],
        #[doc = "0x3e0..0x3f8 - OUT Endpoint %s"]
        pub out_endpoint7: OUT_ENDPOINT,
        _reserved35: [u8; 0x08],
        #[doc = "0x400..0x418 - OUT Endpoint %s"]
        pub out_endpoint8: OUT_ENDPOINT,
        _reserved36: [u8; 0x08],
        #[doc = "0x420..0x438 - OUT Endpoint %s"]
        pub out_endpoint9: OUT_ENDPOINT,
        _reserved37: [u8; 0x08],
        #[doc = "0x440..0x458 - OUT Endpoint %s"]
        pub out_endpoint10: OUT_ENDPOINT,
        _reserved38: [u8; 0x08],
        #[doc = "0x460..0x478 - OUT Endpoint %s"]
        pub out_endpoint11: OUT_ENDPOINT,
    }
    #[doc = "DCFG (rw) register accessor: OTG_HS device configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dcfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dcfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcfg`]
module"]
    pub type DCFG = crate::Reg<dcfg::DCFG_SPEC>;
    #[doc = "OTG_HS device configuration register"]
    pub mod dcfg {
        #[doc = "Register `DCFG` reader"]
        pub type R = crate::R<DCFG_SPEC>;
        #[doc = "Register `DCFG` writer"]
        pub type W = crate::W<DCFG_SPEC>;
        #[doc = "Field `DSPD` reader - Device speed"]
        pub type DSPD_R = crate::FieldReader;
        #[doc = "Field `DSPD` writer - Device speed"]
        pub type DSPD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        #[doc = "Field `NZLSOHSK` reader - Nonzero-length status OUT handshake"]
        pub type NZLSOHSK_R = crate::BitReader;
        #[doc = "Field `NZLSOHSK` writer - Nonzero-length status OUT handshake"]
        pub type NZLSOHSK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DAD` reader - Device address"]
        pub type DAD_R = crate::FieldReader;
        #[doc = "Field `DAD` writer - Device address"]
        pub type DAD_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 7, O>;
        #[doc = "Field `PFIVL` reader - Periodic (micro)frame interval"]
        pub type PFIVL_R = crate::FieldReader;
        #[doc = "Field `PFIVL` writer - Periodic (micro)frame interval"]
        pub type PFIVL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        #[doc = "Field `PERSCHIVL` reader - Periodic scheduling interval"]
        pub type PERSCHIVL_R = crate::FieldReader;
        #[doc = "Field `PERSCHIVL` writer - Periodic scheduling interval"]
        pub type PERSCHIVL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        impl R {
            #[doc = "Bits 0:1 - Device speed"]
            #[inline(always)]
            pub fn dspd(&self) -> DSPD_R {
                DSPD_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Nonzero-length status OUT handshake"]
            #[inline(always)]
            pub fn nzlsohsk(&self) -> NZLSOHSK_R {
                NZLSOHSK_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 4:10 - Device address"]
            #[inline(always)]
            pub fn dad(&self) -> DAD_R {
                DAD_R::new(((self.bits >> 4) & 0x7f) as u8)
            }
            #[doc = "Bits 11:12 - Periodic (micro)frame interval"]
            #[inline(always)]
            pub fn pfivl(&self) -> PFIVL_R {
                PFIVL_R::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bits 24:25 - Periodic scheduling interval"]
            #[inline(always)]
            pub fn perschivl(&self) -> PERSCHIVL_R {
                PERSCHIVL_R::new(((self.bits >> 24) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DCFG")
                    .field("dspd", &format_args!("{}", self.dspd().bits()))
                    .field("nzlsohsk", &format_args!("{}", self.nzlsohsk().bit()))
                    .field("dad", &format_args!("{}", self.dad().bits()))
                    .field("pfivl", &format_args!("{}", self.pfivl().bits()))
                    .field("perschivl", &format_args!("{}", self.perschivl().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DCFG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Device speed"]
            #[inline(always)]
            #[must_use]
            pub fn dspd(&mut self) -> DSPD_W<DCFG_SPEC, 0> {
                DSPD_W::new(self)
            }
            #[doc = "Bit 2 - Nonzero-length status OUT handshake"]
            #[inline(always)]
            #[must_use]
            pub fn nzlsohsk(&mut self) -> NZLSOHSK_W<DCFG_SPEC, 2> {
                NZLSOHSK_W::new(self)
            }
            #[doc = "Bits 4:10 - Device address"]
            #[inline(always)]
            #[must_use]
            pub fn dad(&mut self) -> DAD_W<DCFG_SPEC, 4> {
                DAD_W::new(self)
            }
            #[doc = "Bits 11:12 - Periodic (micro)frame interval"]
            #[inline(always)]
            #[must_use]
            pub fn pfivl(&mut self) -> PFIVL_W<DCFG_SPEC, 11> {
                PFIVL_W::new(self)
            }
            #[doc = "Bits 24:25 - Periodic scheduling interval"]
            #[inline(always)]
            #[must_use]
            pub fn perschivl(&mut self) -> PERSCHIVL_W<DCFG_SPEC, 24> {
                PERSCHIVL_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dcfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dcfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DCFG_SPEC;
        impl crate::RegisterSpec for DCFG_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dcfg::R`](R) reader structure"]
        impl crate::Readable for DCFG_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dcfg::W`](W) writer structure"]
        impl crate::Writable for DCFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DCFG to value 0x0220_0000"]
        impl crate::Resettable for DCFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x0220_0000;
        }
    }
    #[doc = "DCTL (rw) register accessor: OTG_HS device control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dctl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dctl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dctl`]
module"]
    pub type DCTL = crate::Reg<dctl::DCTL_SPEC>;
    #[doc = "OTG_HS device control register"]
    pub mod dctl {
        #[doc = "Register `DCTL` reader"]
        pub type R = crate::R<DCTL_SPEC>;
        #[doc = "Register `DCTL` writer"]
        pub type W = crate::W<DCTL_SPEC>;
        #[doc = "Field `RWUSIG` reader - Remote wakeup signaling"]
        pub type RWUSIG_R = crate::BitReader;
        #[doc = "Field `RWUSIG` writer - Remote wakeup signaling"]
        pub type RWUSIG_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SDIS` reader - Soft disconnect"]
        pub type SDIS_R = crate::BitReader;
        #[doc = "Field `SDIS` writer - Soft disconnect"]
        pub type SDIS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GINSTS` reader - Global IN NAK status"]
        pub type GINSTS_R = crate::BitReader;
        #[doc = "Field `GONSTS` reader - Global OUT NAK status"]
        pub type GONSTS_R = crate::BitReader;
        #[doc = "Field `TCTL` reader - Test control"]
        pub type TCTL_R = crate::FieldReader;
        #[doc = "Field `TCTL` writer - Test control"]
        pub type TCTL_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O>;
        #[doc = "Field `SGINAK` writer - Set global IN NAK"]
        pub type SGINAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CGINAK` writer - Clear global IN NAK"]
        pub type CGINAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SGONAK` writer - Set global OUT NAK"]
        pub type SGONAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CGONAK` writer - Clear global OUT NAK"]
        pub type CGONAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `POPRGDNE` reader - Power-on programming done"]
        pub type POPRGDNE_R = crate::BitReader;
        #[doc = "Field `POPRGDNE` writer - Power-on programming done"]
        pub type POPRGDNE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Remote wakeup signaling"]
            #[inline(always)]
            pub fn rwusig(&self) -> RWUSIG_R {
                RWUSIG_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Soft disconnect"]
            #[inline(always)]
            pub fn sdis(&self) -> SDIS_R {
                SDIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Global IN NAK status"]
            #[inline(always)]
            pub fn ginsts(&self) -> GINSTS_R {
                GINSTS_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Global OUT NAK status"]
            #[inline(always)]
            pub fn gonsts(&self) -> GONSTS_R {
                GONSTS_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:6 - Test control"]
            #[inline(always)]
            pub fn tctl(&self) -> TCTL_R {
                TCTL_R::new(((self.bits >> 4) & 7) as u8)
            }
            #[doc = "Bit 11 - Power-on programming done"]
            #[inline(always)]
            pub fn poprgdne(&self) -> POPRGDNE_R {
                POPRGDNE_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DCTL")
                    .field("rwusig", &format_args!("{}", self.rwusig().bit()))
                    .field("sdis", &format_args!("{}", self.sdis().bit()))
                    .field("ginsts", &format_args!("{}", self.ginsts().bit()))
                    .field("gonsts", &format_args!("{}", self.gonsts().bit()))
                    .field("tctl", &format_args!("{}", self.tctl().bits()))
                    .field("poprgdne", &format_args!("{}", self.poprgdne().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DCTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Remote wakeup signaling"]
            #[inline(always)]
            #[must_use]
            pub fn rwusig(&mut self) -> RWUSIG_W<DCTL_SPEC, 0> {
                RWUSIG_W::new(self)
            }
            #[doc = "Bit 1 - Soft disconnect"]
            #[inline(always)]
            #[must_use]
            pub fn sdis(&mut self) -> SDIS_W<DCTL_SPEC, 1> {
                SDIS_W::new(self)
            }
            #[doc = "Bits 4:6 - Test control"]
            #[inline(always)]
            #[must_use]
            pub fn tctl(&mut self) -> TCTL_W<DCTL_SPEC, 4> {
                TCTL_W::new(self)
            }
            #[doc = "Bit 7 - Set global IN NAK"]
            #[inline(always)]
            #[must_use]
            pub fn sginak(&mut self) -> SGINAK_W<DCTL_SPEC, 7> {
                SGINAK_W::new(self)
            }
            #[doc = "Bit 8 - Clear global IN NAK"]
            #[inline(always)]
            #[must_use]
            pub fn cginak(&mut self) -> CGINAK_W<DCTL_SPEC, 8> {
                CGINAK_W::new(self)
            }
            #[doc = "Bit 9 - Set global OUT NAK"]
            #[inline(always)]
            #[must_use]
            pub fn sgonak(&mut self) -> SGONAK_W<DCTL_SPEC, 9> {
                SGONAK_W::new(self)
            }
            #[doc = "Bit 10 - Clear global OUT NAK"]
            #[inline(always)]
            #[must_use]
            pub fn cgonak(&mut self) -> CGONAK_W<DCTL_SPEC, 10> {
                CGONAK_W::new(self)
            }
            #[doc = "Bit 11 - Power-on programming done"]
            #[inline(always)]
            #[must_use]
            pub fn poprgdne(&mut self) -> POPRGDNE_W<DCTL_SPEC, 11> {
                POPRGDNE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DCTL_SPEC;
        impl crate::RegisterSpec for DCTL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dctl::R`](R) reader structure"]
        impl crate::Readable for DCTL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dctl::W`](W) writer structure"]
        impl crate::Writable for DCTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DCTL to value 0"]
        impl crate::Resettable for DCTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DSTS (r) register accessor: OTG_HS device status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dsts::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dsts`]
module"]
    pub type DSTS = crate::Reg<dsts::DSTS_SPEC>;
    #[doc = "OTG_HS device status register"]
    pub mod dsts {
        #[doc = "Register `DSTS` reader"]
        pub type R = crate::R<DSTS_SPEC>;
        #[doc = "Field `SUSPSTS` reader - Suspend status"]
        pub type SUSPSTS_R = crate::BitReader;
        #[doc = "Field `ENUMSPD` reader - Enumerated speed"]
        pub type ENUMSPD_R = crate::FieldReader;
        #[doc = "Field `EERR` reader - Erratic error"]
        pub type EERR_R = crate::BitReader;
        #[doc = "Field `FNSOF` reader - Frame number of the received SOF"]
        pub type FNSOF_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bit 0 - Suspend status"]
            #[inline(always)]
            pub fn suspsts(&self) -> SUSPSTS_R {
                SUSPSTS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:2 - Enumerated speed"]
            #[inline(always)]
            pub fn enumspd(&self) -> ENUMSPD_R {
                ENUMSPD_R::new(((self.bits >> 1) & 3) as u8)
            }
            #[doc = "Bit 3 - Erratic error"]
            #[inline(always)]
            pub fn eerr(&self) -> EERR_R {
                EERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 8:21 - Frame number of the received SOF"]
            #[inline(always)]
            pub fn fnsof(&self) -> FNSOF_R {
                FNSOF_R::new(((self.bits >> 8) & 0x3fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DSTS")
                    .field("suspsts", &format_args!("{}", self.suspsts().bit()))
                    .field("enumspd", &format_args!("{}", self.enumspd().bits()))
                    .field("eerr", &format_args!("{}", self.eerr().bit()))
                    .field("fnsof", &format_args!("{}", self.fnsof().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DSTS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS device status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dsts::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DSTS_SPEC;
        impl crate::RegisterSpec for DSTS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dsts::R`](R) reader structure"]
        impl crate::Readable for DSTS_SPEC {}
        #[doc = "`reset()` method sets DSTS to value 0x10"]
        impl crate::Resettable for DSTS_SPEC {
            const RESET_VALUE: Self::Ux = 0x10;
        }
    }
    #[doc = "DIEPMSK (rw) register accessor: OTG_HS device IN endpoint common interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepmsk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepmsk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepmsk`]
module"]
    pub type DIEPMSK = crate::Reg<diepmsk::DIEPMSK_SPEC>;
    #[doc = "OTG_HS device IN endpoint common interrupt mask register"]
    pub mod diepmsk {
        #[doc = "Register `DIEPMSK` reader"]
        pub type R = crate::R<DIEPMSK_SPEC>;
        #[doc = "Register `DIEPMSK` writer"]
        pub type W = crate::W<DIEPMSK_SPEC>;
        #[doc = "Field `XFRCM` reader - Transfer completed interrupt mask"]
        pub type XFRCM_R = crate::BitReader;
        #[doc = "Field `XFRCM` writer - Transfer completed interrupt mask"]
        pub type XFRCM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EPDM` reader - Endpoint disabled interrupt mask"]
        pub type EPDM_R = crate::BitReader;
        #[doc = "Field `EPDM` writer - Endpoint disabled interrupt mask"]
        pub type EPDM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TOM` reader - Timeout condition mask (nonisochronous endpoints)"]
        pub type TOM_R = crate::BitReader;
        #[doc = "Field `TOM` writer - Timeout condition mask (nonisochronous endpoints)"]
        pub type TOM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ITTXFEMSK` reader - IN token received when TxFIFO empty mask"]
        pub type ITTXFEMSK_R = crate::BitReader;
        #[doc = "Field `ITTXFEMSK` writer - IN token received when TxFIFO empty mask"]
        pub type ITTXFEMSK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INEPNMM` reader - IN token received with EP mismatch mask"]
        pub type INEPNMM_R = crate::BitReader;
        #[doc = "Field `INEPNMM` writer - IN token received with EP mismatch mask"]
        pub type INEPNMM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INEPNEM` reader - IN endpoint NAK effective mask"]
        pub type INEPNEM_R = crate::BitReader;
        #[doc = "Field `INEPNEM` writer - IN endpoint NAK effective mask"]
        pub type INEPNEM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXFURM` reader - FIFO underrun mask"]
        pub type TXFURM_R = crate::BitReader;
        #[doc = "Field `TXFURM` writer - FIFO underrun mask"]
        pub type TXFURM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BIM` reader - BNA interrupt mask"]
        pub type BIM_R = crate::BitReader;
        #[doc = "Field `BIM` writer - BNA interrupt mask"]
        pub type BIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Transfer completed interrupt mask"]
            #[inline(always)]
            pub fn xfrcm(&self) -> XFRCM_R {
                XFRCM_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Endpoint disabled interrupt mask"]
            #[inline(always)]
            pub fn epdm(&self) -> EPDM_R {
                EPDM_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - Timeout condition mask (nonisochronous endpoints)"]
            #[inline(always)]
            pub fn tom(&self) -> TOM_R {
                TOM_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - IN token received when TxFIFO empty mask"]
            #[inline(always)]
            pub fn ittxfemsk(&self) -> ITTXFEMSK_R {
                ITTXFEMSK_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - IN token received with EP mismatch mask"]
            #[inline(always)]
            pub fn inepnmm(&self) -> INEPNMM_R {
                INEPNMM_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - IN endpoint NAK effective mask"]
            #[inline(always)]
            pub fn inepnem(&self) -> INEPNEM_R {
                INEPNEM_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - FIFO underrun mask"]
            #[inline(always)]
            pub fn txfurm(&self) -> TXFURM_R {
                TXFURM_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - BNA interrupt mask"]
            #[inline(always)]
            pub fn bim(&self) -> BIM_R {
                BIM_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPMSK")
                    .field("xfrcm", &format_args!("{}", self.xfrcm().bit()))
                    .field("epdm", &format_args!("{}", self.epdm().bit()))
                    .field("tom", &format_args!("{}", self.tom().bit()))
                    .field("ittxfemsk", &format_args!("{}", self.ittxfemsk().bit()))
                    .field("inepnmm", &format_args!("{}", self.inepnmm().bit()))
                    .field("inepnem", &format_args!("{}", self.inepnem().bit()))
                    .field("txfurm", &format_args!("{}", self.txfurm().bit()))
                    .field("bim", &format_args!("{}", self.bim().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPMSK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transfer completed interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn xfrcm(&mut self) -> XFRCM_W<DIEPMSK_SPEC, 0> {
                XFRCM_W::new(self)
            }
            #[doc = "Bit 1 - Endpoint disabled interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn epdm(&mut self) -> EPDM_W<DIEPMSK_SPEC, 1> {
                EPDM_W::new(self)
            }
            #[doc = "Bit 3 - Timeout condition mask (nonisochronous endpoints)"]
            #[inline(always)]
            #[must_use]
            pub fn tom(&mut self) -> TOM_W<DIEPMSK_SPEC, 3> {
                TOM_W::new(self)
            }
            #[doc = "Bit 4 - IN token received when TxFIFO empty mask"]
            #[inline(always)]
            #[must_use]
            pub fn ittxfemsk(&mut self) -> ITTXFEMSK_W<DIEPMSK_SPEC, 4> {
                ITTXFEMSK_W::new(self)
            }
            #[doc = "Bit 5 - IN token received with EP mismatch mask"]
            #[inline(always)]
            #[must_use]
            pub fn inepnmm(&mut self) -> INEPNMM_W<DIEPMSK_SPEC, 5> {
                INEPNMM_W::new(self)
            }
            #[doc = "Bit 6 - IN endpoint NAK effective mask"]
            #[inline(always)]
            #[must_use]
            pub fn inepnem(&mut self) -> INEPNEM_W<DIEPMSK_SPEC, 6> {
                INEPNEM_W::new(self)
            }
            #[doc = "Bit 8 - FIFO underrun mask"]
            #[inline(always)]
            #[must_use]
            pub fn txfurm(&mut self) -> TXFURM_W<DIEPMSK_SPEC, 8> {
                TXFURM_W::new(self)
            }
            #[doc = "Bit 9 - BNA interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn bim(&mut self) -> BIM_W<DIEPMSK_SPEC, 9> {
                BIM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint common interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepmsk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepmsk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPMSK_SPEC;
        impl crate::RegisterSpec for DIEPMSK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`diepmsk::R`](R) reader structure"]
        impl crate::Readable for DIEPMSK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`diepmsk::W`](W) writer structure"]
        impl crate::Writable for DIEPMSK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPMSK to value 0"]
        impl crate::Resettable for DIEPMSK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DOEPMSK (rw) register accessor: OTG_HS device OUT endpoint common interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepmsk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepmsk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepmsk`]
module"]
    pub type DOEPMSK = crate::Reg<doepmsk::DOEPMSK_SPEC>;
    #[doc = "OTG_HS device OUT endpoint common interrupt mask register"]
    pub mod doepmsk {
        #[doc = "Register `DOEPMSK` reader"]
        pub type R = crate::R<DOEPMSK_SPEC>;
        #[doc = "Register `DOEPMSK` writer"]
        pub type W = crate::W<DOEPMSK_SPEC>;
        #[doc = "Field `XFRCM` reader - Transfer completed interrupt mask"]
        pub type XFRCM_R = crate::BitReader;
        #[doc = "Field `XFRCM` writer - Transfer completed interrupt mask"]
        pub type XFRCM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EPDM` reader - Endpoint disabled interrupt mask"]
        pub type EPDM_R = crate::BitReader;
        #[doc = "Field `EPDM` writer - Endpoint disabled interrupt mask"]
        pub type EPDM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `STUPM` reader - SETUP phase done mask"]
        pub type STUPM_R = crate::BitReader;
        #[doc = "Field `STUPM` writer - SETUP phase done mask"]
        pub type STUPM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OTEPDM` reader - OUT token received when endpoint disabled mask"]
        pub type OTEPDM_R = crate::BitReader;
        #[doc = "Field `OTEPDM` writer - OUT token received when endpoint disabled mask"]
        pub type OTEPDM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `B2BSTUP` reader - Back-to-back SETUP packets received mask"]
        pub type B2BSTUP_R = crate::BitReader;
        #[doc = "Field `B2BSTUP` writer - Back-to-back SETUP packets received mask"]
        pub type B2BSTUP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OPEM` reader - OUT packet error mask"]
        pub type OPEM_R = crate::BitReader;
        #[doc = "Field `OPEM` writer - OUT packet error mask"]
        pub type OPEM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BOIM` reader - BNA interrupt mask"]
        pub type BOIM_R = crate::BitReader;
        #[doc = "Field `BOIM` writer - BNA interrupt mask"]
        pub type BOIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Transfer completed interrupt mask"]
            #[inline(always)]
            pub fn xfrcm(&self) -> XFRCM_R {
                XFRCM_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Endpoint disabled interrupt mask"]
            #[inline(always)]
            pub fn epdm(&self) -> EPDM_R {
                EPDM_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - SETUP phase done mask"]
            #[inline(always)]
            pub fn stupm(&self) -> STUPM_R {
                STUPM_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - OUT token received when endpoint disabled mask"]
            #[inline(always)]
            pub fn otepdm(&self) -> OTEPDM_R {
                OTEPDM_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - Back-to-back SETUP packets received mask"]
            #[inline(always)]
            pub fn b2bstup(&self) -> B2BSTUP_R {
                B2BSTUP_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - OUT packet error mask"]
            #[inline(always)]
            pub fn opem(&self) -> OPEM_R {
                OPEM_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - BNA interrupt mask"]
            #[inline(always)]
            pub fn boim(&self) -> BOIM_R {
                BOIM_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DOEPMSK")
                    .field("xfrcm", &format_args!("{}", self.xfrcm().bit()))
                    .field("epdm", &format_args!("{}", self.epdm().bit()))
                    .field("stupm", &format_args!("{}", self.stupm().bit()))
                    .field("otepdm", &format_args!("{}", self.otepdm().bit()))
                    .field("b2bstup", &format_args!("{}", self.b2bstup().bit()))
                    .field("opem", &format_args!("{}", self.opem().bit()))
                    .field("boim", &format_args!("{}", self.boim().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DOEPMSK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transfer completed interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn xfrcm(&mut self) -> XFRCM_W<DOEPMSK_SPEC, 0> {
                XFRCM_W::new(self)
            }
            #[doc = "Bit 1 - Endpoint disabled interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn epdm(&mut self) -> EPDM_W<DOEPMSK_SPEC, 1> {
                EPDM_W::new(self)
            }
            #[doc = "Bit 3 - SETUP phase done mask"]
            #[inline(always)]
            #[must_use]
            pub fn stupm(&mut self) -> STUPM_W<DOEPMSK_SPEC, 3> {
                STUPM_W::new(self)
            }
            #[doc = "Bit 4 - OUT token received when endpoint disabled mask"]
            #[inline(always)]
            #[must_use]
            pub fn otepdm(&mut self) -> OTEPDM_W<DOEPMSK_SPEC, 4> {
                OTEPDM_W::new(self)
            }
            #[doc = "Bit 6 - Back-to-back SETUP packets received mask"]
            #[inline(always)]
            #[must_use]
            pub fn b2bstup(&mut self) -> B2BSTUP_W<DOEPMSK_SPEC, 6> {
                B2BSTUP_W::new(self)
            }
            #[doc = "Bit 8 - OUT packet error mask"]
            #[inline(always)]
            #[must_use]
            pub fn opem(&mut self) -> OPEM_W<DOEPMSK_SPEC, 8> {
                OPEM_W::new(self)
            }
            #[doc = "Bit 9 - BNA interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn boim(&mut self) -> BOIM_W<DOEPMSK_SPEC, 9> {
                BOIM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device OUT endpoint common interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepmsk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepmsk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DOEPMSK_SPEC;
        impl crate::RegisterSpec for DOEPMSK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`doepmsk::R`](R) reader structure"]
        impl crate::Readable for DOEPMSK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`doepmsk::W`](W) writer structure"]
        impl crate::Writable for DOEPMSK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DOEPMSK to value 0"]
        impl crate::Resettable for DOEPMSK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DAINT (r) register accessor: OTG_HS device all endpoints interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`daint::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@daint`]
module"]
    pub type DAINT = crate::Reg<daint::DAINT_SPEC>;
    #[doc = "OTG_HS device all endpoints interrupt register"]
    pub mod daint {
        #[doc = "Register `DAINT` reader"]
        pub type R = crate::R<DAINT_SPEC>;
        #[doc = "Field `IEPINT` reader - IN endpoint interrupt bits"]
        pub type IEPINT_R = crate::FieldReader<u16>;
        #[doc = "Field `OEPINT` reader - OUT endpoint interrupt bits"]
        pub type OEPINT_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - IN endpoint interrupt bits"]
            #[inline(always)]
            pub fn iepint(&self) -> IEPINT_R {
                IEPINT_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - OUT endpoint interrupt bits"]
            #[inline(always)]
            pub fn oepint(&self) -> OEPINT_R {
                OEPINT_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DAINT")
                    .field("iepint", &format_args!("{}", self.iepint().bits()))
                    .field("oepint", &format_args!("{}", self.oepint().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DAINT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        #[doc = "OTG_HS device all endpoints interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`daint::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DAINT_SPEC;
        impl crate::RegisterSpec for DAINT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`daint::R`](R) reader structure"]
        impl crate::Readable for DAINT_SPEC {}
        #[doc = "`reset()` method sets DAINT to value 0"]
        impl crate::Resettable for DAINT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DAINTMSK (rw) register accessor: OTG_HS all endpoints interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`daintmsk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`daintmsk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@daintmsk`]
module"]
    pub type DAINTMSK = crate::Reg<daintmsk::DAINTMSK_SPEC>;
    #[doc = "OTG_HS all endpoints interrupt mask register"]
    pub mod daintmsk {
        #[doc = "Register `DAINTMSK` reader"]
        pub type R = crate::R<DAINTMSK_SPEC>;
        #[doc = "Register `DAINTMSK` writer"]
        pub type W = crate::W<DAINTMSK_SPEC>;
        #[doc = "Field `IEPM` reader - IN EP interrupt mask bits"]
        pub type IEPM_R = crate::FieldReader<u16>;
        #[doc = "Field `IEPM` writer - IN EP interrupt mask bits"]
        pub type IEPM_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        #[doc = "Field `OEPM` reader - OUT EP interrupt mask bits"]
        pub type OEPM_R = crate::FieldReader<u16>;
        #[doc = "Field `OEPM` writer - OUT EP interrupt mask bits"]
        pub type OEPM_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN EP interrupt mask bits"]
            #[inline(always)]
            pub fn iepm(&self) -> IEPM_R {
                IEPM_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - OUT EP interrupt mask bits"]
            #[inline(always)]
            pub fn oepm(&self) -> OEPM_R {
                OEPM_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DAINTMSK")
                    .field("iepm", &format_args!("{}", self.iepm().bits()))
                    .field("oepm", &format_args!("{}", self.oepm().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DAINTMSK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN EP interrupt mask bits"]
            #[inline(always)]
            #[must_use]
            pub fn iepm(&mut self) -> IEPM_W<DAINTMSK_SPEC, 0> {
                IEPM_W::new(self)
            }
            #[doc = "Bits 16:31 - OUT EP interrupt mask bits"]
            #[inline(always)]
            #[must_use]
            pub fn oepm(&mut self) -> OEPM_W<DAINTMSK_SPEC, 16> {
                OEPM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS all endpoints interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`daintmsk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`daintmsk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DAINTMSK_SPEC;
        impl crate::RegisterSpec for DAINTMSK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`daintmsk::R`](R) reader structure"]
        impl crate::Readable for DAINTMSK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`daintmsk::W`](W) writer structure"]
        impl crate::Writable for DAINTMSK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DAINTMSK to value 0"]
        impl crate::Resettable for DAINTMSK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DVBUSDIS (rw) register accessor: OTG_HS device VBUS discharge time register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dvbusdis::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dvbusdis::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dvbusdis`]
module"]
    pub type DVBUSDIS = crate::Reg<dvbusdis::DVBUSDIS_SPEC>;
    #[doc = "OTG_HS device VBUS discharge time register"]
    pub mod dvbusdis {
        #[doc = "Register `DVBUSDIS` reader"]
        pub type R = crate::R<DVBUSDIS_SPEC>;
        #[doc = "Register `DVBUSDIS` writer"]
        pub type W = crate::W<DVBUSDIS_SPEC>;
        #[doc = "Field `VBUSDT` reader - Device VBUS discharge time"]
        pub type VBUSDT_R = crate::FieldReader<u16>;
        #[doc = "Field `VBUSDT` writer - Device VBUS discharge time"]
        pub type VBUSDT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - Device VBUS discharge time"]
            #[inline(always)]
            pub fn vbusdt(&self) -> VBUSDT_R {
                VBUSDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DVBUSDIS")
                    .field("vbusdt", &format_args!("{}", self.vbusdt().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DVBUSDIS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Device VBUS discharge time"]
            #[inline(always)]
            #[must_use]
            pub fn vbusdt(&mut self) -> VBUSDT_W<DVBUSDIS_SPEC, 0> {
                VBUSDT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device VBUS discharge time register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dvbusdis::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dvbusdis::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DVBUSDIS_SPEC;
        impl crate::RegisterSpec for DVBUSDIS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dvbusdis::R`](R) reader structure"]
        impl crate::Readable for DVBUSDIS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dvbusdis::W`](W) writer structure"]
        impl crate::Writable for DVBUSDIS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DVBUSDIS to value 0x17d7"]
        impl crate::Resettable for DVBUSDIS_SPEC {
            const RESET_VALUE: Self::Ux = 0x17d7;
        }
    }
    #[doc = "DVBUSPULSE (rw) register accessor: OTG_HS device VBUS pulsing time register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dvbuspulse::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dvbuspulse::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dvbuspulse`]
module"]
    pub type DVBUSPULSE = crate::Reg<dvbuspulse::DVBUSPULSE_SPEC>;
    #[doc = "OTG_HS device VBUS pulsing time register"]
    pub mod dvbuspulse {
        #[doc = "Register `DVBUSPULSE` reader"]
        pub type R = crate::R<DVBUSPULSE_SPEC>;
        #[doc = "Register `DVBUSPULSE` writer"]
        pub type W = crate::W<DVBUSPULSE_SPEC>;
        #[doc = "Field `DVBUSP` reader - Device VBUS pulsing time"]
        pub type DVBUSP_R = crate::FieldReader<u16>;
        #[doc = "Field `DVBUSP` writer - Device VBUS pulsing time"]
        pub type DVBUSP_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 12, O, u16>;
        impl R {
            #[doc = "Bits 0:11 - Device VBUS pulsing time"]
            #[inline(always)]
            pub fn dvbusp(&self) -> DVBUSP_R {
                DVBUSP_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DVBUSPULSE")
                    .field("dvbusp", &format_args!("{}", self.dvbusp().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DVBUSPULSE_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Device VBUS pulsing time"]
            #[inline(always)]
            #[must_use]
            pub fn dvbusp(&mut self) -> DVBUSP_W<DVBUSPULSE_SPEC, 0> {
                DVBUSP_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device VBUS pulsing time register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dvbuspulse::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dvbuspulse::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DVBUSPULSE_SPEC;
        impl crate::RegisterSpec for DVBUSPULSE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dvbuspulse::R`](R) reader structure"]
        impl crate::Readable for DVBUSPULSE_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dvbuspulse::W`](W) writer structure"]
        impl crate::Writable for DVBUSPULSE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DVBUSPULSE to value 0x05b8"]
        impl crate::Resettable for DVBUSPULSE_SPEC {
            const RESET_VALUE: Self::Ux = 0x05b8;
        }
    }
    #[doc = "DTHRCTL (rw) register accessor: OTG_HS Device threshold control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dthrctl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dthrctl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dthrctl`]
module"]
    pub type DTHRCTL = crate::Reg<dthrctl::DTHRCTL_SPEC>;
    #[doc = "OTG_HS Device threshold control register"]
    pub mod dthrctl {
        #[doc = "Register `DTHRCTL` reader"]
        pub type R = crate::R<DTHRCTL_SPEC>;
        #[doc = "Register `DTHRCTL` writer"]
        pub type W = crate::W<DTHRCTL_SPEC>;
        #[doc = "Field `NONISOTHREN` reader - Nonisochronous IN endpoints threshold enable"]
        pub type NONISOTHREN_R = crate::BitReader;
        #[doc = "Field `NONISOTHREN` writer - Nonisochronous IN endpoints threshold enable"]
        pub type NONISOTHREN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ISOTHREN` reader - ISO IN endpoint threshold enable"]
        pub type ISOTHREN_R = crate::BitReader;
        #[doc = "Field `ISOTHREN` writer - ISO IN endpoint threshold enable"]
        pub type ISOTHREN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXTHRLEN` reader - Transmit threshold length"]
        pub type TXTHRLEN_R = crate::FieldReader<u16>;
        #[doc = "Field `TXTHRLEN` writer - Transmit threshold length"]
        pub type TXTHRLEN_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 9, O, u16>;
        #[doc = "Field `RXTHREN` reader - Receive threshold enable"]
        pub type RXTHREN_R = crate::BitReader;
        #[doc = "Field `RXTHREN` writer - Receive threshold enable"]
        pub type RXTHREN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RXTHRLEN` reader - Receive threshold length"]
        pub type RXTHRLEN_R = crate::FieldReader<u16>;
        #[doc = "Field `RXTHRLEN` writer - Receive threshold length"]
        pub type RXTHRLEN_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 9, O, u16>;
        #[doc = "Field `ARPEN` reader - Arbiter parking enable"]
        pub type ARPEN_R = crate::BitReader;
        #[doc = "Field `ARPEN` writer - Arbiter parking enable"]
        pub type ARPEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Nonisochronous IN endpoints threshold enable"]
            #[inline(always)]
            pub fn nonisothren(&self) -> NONISOTHREN_R {
                NONISOTHREN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - ISO IN endpoint threshold enable"]
            #[inline(always)]
            pub fn isothren(&self) -> ISOTHREN_R {
                ISOTHREN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:10 - Transmit threshold length"]
            #[inline(always)]
            pub fn txthrlen(&self) -> TXTHRLEN_R {
                TXTHRLEN_R::new(((self.bits >> 2) & 0x01ff) as u16)
            }
            #[doc = "Bit 16 - Receive threshold enable"]
            #[inline(always)]
            pub fn rxthren(&self) -> RXTHREN_R {
                RXTHREN_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bits 17:25 - Receive threshold length"]
            #[inline(always)]
            pub fn rxthrlen(&self) -> RXTHRLEN_R {
                RXTHRLEN_R::new(((self.bits >> 17) & 0x01ff) as u16)
            }
            #[doc = "Bit 27 - Arbiter parking enable"]
            #[inline(always)]
            pub fn arpen(&self) -> ARPEN_R {
                ARPEN_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DTHRCTL")
                    .field("nonisothren", &format_args!("{}", self.nonisothren().bit()))
                    .field("isothren", &format_args!("{}", self.isothren().bit()))
                    .field("txthrlen", &format_args!("{}", self.txthrlen().bits()))
                    .field("rxthren", &format_args!("{}", self.rxthren().bit()))
                    .field("rxthrlen", &format_args!("{}", self.rxthrlen().bits()))
                    .field("arpen", &format_args!("{}", self.arpen().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DTHRCTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Nonisochronous IN endpoints threshold enable"]
            #[inline(always)]
            #[must_use]
            pub fn nonisothren(&mut self) -> NONISOTHREN_W<DTHRCTL_SPEC, 0> {
                NONISOTHREN_W::new(self)
            }
            #[doc = "Bit 1 - ISO IN endpoint threshold enable"]
            #[inline(always)]
            #[must_use]
            pub fn isothren(&mut self) -> ISOTHREN_W<DTHRCTL_SPEC, 1> {
                ISOTHREN_W::new(self)
            }
            #[doc = "Bits 2:10 - Transmit threshold length"]
            #[inline(always)]
            #[must_use]
            pub fn txthrlen(&mut self) -> TXTHRLEN_W<DTHRCTL_SPEC, 2> {
                TXTHRLEN_W::new(self)
            }
            #[doc = "Bit 16 - Receive threshold enable"]
            #[inline(always)]
            #[must_use]
            pub fn rxthren(&mut self) -> RXTHREN_W<DTHRCTL_SPEC, 16> {
                RXTHREN_W::new(self)
            }
            #[doc = "Bits 17:25 - Receive threshold length"]
            #[inline(always)]
            #[must_use]
            pub fn rxthrlen(&mut self) -> RXTHRLEN_W<DTHRCTL_SPEC, 17> {
                RXTHRLEN_W::new(self)
            }
            #[doc = "Bit 27 - Arbiter parking enable"]
            #[inline(always)]
            #[must_use]
            pub fn arpen(&mut self) -> ARPEN_W<DTHRCTL_SPEC, 27> {
                ARPEN_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS Device threshold control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dthrctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dthrctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DTHRCTL_SPEC;
        impl crate::RegisterSpec for DTHRCTL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dthrctl::R`](R) reader structure"]
        impl crate::Readable for DTHRCTL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dthrctl::W`](W) writer structure"]
        impl crate::Writable for DTHRCTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DTHRCTL to value 0"]
        impl crate::Resettable for DTHRCTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DIEPEMPMSK (rw) register accessor: OTG_HS device IN endpoint FIFO empty interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepempmsk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepempmsk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepempmsk`]
module"]
    pub type DIEPEMPMSK = crate::Reg<diepempmsk::DIEPEMPMSK_SPEC>;
    #[doc = "OTG_HS device IN endpoint FIFO empty interrupt mask register"]
    pub mod diepempmsk {
        #[doc = "Register `DIEPEMPMSK` reader"]
        pub type R = crate::R<DIEPEMPMSK_SPEC>;
        #[doc = "Register `DIEPEMPMSK` writer"]
        pub type W = crate::W<DIEPEMPMSK_SPEC>;
        #[doc = "Field `INEPTXFEM` reader - IN EP Tx FIFO empty interrupt mask bits"]
        pub type INEPTXFEM_R = crate::FieldReader<u16>;
        #[doc = "Field `INEPTXFEM` writer - IN EP Tx FIFO empty interrupt mask bits"]
        pub type INEPTXFEM_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15 - IN EP Tx FIFO empty interrupt mask bits"]
            #[inline(always)]
            pub fn ineptxfem(&self) -> INEPTXFEM_R {
                INEPTXFEM_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPEMPMSK")
                    .field("ineptxfem", &format_args!("{}", self.ineptxfem().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPEMPMSK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - IN EP Tx FIFO empty interrupt mask bits"]
            #[inline(always)]
            #[must_use]
            pub fn ineptxfem(&mut self) -> INEPTXFEM_W<DIEPEMPMSK_SPEC, 0> {
                INEPTXFEM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device IN endpoint FIFO empty interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepempmsk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepempmsk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPEMPMSK_SPEC;
        impl crate::RegisterSpec for DIEPEMPMSK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`diepempmsk::R`](R) reader structure"]
        impl crate::Readable for DIEPEMPMSK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`diepempmsk::W`](W) writer structure"]
        impl crate::Writable for DIEPEMPMSK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPEMPMSK to value 0"]
        impl crate::Resettable for DIEPEMPMSK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DEACHINT (rw) register accessor: OTG_HS device each endpoint interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`deachint::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`deachint::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@deachint`]
module"]
    pub type DEACHINT = crate::Reg<deachint::DEACHINT_SPEC>;
    #[doc = "OTG_HS device each endpoint interrupt register"]
    pub mod deachint {
        #[doc = "Register `DEACHINT` reader"]
        pub type R = crate::R<DEACHINT_SPEC>;
        #[doc = "Register `DEACHINT` writer"]
        pub type W = crate::W<DEACHINT_SPEC>;
        #[doc = "Field `IEP1INT` reader - IN endpoint 1interrupt bit"]
        pub type IEP1INT_R = crate::BitReader;
        #[doc = "Field `IEP1INT` writer - IN endpoint 1interrupt bit"]
        pub type IEP1INT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OEP1INT` reader - OUT endpoint 1 interrupt bit"]
        pub type OEP1INT_R = crate::BitReader;
        #[doc = "Field `OEP1INT` writer - OUT endpoint 1 interrupt bit"]
        pub type OEP1INT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 1 - IN endpoint 1interrupt bit"]
            #[inline(always)]
            pub fn iep1int(&self) -> IEP1INT_R {
                IEP1INT_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 17 - OUT endpoint 1 interrupt bit"]
            #[inline(always)]
            pub fn oep1int(&self) -> OEP1INT_R {
                OEP1INT_R::new(((self.bits >> 17) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DEACHINT")
                    .field("iep1int", &format_args!("{}", self.iep1int().bit()))
                    .field("oep1int", &format_args!("{}", self.oep1int().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DEACHINT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - IN endpoint 1interrupt bit"]
            #[inline(always)]
            #[must_use]
            pub fn iep1int(&mut self) -> IEP1INT_W<DEACHINT_SPEC, 1> {
                IEP1INT_W::new(self)
            }
            #[doc = "Bit 17 - OUT endpoint 1 interrupt bit"]
            #[inline(always)]
            #[must_use]
            pub fn oep1int(&mut self) -> OEP1INT_W<DEACHINT_SPEC, 17> {
                OEP1INT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device each endpoint interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`deachint::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`deachint::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DEACHINT_SPEC;
        impl crate::RegisterSpec for DEACHINT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`deachint::R`](R) reader structure"]
        impl crate::Readable for DEACHINT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`deachint::W`](W) writer structure"]
        impl crate::Writable for DEACHINT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DEACHINT to value 0"]
        impl crate::Resettable for DEACHINT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DEACHINTMSK (rw) register accessor: OTG_HS device each endpoint interrupt register mask\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`deachintmsk::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`deachintmsk::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@deachintmsk`]
module"]
    pub type DEACHINTMSK = crate::Reg<deachintmsk::DEACHINTMSK_SPEC>;
    #[doc = "OTG_HS device each endpoint interrupt register mask"]
    pub mod deachintmsk {
        #[doc = "Register `DEACHINTMSK` reader"]
        pub type R = crate::R<DEACHINTMSK_SPEC>;
        #[doc = "Register `DEACHINTMSK` writer"]
        pub type W = crate::W<DEACHINTMSK_SPEC>;
        #[doc = "Field `IEP1INTM` reader - IN Endpoint 1 interrupt mask bit"]
        pub type IEP1INTM_R = crate::BitReader;
        #[doc = "Field `IEP1INTM` writer - IN Endpoint 1 interrupt mask bit"]
        pub type IEP1INTM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `OEP1INTM` reader - OUT Endpoint 1 interrupt mask bit"]
        pub type OEP1INTM_R = crate::BitReader;
        #[doc = "Field `OEP1INTM` writer - OUT Endpoint 1 interrupt mask bit"]
        pub type OEP1INTM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 1 - IN Endpoint 1 interrupt mask bit"]
            #[inline(always)]
            pub fn iep1intm(&self) -> IEP1INTM_R {
                IEP1INTM_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 17 - OUT Endpoint 1 interrupt mask bit"]
            #[inline(always)]
            pub fn oep1intm(&self) -> OEP1INTM_R {
                OEP1INTM_R::new(((self.bits >> 17) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DEACHINTMSK")
                    .field("iep1intm", &format_args!("{}", self.iep1intm().bit()))
                    .field("oep1intm", &format_args!("{}", self.oep1intm().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DEACHINTMSK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - IN Endpoint 1 interrupt mask bit"]
            #[inline(always)]
            #[must_use]
            pub fn iep1intm(&mut self) -> IEP1INTM_W<DEACHINTMSK_SPEC, 1> {
                IEP1INTM_W::new(self)
            }
            #[doc = "Bit 17 - OUT Endpoint 1 interrupt mask bit"]
            #[inline(always)]
            #[must_use]
            pub fn oep1intm(&mut self) -> OEP1INTM_W<DEACHINTMSK_SPEC, 17> {
                OEP1INTM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device each endpoint interrupt register mask\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`deachintmsk::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`deachintmsk::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DEACHINTMSK_SPEC;
        impl crate::RegisterSpec for DEACHINTMSK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`deachintmsk::R`](R) reader structure"]
        impl crate::Readable for DEACHINTMSK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`deachintmsk::W`](W) writer structure"]
        impl crate::Writable for DEACHINTMSK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DEACHINTMSK to value 0"]
        impl crate::Resettable for DEACHINTMSK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DIEPEACHMSK1 (rw) register accessor: OTG_HS device each in endpoint-1 interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepeachmsk1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepeachmsk1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepeachmsk1`]
module"]
    pub type DIEPEACHMSK1 = crate::Reg<diepeachmsk1::DIEPEACHMSK1_SPEC>;
    #[doc = "OTG_HS device each in endpoint-1 interrupt register"]
    pub mod diepeachmsk1 {
        #[doc = "Register `DIEPEACHMSK1` reader"]
        pub type R = crate::R<DIEPEACHMSK1_SPEC>;
        #[doc = "Register `DIEPEACHMSK1` writer"]
        pub type W = crate::W<DIEPEACHMSK1_SPEC>;
        #[doc = "Field `XFRCM` reader - Transfer completed interrupt mask"]
        pub type XFRCM_R = crate::BitReader;
        #[doc = "Field `XFRCM` writer - Transfer completed interrupt mask"]
        pub type XFRCM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EPDM` reader - Endpoint disabled interrupt mask"]
        pub type EPDM_R = crate::BitReader;
        #[doc = "Field `EPDM` writer - Endpoint disabled interrupt mask"]
        pub type EPDM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TOM` reader - Timeout condition mask (nonisochronous endpoints)"]
        pub type TOM_R = crate::BitReader;
        #[doc = "Field `TOM` writer - Timeout condition mask (nonisochronous endpoints)"]
        pub type TOM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ITTXFEMSK` reader - IN token received when TxFIFO empty mask"]
        pub type ITTXFEMSK_R = crate::BitReader;
        #[doc = "Field `ITTXFEMSK` writer - IN token received when TxFIFO empty mask"]
        pub type ITTXFEMSK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INEPNMM` reader - IN token received with EP mismatch mask"]
        pub type INEPNMM_R = crate::BitReader;
        #[doc = "Field `INEPNMM` writer - IN token received with EP mismatch mask"]
        pub type INEPNMM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INEPNEM` reader - IN endpoint NAK effective mask"]
        pub type INEPNEM_R = crate::BitReader;
        #[doc = "Field `INEPNEM` writer - IN endpoint NAK effective mask"]
        pub type INEPNEM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXFURM` reader - FIFO underrun mask"]
        pub type TXFURM_R = crate::BitReader;
        #[doc = "Field `TXFURM` writer - FIFO underrun mask"]
        pub type TXFURM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BIM` reader - BNA interrupt mask"]
        pub type BIM_R = crate::BitReader;
        #[doc = "Field `BIM` writer - BNA interrupt mask"]
        pub type BIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `NAKM` reader - NAK interrupt mask"]
        pub type NAKM_R = crate::BitReader;
        #[doc = "Field `NAKM` writer - NAK interrupt mask"]
        pub type NAKM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Transfer completed interrupt mask"]
            #[inline(always)]
            pub fn xfrcm(&self) -> XFRCM_R {
                XFRCM_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Endpoint disabled interrupt mask"]
            #[inline(always)]
            pub fn epdm(&self) -> EPDM_R {
                EPDM_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - Timeout condition mask (nonisochronous endpoints)"]
            #[inline(always)]
            pub fn tom(&self) -> TOM_R {
                TOM_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - IN token received when TxFIFO empty mask"]
            #[inline(always)]
            pub fn ittxfemsk(&self) -> ITTXFEMSK_R {
                ITTXFEMSK_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - IN token received with EP mismatch mask"]
            #[inline(always)]
            pub fn inepnmm(&self) -> INEPNMM_R {
                INEPNMM_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - IN endpoint NAK effective mask"]
            #[inline(always)]
            pub fn inepnem(&self) -> INEPNEM_R {
                INEPNEM_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - FIFO underrun mask"]
            #[inline(always)]
            pub fn txfurm(&self) -> TXFURM_R {
                TXFURM_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - BNA interrupt mask"]
            #[inline(always)]
            pub fn bim(&self) -> BIM_R {
                BIM_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 13 - NAK interrupt mask"]
            #[inline(always)]
            pub fn nakm(&self) -> NAKM_R {
                NAKM_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIEPEACHMSK1")
                    .field("xfrcm", &format_args!("{}", self.xfrcm().bit()))
                    .field("epdm", &format_args!("{}", self.epdm().bit()))
                    .field("tom", &format_args!("{}", self.tom().bit()))
                    .field("ittxfemsk", &format_args!("{}", self.ittxfemsk().bit()))
                    .field("inepnmm", &format_args!("{}", self.inepnmm().bit()))
                    .field("inepnem", &format_args!("{}", self.inepnem().bit()))
                    .field("txfurm", &format_args!("{}", self.txfurm().bit()))
                    .field("bim", &format_args!("{}", self.bim().bit()))
                    .field("nakm", &format_args!("{}", self.nakm().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIEPEACHMSK1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transfer completed interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn xfrcm(&mut self) -> XFRCM_W<DIEPEACHMSK1_SPEC, 0> {
                XFRCM_W::new(self)
            }
            #[doc = "Bit 1 - Endpoint disabled interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn epdm(&mut self) -> EPDM_W<DIEPEACHMSK1_SPEC, 1> {
                EPDM_W::new(self)
            }
            #[doc = "Bit 3 - Timeout condition mask (nonisochronous endpoints)"]
            #[inline(always)]
            #[must_use]
            pub fn tom(&mut self) -> TOM_W<DIEPEACHMSK1_SPEC, 3> {
                TOM_W::new(self)
            }
            #[doc = "Bit 4 - IN token received when TxFIFO empty mask"]
            #[inline(always)]
            #[must_use]
            pub fn ittxfemsk(&mut self) -> ITTXFEMSK_W<DIEPEACHMSK1_SPEC, 4> {
                ITTXFEMSK_W::new(self)
            }
            #[doc = "Bit 5 - IN token received with EP mismatch mask"]
            #[inline(always)]
            #[must_use]
            pub fn inepnmm(&mut self) -> INEPNMM_W<DIEPEACHMSK1_SPEC, 5> {
                INEPNMM_W::new(self)
            }
            #[doc = "Bit 6 - IN endpoint NAK effective mask"]
            #[inline(always)]
            #[must_use]
            pub fn inepnem(&mut self) -> INEPNEM_W<DIEPEACHMSK1_SPEC, 6> {
                INEPNEM_W::new(self)
            }
            #[doc = "Bit 8 - FIFO underrun mask"]
            #[inline(always)]
            #[must_use]
            pub fn txfurm(&mut self) -> TXFURM_W<DIEPEACHMSK1_SPEC, 8> {
                TXFURM_W::new(self)
            }
            #[doc = "Bit 9 - BNA interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn bim(&mut self) -> BIM_W<DIEPEACHMSK1_SPEC, 9> {
                BIM_W::new(self)
            }
            #[doc = "Bit 13 - NAK interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn nakm(&mut self) -> NAKM_W<DIEPEACHMSK1_SPEC, 13> {
                NAKM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device each in endpoint-1 interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepeachmsk1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepeachmsk1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DIEPEACHMSK1_SPEC;
        impl crate::RegisterSpec for DIEPEACHMSK1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`diepeachmsk1::R`](R) reader structure"]
        impl crate::Readable for DIEPEACHMSK1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`diepeachmsk1::W`](W) writer structure"]
        impl crate::Writable for DIEPEACHMSK1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DIEPEACHMSK1 to value 0"]
        impl crate::Resettable for DIEPEACHMSK1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DOEPEACHMSK1 (rw) register accessor: OTG_HS device each OUT endpoint-1 interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepeachmsk1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepeachmsk1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepeachmsk1`]
module"]
    pub type DOEPEACHMSK1 = crate::Reg<doepeachmsk1::DOEPEACHMSK1_SPEC>;
    #[doc = "OTG_HS device each OUT endpoint-1 interrupt register"]
    pub mod doepeachmsk1 {
        #[doc = "Register `DOEPEACHMSK1` reader"]
        pub type R = crate::R<DOEPEACHMSK1_SPEC>;
        #[doc = "Register `DOEPEACHMSK1` writer"]
        pub type W = crate::W<DOEPEACHMSK1_SPEC>;
        #[doc = "Field `XFRCM` reader - Transfer completed interrupt mask"]
        pub type XFRCM_R = crate::BitReader;
        #[doc = "Field `XFRCM` writer - Transfer completed interrupt mask"]
        pub type XFRCM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EPDM` reader - Endpoint disabled interrupt mask"]
        pub type EPDM_R = crate::BitReader;
        #[doc = "Field `EPDM` writer - Endpoint disabled interrupt mask"]
        pub type EPDM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TOM` reader - Timeout condition mask"]
        pub type TOM_R = crate::BitReader;
        #[doc = "Field `TOM` writer - Timeout condition mask"]
        pub type TOM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ITTXFEMSK` reader - IN token received when TxFIFO empty mask"]
        pub type ITTXFEMSK_R = crate::BitReader;
        #[doc = "Field `ITTXFEMSK` writer - IN token received when TxFIFO empty mask"]
        pub type ITTXFEMSK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INEPNMM` reader - IN token received with EP mismatch mask"]
        pub type INEPNMM_R = crate::BitReader;
        #[doc = "Field `INEPNMM` writer - IN token received with EP mismatch mask"]
        pub type INEPNMM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `INEPNEM` reader - IN endpoint NAK effective mask"]
        pub type INEPNEM_R = crate::BitReader;
        #[doc = "Field `INEPNEM` writer - IN endpoint NAK effective mask"]
        pub type INEPNEM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TXFURM` reader - OUT packet error mask"]
        pub type TXFURM_R = crate::BitReader;
        #[doc = "Field `TXFURM` writer - OUT packet error mask"]
        pub type TXFURM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BIM` reader - BNA interrupt mask"]
        pub type BIM_R = crate::BitReader;
        #[doc = "Field `BIM` writer - BNA interrupt mask"]
        pub type BIM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BERRM` reader - Bubble error interrupt mask"]
        pub type BERRM_R = crate::BitReader;
        #[doc = "Field `BERRM` writer - Bubble error interrupt mask"]
        pub type BERRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `NAKM` reader - NAK interrupt mask"]
        pub type NAKM_R = crate::BitReader;
        #[doc = "Field `NAKM` writer - NAK interrupt mask"]
        pub type NAKM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `NYETM` reader - NYET interrupt mask"]
        pub type NYETM_R = crate::BitReader;
        #[doc = "Field `NYETM` writer - NYET interrupt mask"]
        pub type NYETM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Transfer completed interrupt mask"]
            #[inline(always)]
            pub fn xfrcm(&self) -> XFRCM_R {
                XFRCM_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Endpoint disabled interrupt mask"]
            #[inline(always)]
            pub fn epdm(&self) -> EPDM_R {
                EPDM_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - Timeout condition mask"]
            #[inline(always)]
            pub fn tom(&self) -> TOM_R {
                TOM_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - IN token received when TxFIFO empty mask"]
            #[inline(always)]
            pub fn ittxfemsk(&self) -> ITTXFEMSK_R {
                ITTXFEMSK_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - IN token received with EP mismatch mask"]
            #[inline(always)]
            pub fn inepnmm(&self) -> INEPNMM_R {
                INEPNMM_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - IN endpoint NAK effective mask"]
            #[inline(always)]
            pub fn inepnem(&self) -> INEPNEM_R {
                INEPNEM_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - OUT packet error mask"]
            #[inline(always)]
            pub fn txfurm(&self) -> TXFURM_R {
                TXFURM_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - BNA interrupt mask"]
            #[inline(always)]
            pub fn bim(&self) -> BIM_R {
                BIM_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 12 - Bubble error interrupt mask"]
            #[inline(always)]
            pub fn berrm(&self) -> BERRM_R {
                BERRM_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - NAK interrupt mask"]
            #[inline(always)]
            pub fn nakm(&self) -> NAKM_R {
                NAKM_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - NYET interrupt mask"]
            #[inline(always)]
            pub fn nyetm(&self) -> NYETM_R {
                NYETM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DOEPEACHMSK1")
                    .field("xfrcm", &format_args!("{}", self.xfrcm().bit()))
                    .field("epdm", &format_args!("{}", self.epdm().bit()))
                    .field("tom", &format_args!("{}", self.tom().bit()))
                    .field("ittxfemsk", &format_args!("{}", self.ittxfemsk().bit()))
                    .field("inepnmm", &format_args!("{}", self.inepnmm().bit()))
                    .field("inepnem", &format_args!("{}", self.inepnem().bit()))
                    .field("txfurm", &format_args!("{}", self.txfurm().bit()))
                    .field("bim", &format_args!("{}", self.bim().bit()))
                    .field("berrm", &format_args!("{}", self.berrm().bit()))
                    .field("nakm", &format_args!("{}", self.nakm().bit()))
                    .field("nyetm", &format_args!("{}", self.nyetm().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DOEPEACHMSK1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transfer completed interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn xfrcm(&mut self) -> XFRCM_W<DOEPEACHMSK1_SPEC, 0> {
                XFRCM_W::new(self)
            }
            #[doc = "Bit 1 - Endpoint disabled interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn epdm(&mut self) -> EPDM_W<DOEPEACHMSK1_SPEC, 1> {
                EPDM_W::new(self)
            }
            #[doc = "Bit 3 - Timeout condition mask"]
            #[inline(always)]
            #[must_use]
            pub fn tom(&mut self) -> TOM_W<DOEPEACHMSK1_SPEC, 3> {
                TOM_W::new(self)
            }
            #[doc = "Bit 4 - IN token received when TxFIFO empty mask"]
            #[inline(always)]
            #[must_use]
            pub fn ittxfemsk(&mut self) -> ITTXFEMSK_W<DOEPEACHMSK1_SPEC, 4> {
                ITTXFEMSK_W::new(self)
            }
            #[doc = "Bit 5 - IN token received with EP mismatch mask"]
            #[inline(always)]
            #[must_use]
            pub fn inepnmm(&mut self) -> INEPNMM_W<DOEPEACHMSK1_SPEC, 5> {
                INEPNMM_W::new(self)
            }
            #[doc = "Bit 6 - IN endpoint NAK effective mask"]
            #[inline(always)]
            #[must_use]
            pub fn inepnem(&mut self) -> INEPNEM_W<DOEPEACHMSK1_SPEC, 6> {
                INEPNEM_W::new(self)
            }
            #[doc = "Bit 8 - OUT packet error mask"]
            #[inline(always)]
            #[must_use]
            pub fn txfurm(&mut self) -> TXFURM_W<DOEPEACHMSK1_SPEC, 8> {
                TXFURM_W::new(self)
            }
            #[doc = "Bit 9 - BNA interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn bim(&mut self) -> BIM_W<DOEPEACHMSK1_SPEC, 9> {
                BIM_W::new(self)
            }
            #[doc = "Bit 12 - Bubble error interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn berrm(&mut self) -> BERRM_W<DOEPEACHMSK1_SPEC, 12> {
                BERRM_W::new(self)
            }
            #[doc = "Bit 13 - NAK interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn nakm(&mut self) -> NAKM_W<DOEPEACHMSK1_SPEC, 13> {
                NAKM_W::new(self)
            }
            #[doc = "Bit 14 - NYET interrupt mask"]
            #[inline(always)]
            #[must_use]
            pub fn nyetm(&mut self) -> NYETM_W<DOEPEACHMSK1_SPEC, 14> {
                NYETM_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "OTG_HS device each OUT endpoint-1 interrupt register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepeachmsk1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepeachmsk1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DOEPEACHMSK1_SPEC;
        impl crate::RegisterSpec for DOEPEACHMSK1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`doepeachmsk1::R`](R) reader structure"]
        impl crate::Readable for DOEPEACHMSK1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`doepeachmsk1::W`](W) writer structure"]
        impl crate::Writable for DOEPEACHMSK1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DOEPEACHMSK1 to value 0"]
        impl crate::Resettable for DOEPEACHMSK1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IN Endpoint %s"]
    pub use self::in_endpoint::IN_ENDPOINT;
    #[doc = r"Cluster"]
    #[doc = "IN Endpoint %s"]
    pub mod in_endpoint {
        #[doc = r"Register block"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IN_ENDPOINT {
            #[doc = "0x00 - Control"]
            pub diepctl0: DIEPCTL0,
            _reserved1: [u8; 0x04],
            #[doc = "0x08 - Interrupt"]
            pub diepint: DIEPINT,
            _reserved2: [u8; 0x04],
            #[doc = "0x10 - Transfer size"]
            pub dieptsiz: DIEPTSIZ,
            #[doc = "0x14 - DMA address"]
            pub diepdma: DIEPDMA,
            #[doc = "0x18 - Transmit FIFO status"]
            pub dtxfsts: DTXFSTS,
        }
        #[doc = "DIEPCTL0 (rw) register accessor: Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepctl0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepctl0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepctl0`]
module"]
        pub type DIEPCTL0 = crate::Reg<diepctl0::DIEPCTL0_SPEC>;
        #[doc = "Control"]
        pub mod diepctl0 {
            #[doc = "Register `DIEPCTL0` reader"]
            pub type R = crate::R<DIEPCTL0_SPEC>;
            #[doc = "Register `DIEPCTL0` writer"]
            pub type W = crate::W<DIEPCTL0_SPEC>;
            #[doc = "Field `MPSIZ` reader - Maximum packet size"]
            pub type MPSIZ_R = crate::FieldReader<u16>;
            #[doc = "Field `MPSIZ` writer - Maximum packet size"]
            pub type MPSIZ_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 11, O, u16>;
            #[doc = "Field `USBAEP` reader - USB active endpoint"]
            pub type USBAEP_R = crate::BitReader;
            #[doc = "Field `USBAEP` writer - USB active endpoint"]
            pub type USBAEP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `EONUM_DPID` reader - Even/odd frame"]
            pub type EONUM_DPID_R = crate::BitReader;
            #[doc = "Field `NAKSTS` reader - NAK status"]
            pub type NAKSTS_R = crate::BitReader;
            #[doc = "Field `EPTYP` reader - Endpoint type"]
            pub type EPTYP_R = crate::FieldReader;
            #[doc = "Field `EPTYP` writer - Endpoint type"]
            pub type EPTYP_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
            #[doc = "Field `Stall` reader - STALL handshake"]
            pub type STALL_R = crate::BitReader;
            #[doc = "Field `Stall` writer - STALL handshake"]
            pub type STALL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `TXFNUM` reader - TxFIFO number"]
            pub type TXFNUM_R = crate::FieldReader;
            #[doc = "Field `TXFNUM` writer - TxFIFO number"]
            pub type TXFNUM_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
            #[doc = "Field `CNAK` writer - Clear NAK"]
            pub type CNAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `SNAK` writer - Set NAK"]
            pub type SNAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `SD0PID_SEVNFRM` writer - Set DATA0 PID"]
            pub type SD0PID_SEVNFRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `SODDFRM` writer - Set odd frame"]
            pub type SODDFRM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `EPDIS` reader - Endpoint disable"]
            pub type EPDIS_R = crate::BitReader;
            #[doc = "Field `EPDIS` writer - Endpoint disable"]
            pub type EPDIS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `EPENA` reader - Endpoint enable"]
            pub type EPENA_R = crate::BitReader;
            #[doc = "Field `EPENA` writer - Endpoint enable"]
            pub type EPENA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            impl R {
                #[doc = "Bits 0:10 - Maximum packet size"]
                #[inline(always)]
                pub fn mpsiz(&self) -> MPSIZ_R {
                    MPSIZ_R::new((self.bits & 0x07ff) as u16)
                }
                #[doc = "Bit 15 - USB active endpoint"]
                #[inline(always)]
                pub fn usbaep(&self) -> USBAEP_R {
                    USBAEP_R::new(((self.bits >> 15) & 1) != 0)
                }
                #[doc = "Bit 16 - Even/odd frame"]
                #[inline(always)]
                pub fn eonum_dpid(&self) -> EONUM_DPID_R {
                    EONUM_DPID_R::new(((self.bits >> 16) & 1) != 0)
                }
                #[doc = "Bit 17 - NAK status"]
                #[inline(always)]
                pub fn naksts(&self) -> NAKSTS_R {
                    NAKSTS_R::new(((self.bits >> 17) & 1) != 0)
                }
                #[doc = "Bits 18:19 - Endpoint type"]
                #[inline(always)]
                pub fn eptyp(&self) -> EPTYP_R {
                    EPTYP_R::new(((self.bits >> 18) & 3) as u8)
                }
                #[doc = "Bit 21 - STALL handshake"]
                #[inline(always)]
                pub fn stall(&self) -> STALL_R {
                    STALL_R::new(((self.bits >> 21) & 1) != 0)
                }
                #[doc = "Bits 22:25 - TxFIFO number"]
                #[inline(always)]
                pub fn txfnum(&self) -> TXFNUM_R {
                    TXFNUM_R::new(((self.bits >> 22) & 0x0f) as u8)
                }
                #[doc = "Bit 30 - Endpoint disable"]
                #[inline(always)]
                pub fn epdis(&self) -> EPDIS_R {
                    EPDIS_R::new(((self.bits >> 30) & 1) != 0)
                }
                #[doc = "Bit 31 - Endpoint enable"]
                #[inline(always)]
                pub fn epena(&self) -> EPENA_R {
                    EPENA_R::new(((self.bits >> 31) & 1) != 0)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DIEPCTL0")
                        .field("mpsiz", &format_args!("{}", self.mpsiz().bits()))
                        .field("usbaep", &format_args!("{}", self.usbaep().bit()))
                        .field("eonum_dpid", &format_args!("{}", self.eonum_dpid().bit()))
                        .field("naksts", &format_args!("{}", self.naksts().bit()))
                        .field("eptyp", &format_args!("{}", self.eptyp().bits()))
                        .field("stall", &format_args!("{}", self.stall().bit()))
                        .field("txfnum", &format_args!("{}", self.txfnum().bits()))
                        .field("epdis", &format_args!("{}", self.epdis().bit()))
                        .field("epena", &format_args!("{}", self.epena().bit()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DIEPCTL0_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:10 - Maximum packet size"]
                #[inline(always)]
                #[must_use]
                pub fn mpsiz(&mut self) -> MPSIZ_W<DIEPCTL0_SPEC, 0> {
                    MPSIZ_W::new(self)
                }
                #[doc = "Bit 15 - USB active endpoint"]
                #[inline(always)]
                #[must_use]
                pub fn usbaep(&mut self) -> USBAEP_W<DIEPCTL0_SPEC, 15> {
                    USBAEP_W::new(self)
                }
                #[doc = "Bits 18:19 - Endpoint type"]
                #[inline(always)]
                #[must_use]
                pub fn eptyp(&mut self) -> EPTYP_W<DIEPCTL0_SPEC, 18> {
                    EPTYP_W::new(self)
                }
                #[doc = "Bit 21 - STALL handshake"]
                #[inline(always)]
                #[must_use]
                pub fn stall(&mut self) -> STALL_W<DIEPCTL0_SPEC, 21> {
                    STALL_W::new(self)
                }
                #[doc = "Bits 22:25 - TxFIFO number"]
                #[inline(always)]
                #[must_use]
                pub fn txfnum(&mut self) -> TXFNUM_W<DIEPCTL0_SPEC, 22> {
                    TXFNUM_W::new(self)
                }
                #[doc = "Bit 26 - Clear NAK"]
                #[inline(always)]
                #[must_use]
                pub fn cnak(&mut self) -> CNAK_W<DIEPCTL0_SPEC, 26> {
                    CNAK_W::new(self)
                }
                #[doc = "Bit 27 - Set NAK"]
                #[inline(always)]
                #[must_use]
                pub fn snak(&mut self) -> SNAK_W<DIEPCTL0_SPEC, 27> {
                    SNAK_W::new(self)
                }
                #[doc = "Bit 28 - Set DATA0 PID"]
                #[inline(always)]
                #[must_use]
                pub fn sd0pid_sevnfrm(&mut self) -> SD0PID_SEVNFRM_W<DIEPCTL0_SPEC, 28> {
                    SD0PID_SEVNFRM_W::new(self)
                }
                #[doc = "Bit 29 - Set odd frame"]
                #[inline(always)]
                #[must_use]
                pub fn soddfrm(&mut self) -> SODDFRM_W<DIEPCTL0_SPEC, 29> {
                    SODDFRM_W::new(self)
                }
                #[doc = "Bit 30 - Endpoint disable"]
                #[inline(always)]
                #[must_use]
                pub fn epdis(&mut self) -> EPDIS_W<DIEPCTL0_SPEC, 30> {
                    EPDIS_W::new(self)
                }
                #[doc = "Bit 31 - Endpoint enable"]
                #[inline(always)]
                #[must_use]
                pub fn epena(&mut self) -> EPENA_W<DIEPCTL0_SPEC, 31> {
                    EPENA_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepctl0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepctl0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DIEPCTL0_SPEC;
            impl crate::RegisterSpec for DIEPCTL0_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`diepctl0::R`](R) reader structure"]
            impl crate::Readable for DIEPCTL0_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`diepctl0::W`](W) writer structure"]
            impl crate::Writable for DIEPCTL0_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets DIEPCTL0 to value 0"]
            impl crate::Resettable for DIEPCTL0_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "DIEPINT (rw) register accessor: Interrupt\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepint::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepint::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepint`]
module"]
        pub type DIEPINT = crate::Reg<diepint::DIEPINT_SPEC>;
        #[doc = "Interrupt"]
        pub mod diepint {
            #[doc = "Register `DIEPINT` reader"]
            pub type R = crate::R<DIEPINT_SPEC>;
            #[doc = "Register `DIEPINT` writer"]
            pub type W = crate::W<DIEPINT_SPEC>;
            #[doc = "Field `XFRC` reader - Transfer completed interrupt"]
            pub type XFRC_R = crate::BitReader;
            #[doc = "Field `XFRC` writer - Transfer completed interrupt"]
            pub type XFRC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `EPDISD` reader - Endpoint disabled interrupt"]
            pub type EPDISD_R = crate::BitReader;
            #[doc = "Field `EPDISD` writer - Endpoint disabled interrupt"]
            pub type EPDISD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `TOC` reader - Timeout condition"]
            pub type TOC_R = crate::BitReader;
            #[doc = "Field `TOC` writer - Timeout condition"]
            pub type TOC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `ITTXFE` reader - IN token received when TxFIFO is empty"]
            pub type ITTXFE_R = crate::BitReader;
            #[doc = "Field `ITTXFE` writer - IN token received when TxFIFO is empty"]
            pub type ITTXFE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `INEPNE` reader - IN endpoint NAK effective"]
            pub type INEPNE_R = crate::BitReader;
            #[doc = "Field `INEPNE` writer - IN endpoint NAK effective"]
            pub type INEPNE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `TXFE` reader - Transmit FIFO empty"]
            pub type TXFE_R = crate::BitReader;
            #[doc = "Field `TXFIFOUDRN` reader - Transmit Fifo Underrun"]
            pub type TXFIFOUDRN_R = crate::BitReader;
            #[doc = "Field `TXFIFOUDRN` writer - Transmit Fifo Underrun"]
            pub type TXFIFOUDRN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `BNA` reader - Buffer not available interrupt"]
            pub type BNA_R = crate::BitReader;
            #[doc = "Field `BNA` writer - Buffer not available interrupt"]
            pub type BNA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `PKTDRPSTS` reader - Packet dropped status"]
            pub type PKTDRPSTS_R = crate::BitReader;
            #[doc = "Field `PKTDRPSTS` writer - Packet dropped status"]
            pub type PKTDRPSTS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `BERR` reader - Babble error interrupt"]
            pub type BERR_R = crate::BitReader;
            #[doc = "Field `BERR` writer - Babble error interrupt"]
            pub type BERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `NAK` reader - NAK interrupt"]
            pub type NAK_R = crate::BitReader;
            #[doc = "Field `NAK` writer - NAK interrupt"]
            pub type NAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            impl R {
                #[doc = "Bit 0 - Transfer completed interrupt"]
                #[inline(always)]
                pub fn xfrc(&self) -> XFRC_R {
                    XFRC_R::new((self.bits & 1) != 0)
                }
                #[doc = "Bit 1 - Endpoint disabled interrupt"]
                #[inline(always)]
                pub fn epdisd(&self) -> EPDISD_R {
                    EPDISD_R::new(((self.bits >> 1) & 1) != 0)
                }
                #[doc = "Bit 3 - Timeout condition"]
                #[inline(always)]
                pub fn toc(&self) -> TOC_R {
                    TOC_R::new(((self.bits >> 3) & 1) != 0)
                }
                #[doc = "Bit 4 - IN token received when TxFIFO is empty"]
                #[inline(always)]
                pub fn ittxfe(&self) -> ITTXFE_R {
                    ITTXFE_R::new(((self.bits >> 4) & 1) != 0)
                }
                #[doc = "Bit 6 - IN endpoint NAK effective"]
                #[inline(always)]
                pub fn inepne(&self) -> INEPNE_R {
                    INEPNE_R::new(((self.bits >> 6) & 1) != 0)
                }
                #[doc = "Bit 7 - Transmit FIFO empty"]
                #[inline(always)]
                pub fn txfe(&self) -> TXFE_R {
                    TXFE_R::new(((self.bits >> 7) & 1) != 0)
                }
                #[doc = "Bit 8 - Transmit Fifo Underrun"]
                #[inline(always)]
                pub fn txfifoudrn(&self) -> TXFIFOUDRN_R {
                    TXFIFOUDRN_R::new(((self.bits >> 8) & 1) != 0)
                }
                #[doc = "Bit 9 - Buffer not available interrupt"]
                #[inline(always)]
                pub fn bna(&self) -> BNA_R {
                    BNA_R::new(((self.bits >> 9) & 1) != 0)
                }
                #[doc = "Bit 11 - Packet dropped status"]
                #[inline(always)]
                pub fn pktdrpsts(&self) -> PKTDRPSTS_R {
                    PKTDRPSTS_R::new(((self.bits >> 11) & 1) != 0)
                }
                #[doc = "Bit 12 - Babble error interrupt"]
                #[inline(always)]
                pub fn berr(&self) -> BERR_R {
                    BERR_R::new(((self.bits >> 12) & 1) != 0)
                }
                #[doc = "Bit 13 - NAK interrupt"]
                #[inline(always)]
                pub fn nak(&self) -> NAK_R {
                    NAK_R::new(((self.bits >> 13) & 1) != 0)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DIEPINT")
                        .field("xfrc", &format_args!("{}", self.xfrc().bit()))
                        .field("epdisd", &format_args!("{}", self.epdisd().bit()))
                        .field("toc", &format_args!("{}", self.toc().bit()))
                        .field("ittxfe", &format_args!("{}", self.ittxfe().bit()))
                        .field("inepne", &format_args!("{}", self.inepne().bit()))
                        .field("txfe", &format_args!("{}", self.txfe().bit()))
                        .field("txfifoudrn", &format_args!("{}", self.txfifoudrn().bit()))
                        .field("bna", &format_args!("{}", self.bna().bit()))
                        .field("pktdrpsts", &format_args!("{}", self.pktdrpsts().bit()))
                        .field("berr", &format_args!("{}", self.berr().bit()))
                        .field("nak", &format_args!("{}", self.nak().bit()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DIEPINT_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bit 0 - Transfer completed interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn xfrc(&mut self) -> XFRC_W<DIEPINT_SPEC, 0> {
                    XFRC_W::new(self)
                }
                #[doc = "Bit 1 - Endpoint disabled interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn epdisd(&mut self) -> EPDISD_W<DIEPINT_SPEC, 1> {
                    EPDISD_W::new(self)
                }
                #[doc = "Bit 3 - Timeout condition"]
                #[inline(always)]
                #[must_use]
                pub fn toc(&mut self) -> TOC_W<DIEPINT_SPEC, 3> {
                    TOC_W::new(self)
                }
                #[doc = "Bit 4 - IN token received when TxFIFO is empty"]
                #[inline(always)]
                #[must_use]
                pub fn ittxfe(&mut self) -> ITTXFE_W<DIEPINT_SPEC, 4> {
                    ITTXFE_W::new(self)
                }
                #[doc = "Bit 6 - IN endpoint NAK effective"]
                #[inline(always)]
                #[must_use]
                pub fn inepne(&mut self) -> INEPNE_W<DIEPINT_SPEC, 6> {
                    INEPNE_W::new(self)
                }
                #[doc = "Bit 8 - Transmit Fifo Underrun"]
                #[inline(always)]
                #[must_use]
                pub fn txfifoudrn(&mut self) -> TXFIFOUDRN_W<DIEPINT_SPEC, 8> {
                    TXFIFOUDRN_W::new(self)
                }
                #[doc = "Bit 9 - Buffer not available interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn bna(&mut self) -> BNA_W<DIEPINT_SPEC, 9> {
                    BNA_W::new(self)
                }
                #[doc = "Bit 11 - Packet dropped status"]
                #[inline(always)]
                #[must_use]
                pub fn pktdrpsts(&mut self) -> PKTDRPSTS_W<DIEPINT_SPEC, 11> {
                    PKTDRPSTS_W::new(self)
                }
                #[doc = "Bit 12 - Babble error interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn berr(&mut self) -> BERR_W<DIEPINT_SPEC, 12> {
                    BERR_W::new(self)
                }
                #[doc = "Bit 13 - NAK interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn nak(&mut self) -> NAK_W<DIEPINT_SPEC, 13> {
                    NAK_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Interrupt\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepint::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepint::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DIEPINT_SPEC;
            impl crate::RegisterSpec for DIEPINT_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`diepint::R`](R) reader structure"]
            impl crate::Readable for DIEPINT_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`diepint::W`](W) writer structure"]
            impl crate::Writable for DIEPINT_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets DIEPINT to value 0x80"]
            impl crate::Resettable for DIEPINT_SPEC {
                const RESET_VALUE: Self::Ux = 0x80;
            }
        }
        #[doc = "DIEPTSIZ (rw) register accessor: Transfer size\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptsiz::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptsiz::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptsiz`]
module"]
        pub type DIEPTSIZ = crate::Reg<dieptsiz::DIEPTSIZ_SPEC>;
        #[doc = "Transfer size"]
        pub mod dieptsiz {
            #[doc = "Register `DIEPTSIZ` reader"]
            pub type R = crate::R<DIEPTSIZ_SPEC>;
            #[doc = "Register `DIEPTSIZ` writer"]
            pub type W = crate::W<DIEPTSIZ_SPEC>;
            #[doc = "Field `XFRSIZ` reader - Transfer size"]
            pub type XFRSIZ_R = crate::FieldReader;
            #[doc = "Field `XFRSIZ` writer - Transfer size"]
            pub type XFRSIZ_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 7, O>;
            #[doc = "Field `PKTCNT` reader - Packet count"]
            pub type PKTCNT_R = crate::FieldReader;
            #[doc = "Field `PKTCNT` writer - Packet count"]
            pub type PKTCNT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
            impl R {
                #[doc = "Bits 0:6 - Transfer size"]
                #[inline(always)]
                pub fn xfrsiz(&self) -> XFRSIZ_R {
                    XFRSIZ_R::new((self.bits & 0x7f) as u8)
                }
                #[doc = "Bits 19:20 - Packet count"]
                #[inline(always)]
                pub fn pktcnt(&self) -> PKTCNT_R {
                    PKTCNT_R::new(((self.bits >> 19) & 3) as u8)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DIEPTSIZ")
                        .field("xfrsiz", &format_args!("{}", self.xfrsiz().bits()))
                        .field("pktcnt", &format_args!("{}", self.pktcnt().bits()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DIEPTSIZ_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:6 - Transfer size"]
                #[inline(always)]
                #[must_use]
                pub fn xfrsiz(&mut self) -> XFRSIZ_W<DIEPTSIZ_SPEC, 0> {
                    XFRSIZ_W::new(self)
                }
                #[doc = "Bits 19:20 - Packet count"]
                #[inline(always)]
                #[must_use]
                pub fn pktcnt(&mut self) -> PKTCNT_W<DIEPTSIZ_SPEC, 19> {
                    PKTCNT_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Transfer size\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dieptsiz::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dieptsiz::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DIEPTSIZ_SPEC;
            impl crate::RegisterSpec for DIEPTSIZ_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`dieptsiz::R`](R) reader structure"]
            impl crate::Readable for DIEPTSIZ_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`dieptsiz::W`](W) writer structure"]
            impl crate::Writable for DIEPTSIZ_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets DIEPTSIZ to value 0"]
            impl crate::Resettable for DIEPTSIZ_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "DIEPDMA (rw) register accessor: DMA address\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepdma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepdma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepdma`]
module"]
        pub type DIEPDMA = crate::Reg<diepdma::DIEPDMA_SPEC>;
        #[doc = "DMA address"]
        pub mod diepdma {
            #[doc = "Register `DIEPDMA` reader"]
            pub type R = crate::R<DIEPDMA_SPEC>;
            #[doc = "Register `DIEPDMA` writer"]
            pub type W = crate::W<DIEPDMA_SPEC>;
            #[doc = "Field `DMAADDR` reader - DMA address"]
            pub type DMAADDR_R = crate::FieldReader<u32>;
            #[doc = "Field `DMAADDR` writer - DMA address"]
            pub type DMAADDR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 32, O, u32>;
            impl R {
                #[doc = "Bits 0:31 - DMA address"]
                #[inline(always)]
                pub fn dmaaddr(&self) -> DMAADDR_R {
                    DMAADDR_R::new(self.bits)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DIEPDMA")
                        .field("dmaaddr", &format_args!("{}", self.dmaaddr().bits()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DIEPDMA_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:31 - DMA address"]
                #[inline(always)]
                #[must_use]
                pub fn dmaaddr(&mut self) -> DMAADDR_W<DIEPDMA_SPEC, 0> {
                    DMAADDR_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "DMA address\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`diepdma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`diepdma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DIEPDMA_SPEC;
            impl crate::RegisterSpec for DIEPDMA_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`diepdma::R`](R) reader structure"]
            impl crate::Readable for DIEPDMA_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`diepdma::W`](W) writer structure"]
            impl crate::Writable for DIEPDMA_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets DIEPDMA to value 0"]
            impl crate::Resettable for DIEPDMA_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "DTXFSTS (r) register accessor: Transmit FIFO status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dtxfsts::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dtxfsts`]
module"]
        pub type DTXFSTS = crate::Reg<dtxfsts::DTXFSTS_SPEC>;
        #[doc = "Transmit FIFO status"]
        pub mod dtxfsts {
            #[doc = "Register `DTXFSTS` reader"]
            pub type R = crate::R<DTXFSTS_SPEC>;
            #[doc = "Field `INEPTFSAV` reader - IN endpoint TxFIFO space avail"]
            pub type INEPTFSAV_R = crate::FieldReader<u16>;
            impl R {
                #[doc = "Bits 0:15 - IN endpoint TxFIFO space avail"]
                #[inline(always)]
                pub fn ineptfsav(&self) -> INEPTFSAV_R {
                    INEPTFSAV_R::new((self.bits & 0xffff) as u16)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DTXFSTS")
                        .field("ineptfsav", &format_args!("{}", self.ineptfsav().bits()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DTXFSTS_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            #[doc = "Transmit FIFO status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dtxfsts::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DTXFSTS_SPEC;
            impl crate::RegisterSpec for DTXFSTS_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`dtxfsts::R`](R) reader structure"]
            impl crate::Readable for DTXFSTS_SPEC {}
            #[doc = "`reset()` method sets DTXFSTS to value 0"]
            impl crate::Resettable for DTXFSTS_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
    }
    #[doc = "OUT Endpoint %s"]
    pub use self::out_endpoint::OUT_ENDPOINT;
    #[doc = r"Cluster"]
    #[doc = "OUT Endpoint %s"]
    pub mod out_endpoint {
        #[doc = r"Register block"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct OUT_ENDPOINT {
            #[doc = "0x00 - Control"]
            pub doepctl: DOEPCTL,
            _reserved1: [u8; 0x04],
            #[doc = "0x08 - Interrupt"]
            pub doepint: DOEPINT,
            _reserved2: [u8; 0x04],
            #[doc = "0x10 - Transfer size"]
            pub doeptsiz: DOEPTSIZ,
            #[doc = "0x14 - DMA address"]
            pub doepdma: DOEPDMA,
        }
        #[doc = "DOEPCTL (rw) register accessor: Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepctl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepctl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepctl`]
module"]
        pub type DOEPCTL = crate::Reg<doepctl::DOEPCTL_SPEC>;
        #[doc = "Control"]
        pub mod doepctl {
            #[doc = "Register `DOEPCTL` reader"]
            pub type R = crate::R<DOEPCTL_SPEC>;
            #[doc = "Register `DOEPCTL` writer"]
            pub type W = crate::W<DOEPCTL_SPEC>;
            #[doc = "Field `MPSIZ` reader - Maximum packet size"]
            pub type MPSIZ_R = crate::FieldReader;
            #[doc = "Field `USBAEP` reader - USB active endpoint"]
            pub type USBAEP_R = crate::BitReader;
            #[doc = "Field `NAKSTS` reader - NAK status"]
            pub type NAKSTS_R = crate::BitReader;
            #[doc = "Field `EPTYP` reader - Endpoint type"]
            pub type EPTYP_R = crate::FieldReader;
            #[doc = "Field `SNPM` reader - Snoop mode"]
            pub type SNPM_R = crate::BitReader;
            #[doc = "Field `SNPM` writer - Snoop mode"]
            pub type SNPM_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `Stall` reader - STALL handshake"]
            pub type STALL_R = crate::BitReader;
            #[doc = "Field `Stall` writer - STALL handshake"]
            pub type STALL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `CNAK` writer - Clear NAK"]
            pub type CNAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `SNAK` writer - Set NAK"]
            pub type SNAK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `EPDIS` reader - Endpoint disable"]
            pub type EPDIS_R = crate::BitReader;
            #[doc = "Field `EPENA` writer - Endpoint enable"]
            pub type EPENA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            impl R {
                #[doc = "Bits 0:1 - Maximum packet size"]
                #[inline(always)]
                pub fn mpsiz(&self) -> MPSIZ_R {
                    MPSIZ_R::new((self.bits & 3) as u8)
                }
                #[doc = "Bit 15 - USB active endpoint"]
                #[inline(always)]
                pub fn usbaep(&self) -> USBAEP_R {
                    USBAEP_R::new(((self.bits >> 15) & 1) != 0)
                }
                #[doc = "Bit 17 - NAK status"]
                #[inline(always)]
                pub fn naksts(&self) -> NAKSTS_R {
                    NAKSTS_R::new(((self.bits >> 17) & 1) != 0)
                }
                #[doc = "Bits 18:19 - Endpoint type"]
                #[inline(always)]
                pub fn eptyp(&self) -> EPTYP_R {
                    EPTYP_R::new(((self.bits >> 18) & 3) as u8)
                }
                #[doc = "Bit 20 - Snoop mode"]
                #[inline(always)]
                pub fn snpm(&self) -> SNPM_R {
                    SNPM_R::new(((self.bits >> 20) & 1) != 0)
                }
                #[doc = "Bit 21 - STALL handshake"]
                #[inline(always)]
                pub fn stall(&self) -> STALL_R {
                    STALL_R::new(((self.bits >> 21) & 1) != 0)
                }
                #[doc = "Bit 30 - Endpoint disable"]
                #[inline(always)]
                pub fn epdis(&self) -> EPDIS_R {
                    EPDIS_R::new(((self.bits >> 30) & 1) != 0)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DOEPCTL")
                        .field("mpsiz", &format_args!("{}", self.mpsiz().bits()))
                        .field("usbaep", &format_args!("{}", self.usbaep().bit()))
                        .field("naksts", &format_args!("{}", self.naksts().bit()))
                        .field("eptyp", &format_args!("{}", self.eptyp().bits()))
                        .field("snpm", &format_args!("{}", self.snpm().bit()))
                        .field("stall", &format_args!("{}", self.stall().bit()))
                        .field("epdis", &format_args!("{}", self.epdis().bit()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DOEPCTL_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bit 20 - Snoop mode"]
                #[inline(always)]
                #[must_use]
                pub fn snpm(&mut self) -> SNPM_W<DOEPCTL_SPEC, 20> {
                    SNPM_W::new(self)
                }
                #[doc = "Bit 21 - STALL handshake"]
                #[inline(always)]
                #[must_use]
                pub fn stall(&mut self) -> STALL_W<DOEPCTL_SPEC, 21> {
                    STALL_W::new(self)
                }
                #[doc = "Bit 26 - Clear NAK"]
                #[inline(always)]
                #[must_use]
                pub fn cnak(&mut self) -> CNAK_W<DOEPCTL_SPEC, 26> {
                    CNAK_W::new(self)
                }
                #[doc = "Bit 27 - Set NAK"]
                #[inline(always)]
                #[must_use]
                pub fn snak(&mut self) -> SNAK_W<DOEPCTL_SPEC, 27> {
                    SNAK_W::new(self)
                }
                #[doc = "Bit 31 - Endpoint enable"]
                #[inline(always)]
                #[must_use]
                pub fn epena(&mut self) -> EPENA_W<DOEPCTL_SPEC, 31> {
                    EPENA_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DOEPCTL_SPEC;
            impl crate::RegisterSpec for DOEPCTL_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`doepctl::R`](R) reader structure"]
            impl crate::Readable for DOEPCTL_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`doepctl::W`](W) writer structure"]
            impl crate::Writable for DOEPCTL_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets DOEPCTL to value 0x8000"]
            impl crate::Resettable for DOEPCTL_SPEC {
                const RESET_VALUE: Self::Ux = 0x8000;
            }
        }
        #[doc = "DOEPINT (rw) register accessor: Interrupt\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepint::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepint::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepint`]
module"]
        pub type DOEPINT = crate::Reg<doepint::DOEPINT_SPEC>;
        #[doc = "Interrupt"]
        pub mod doepint {
            #[doc = "Register `DOEPINT` reader"]
            pub type R = crate::R<DOEPINT_SPEC>;
            #[doc = "Register `DOEPINT` writer"]
            pub type W = crate::W<DOEPINT_SPEC>;
            #[doc = "Field `XFRC` reader - Transfer completed interrupt"]
            pub type XFRC_R = crate::BitReader;
            #[doc = "Field `XFRC` writer - Transfer completed interrupt"]
            pub type XFRC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `EPDISD` reader - Endpoint disabled interrupt"]
            pub type EPDISD_R = crate::BitReader;
            #[doc = "Field `EPDISD` writer - Endpoint disabled interrupt"]
            pub type EPDISD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `STUP` reader - SETUP phase done"]
            pub type STUP_R = crate::BitReader;
            #[doc = "Field `STUP` writer - SETUP phase done"]
            pub type STUP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `OTEPDIS` reader - OUT token received when endpoint disabled"]
            pub type OTEPDIS_R = crate::BitReader;
            #[doc = "Field `OTEPDIS` writer - OUT token received when endpoint disabled"]
            pub type OTEPDIS_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `B2BSTUP` reader - Back-to-back SETUP packets received"]
            pub type B2BSTUP_R = crate::BitReader;
            #[doc = "Field `B2BSTUP` writer - Back-to-back SETUP packets received"]
            pub type B2BSTUP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `NYET` reader - NYET interrupt"]
            pub type NYET_R = crate::BitReader;
            #[doc = "Field `NYET` writer - NYET interrupt"]
            pub type NYET_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            impl R {
                #[doc = "Bit 0 - Transfer completed interrupt"]
                #[inline(always)]
                pub fn xfrc(&self) -> XFRC_R {
                    XFRC_R::new((self.bits & 1) != 0)
                }
                #[doc = "Bit 1 - Endpoint disabled interrupt"]
                #[inline(always)]
                pub fn epdisd(&self) -> EPDISD_R {
                    EPDISD_R::new(((self.bits >> 1) & 1) != 0)
                }
                #[doc = "Bit 3 - SETUP phase done"]
                #[inline(always)]
                pub fn stup(&self) -> STUP_R {
                    STUP_R::new(((self.bits >> 3) & 1) != 0)
                }
                #[doc = "Bit 4 - OUT token received when endpoint disabled"]
                #[inline(always)]
                pub fn otepdis(&self) -> OTEPDIS_R {
                    OTEPDIS_R::new(((self.bits >> 4) & 1) != 0)
                }
                #[doc = "Bit 6 - Back-to-back SETUP packets received"]
                #[inline(always)]
                pub fn b2bstup(&self) -> B2BSTUP_R {
                    B2BSTUP_R::new(((self.bits >> 6) & 1) != 0)
                }
                #[doc = "Bit 14 - NYET interrupt"]
                #[inline(always)]
                pub fn nyet(&self) -> NYET_R {
                    NYET_R::new(((self.bits >> 14) & 1) != 0)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DOEPINT")
                        .field("xfrc", &format_args!("{}", self.xfrc().bit()))
                        .field("epdisd", &format_args!("{}", self.epdisd().bit()))
                        .field("stup", &format_args!("{}", self.stup().bit()))
                        .field("otepdis", &format_args!("{}", self.otepdis().bit()))
                        .field("b2bstup", &format_args!("{}", self.b2bstup().bit()))
                        .field("nyet", &format_args!("{}", self.nyet().bit()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DOEPINT_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bit 0 - Transfer completed interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn xfrc(&mut self) -> XFRC_W<DOEPINT_SPEC, 0> {
                    XFRC_W::new(self)
                }
                #[doc = "Bit 1 - Endpoint disabled interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn epdisd(&mut self) -> EPDISD_W<DOEPINT_SPEC, 1> {
                    EPDISD_W::new(self)
                }
                #[doc = "Bit 3 - SETUP phase done"]
                #[inline(always)]
                #[must_use]
                pub fn stup(&mut self) -> STUP_W<DOEPINT_SPEC, 3> {
                    STUP_W::new(self)
                }
                #[doc = "Bit 4 - OUT token received when endpoint disabled"]
                #[inline(always)]
                #[must_use]
                pub fn otepdis(&mut self) -> OTEPDIS_W<DOEPINT_SPEC, 4> {
                    OTEPDIS_W::new(self)
                }
                #[doc = "Bit 6 - Back-to-back SETUP packets received"]
                #[inline(always)]
                #[must_use]
                pub fn b2bstup(&mut self) -> B2BSTUP_W<DOEPINT_SPEC, 6> {
                    B2BSTUP_W::new(self)
                }
                #[doc = "Bit 14 - NYET interrupt"]
                #[inline(always)]
                #[must_use]
                pub fn nyet(&mut self) -> NYET_W<DOEPINT_SPEC, 14> {
                    NYET_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Interrupt\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepint::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepint::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DOEPINT_SPEC;
            impl crate::RegisterSpec for DOEPINT_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`doepint::R`](R) reader structure"]
            impl crate::Readable for DOEPINT_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`doepint::W`](W) writer structure"]
            impl crate::Writable for DOEPINT_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets DOEPINT to value 0x80"]
            impl crate::Resettable for DOEPINT_SPEC {
                const RESET_VALUE: Self::Ux = 0x80;
            }
        }
        #[doc = "DOEPTSIZ (rw) register accessor: Transfer size\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doeptsiz::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doeptsiz::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doeptsiz`]
module"]
        pub type DOEPTSIZ = crate::Reg<doeptsiz::DOEPTSIZ_SPEC>;
        #[doc = "Transfer size"]
        pub mod doeptsiz {
            #[doc = "Register `DOEPTSIZ` reader"]
            pub type R = crate::R<DOEPTSIZ_SPEC>;
            #[doc = "Register `DOEPTSIZ` writer"]
            pub type W = crate::W<DOEPTSIZ_SPEC>;
            #[doc = "Field `XFRSIZ` reader - Transfer size"]
            pub type XFRSIZ_R = crate::FieldReader;
            #[doc = "Field `XFRSIZ` writer - Transfer size"]
            pub type XFRSIZ_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 7, O>;
            #[doc = "Field `PKTCNT` reader - Packet count"]
            pub type PKTCNT_R = crate::BitReader;
            #[doc = "Field `PKTCNT` writer - Packet count"]
            pub type PKTCNT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
            #[doc = "Field `STUPCNT` reader - SETUP packet count"]
            pub type STUPCNT_R = crate::FieldReader;
            #[doc = "Field `STUPCNT` writer - SETUP packet count"]
            pub type STUPCNT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
            impl R {
                #[doc = "Bits 0:6 - Transfer size"]
                #[inline(always)]
                pub fn xfrsiz(&self) -> XFRSIZ_R {
                    XFRSIZ_R::new((self.bits & 0x7f) as u8)
                }
                #[doc = "Bit 19 - Packet count"]
                #[inline(always)]
                pub fn pktcnt(&self) -> PKTCNT_R {
                    PKTCNT_R::new(((self.bits >> 19) & 1) != 0)
                }
                #[doc = "Bits 29:30 - SETUP packet count"]
                #[inline(always)]
                pub fn stupcnt(&self) -> STUPCNT_R {
                    STUPCNT_R::new(((self.bits >> 29) & 3) as u8)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DOEPTSIZ")
                        .field("xfrsiz", &format_args!("{}", self.xfrsiz().bits()))
                        .field("pktcnt", &format_args!("{}", self.pktcnt().bit()))
                        .field("stupcnt", &format_args!("{}", self.stupcnt().bits()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DOEPTSIZ_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:6 - Transfer size"]
                #[inline(always)]
                #[must_use]
                pub fn xfrsiz(&mut self) -> XFRSIZ_W<DOEPTSIZ_SPEC, 0> {
                    XFRSIZ_W::new(self)
                }
                #[doc = "Bit 19 - Packet count"]
                #[inline(always)]
                #[must_use]
                pub fn pktcnt(&mut self) -> PKTCNT_W<DOEPTSIZ_SPEC, 19> {
                    PKTCNT_W::new(self)
                }
                #[doc = "Bits 29:30 - SETUP packet count"]
                #[inline(always)]
                #[must_use]
                pub fn stupcnt(&mut self) -> STUPCNT_W<DOEPTSIZ_SPEC, 29> {
                    STUPCNT_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Transfer size\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doeptsiz::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doeptsiz::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DOEPTSIZ_SPEC;
            impl crate::RegisterSpec for DOEPTSIZ_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`doeptsiz::R`](R) reader structure"]
            impl crate::Readable for DOEPTSIZ_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`doeptsiz::W`](W) writer structure"]
            impl crate::Writable for DOEPTSIZ_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets DOEPTSIZ to value 0"]
            impl crate::Resettable for DOEPTSIZ_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
        #[doc = "DOEPDMA (rw) register accessor: DMA address\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepdma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepdma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepdma`]
module"]
        pub type DOEPDMA = crate::Reg<doepdma::DOEPDMA_SPEC>;
        #[doc = "DMA address"]
        pub mod doepdma {
            #[doc = "Register `DOEPDMA` reader"]
            pub type R = crate::R<DOEPDMA_SPEC>;
            #[doc = "Register `DOEPDMA` writer"]
            pub type W = crate::W<DOEPDMA_SPEC>;
            #[doc = "Field `DMAADDR` reader - DMA address"]
            pub type DMAADDR_R = crate::FieldReader<u32>;
            #[doc = "Field `DMAADDR` writer - DMA address"]
            pub type DMAADDR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 32, O, u32>;
            impl R {
                #[doc = "Bits 0:31 - DMA address"]
                #[inline(always)]
                pub fn dmaaddr(&self) -> DMAADDR_R {
                    DMAADDR_R::new(self.bits)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("DOEPDMA")
                        .field("dmaaddr", &format_args!("{}", self.dmaaddr().bits()))
                        .finish()
                }
            }
            impl core::fmt::Debug for crate::generic::Reg<DOEPDMA_SPEC> {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    self.read().fmt(f)
                }
            }
            impl W {
                #[doc = "Bits 0:31 - DMA address"]
                #[inline(always)]
                #[must_use]
                pub fn dmaaddr(&mut self) -> DMAADDR_W<DOEPDMA_SPEC, 0> {
                    DMAADDR_W::new(self)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "DMA address\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`doepdma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`doepdma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct DOEPDMA_SPEC;
            impl crate::RegisterSpec for DOEPDMA_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`doepdma::R`](R) reader structure"]
            impl crate::Readable for DOEPDMA_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`doepdma::W`](W) writer structure"]
            impl crate::Writable for DOEPDMA_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            }
            #[doc = "`reset()` method sets DOEPDMA to value 0"]
            impl crate::Resettable for DOEPDMA_SPEC {
                const RESET_VALUE: Self::Ux = 0;
            }
        }
    }
}
#[doc = "USB on the go high speed power control"]
pub struct USB_OTG_PWRCLK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB_OTG_PWRCLK {}
impl USB_OTG_PWRCLK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb_otg_pwrclk::RegisterBlock = 0x2098_0e00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb_otg_pwrclk::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB_OTG_PWRCLK {
    type Target = usb_otg_pwrclk::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB_OTG_PWRCLK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB_OTG_PWRCLK").finish()
    }
}
#[doc = "USB on the go high speed power control"]
pub mod usb_otg_pwrclk {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - power and clock gating control"]
        pub pcgcctl: PCGCCTL,
    }
    #[doc = "PCGCCTL (rw) register accessor: power and clock gating control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pcgcctl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pcgcctl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pcgcctl`]
module"]
    pub type PCGCCTL = crate::Reg<pcgcctl::PCGCCTL_SPEC>;
    #[doc = "power and clock gating control"]
    pub mod pcgcctl {
        #[doc = "Register `PCGCCTL` reader"]
        pub type R = crate::R<PCGCCTL_SPEC>;
        #[doc = "Register `PCGCCTL` writer"]
        pub type W = crate::W<PCGCCTL_SPEC>;
        #[doc = "Field `STPPCLK` reader - Stop PHY clock"]
        pub type STPPCLK_R = crate::BitReader;
        #[doc = "Field `STPPCLK` writer - Stop PHY clock"]
        pub type STPPCLK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GATEHCLK` reader - Gate HCLK"]
        pub type GATEHCLK_R = crate::BitReader;
        #[doc = "Field `GATEHCLK` writer - Gate HCLK"]
        pub type GATEHCLK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PWRCLMP` reader - Power clamp"]
        pub type PWRCLMP_R = crate::BitReader;
        #[doc = "Field `PWRCLMP` writer - Power clamp"]
        pub type PWRCLMP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RSTPDWNMODULE` reader - Power down modules"]
        pub type RSTPDWNMODULE_R = crate::BitReader;
        #[doc = "Field `RSTPDWNMODULE` writer - Power down modules"]
        pub type RSTPDWNMODULE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PHYSUSP` reader - PHY Suspended"]
        pub type PHYSUSP_R = crate::BitReader;
        #[doc = "Field `PHYSUSP` writer - PHY Suspended"]
        pub type PHYSUSP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENABLE_L1GATING` reader - Enable sleep clock gating"]
        pub type ENABLE_L1GATING_R = crate::BitReader;
        #[doc = "Field `ENABLE_L1GATING` writer - Enable sleep clock gating"]
        pub type ENABLE_L1GATING_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `PHYSLEEP` reader - PHY is in sleep mode"]
        pub type PHYSLEEP_R = crate::BitReader;
        #[doc = "Field `PHYSLEEP` writer - PHY is in sleep mode"]
        pub type PHYSLEEP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DEEPSLEEP` reader - PHY is in deep sleep"]
        pub type DEEPSLEEP_R = crate::BitReader;
        #[doc = "Field `DEEPSLEEP` writer - PHY is in deep sleep"]
        pub type DEEPSLEEP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RESETAFTERSUSP` reader - Reset after suspend"]
        pub type RESETAFTERSUSP_R = crate::BitReader;
        #[doc = "Field `RESETAFTERSUSP` writer - Reset after suspend"]
        pub type RESETAFTERSUSP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RESTOREMODE` reader - Restore mode"]
        pub type RESTOREMODE_R = crate::BitReader;
        #[doc = "Field `RESTOREMODE` writer - Restore mode"]
        pub type RESTOREMODE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENEXTNDEDHIBER` reader - Enable extended hibernation"]
        pub type ENEXTNDEDHIBER_R = crate::BitReader;
        #[doc = "Field `ENEXTNDEDHIBER` writer - Enable extended hibernation"]
        pub type ENEXTNDEDHIBER_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EXTNDEDHIBERNATIONCLAMP` reader - Extended hibernation clamp"]
        pub type EXTNDEDHIBERNATIONCLAMP_R = crate::BitReader;
        #[doc = "Field `EXTNDEDHIBERNATIONCLAMP` writer - Extended hibernation clamp"]
        pub type EXTNDEDHIBERNATIONCLAMP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `EXTNDEDHIBERNATIONSWITCH` reader - Extended hibernation switch"]
        pub type EXTNDEDHIBERNATIONSWITCH_R = crate::BitReader;
        #[doc = "Field `EXTNDEDHIBERNATIONSWITCH` writer - Extended hibernation switch"]
        pub type EXTNDEDHIBERNATIONSWITCH_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ESSREGRESTORED` reader - Essential register values restored"]
        pub type ESSREGRESTORED_R = crate::BitReader;
        #[doc = "Field `ESSREGRESTORED` writer - Essential register values restored"]
        pub type ESSREGRESTORED_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RESTORE_VALUE` reader - Restore value"]
        pub type RESTORE_VALUE_R = crate::FieldReader<u32>;
        #[doc = "Field `RESTORE_VALUE` writer - Restore value"]
        pub type RESTORE_VALUE_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 18, O, u32>;
        impl R {
            #[doc = "Bit 0 - Stop PHY clock"]
            #[inline(always)]
            pub fn stppclk(&self) -> STPPCLK_R {
                STPPCLK_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Gate HCLK"]
            #[inline(always)]
            pub fn gatehclk(&self) -> GATEHCLK_R {
                GATEHCLK_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Power clamp"]
            #[inline(always)]
            pub fn pwrclmp(&self) -> PWRCLMP_R {
                PWRCLMP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Power down modules"]
            #[inline(always)]
            pub fn rstpdwnmodule(&self) -> RSTPDWNMODULE_R {
                RSTPDWNMODULE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - PHY Suspended"]
            #[inline(always)]
            pub fn physusp(&self) -> PHYSUSP_R {
                PHYSUSP_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Enable sleep clock gating"]
            #[inline(always)]
            pub fn enable_l1gating(&self) -> ENABLE_L1GATING_R {
                ENABLE_L1GATING_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - PHY is in sleep mode"]
            #[inline(always)]
            pub fn physleep(&self) -> PHYSLEEP_R {
                PHYSLEEP_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - PHY is in deep sleep"]
            #[inline(always)]
            pub fn deepsleep(&self) -> DEEPSLEEP_R {
                DEEPSLEEP_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Reset after suspend"]
            #[inline(always)]
            pub fn resetaftersusp(&self) -> RESETAFTERSUSP_R {
                RESETAFTERSUSP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Restore mode"]
            #[inline(always)]
            pub fn restoremode(&self) -> RESTOREMODE_R {
                RESTOREMODE_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Enable extended hibernation"]
            #[inline(always)]
            pub fn enextndedhiber(&self) -> ENEXTNDEDHIBER_R {
                ENEXTNDEDHIBER_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Extended hibernation clamp"]
            #[inline(always)]
            pub fn extndedhibernationclamp(&self) -> EXTNDEDHIBERNATIONCLAMP_R {
                EXTNDEDHIBERNATIONCLAMP_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Extended hibernation switch"]
            #[inline(always)]
            pub fn extndedhibernationswitch(&self) -> EXTNDEDHIBERNATIONSWITCH_R {
                EXTNDEDHIBERNATIONSWITCH_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Essential register values restored"]
            #[inline(always)]
            pub fn essregrestored(&self) -> ESSREGRESTORED_R {
                ESSREGRESTORED_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bits 14:31 - Restore value"]
            #[inline(always)]
            pub fn restore_value(&self) -> RESTORE_VALUE_R {
                RESTORE_VALUE_R::new((self.bits >> 14) & 0x0003_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PCGCCTL")
                    .field("stppclk", &format_args!("{}", self.stppclk().bit()))
                    .field("gatehclk", &format_args!("{}", self.gatehclk().bit()))
                    .field("pwrclmp", &format_args!("{}", self.pwrclmp().bit()))
                    .field(
                        "rstpdwnmodule",
                        &format_args!("{}", self.rstpdwnmodule().bit()),
                    )
                    .field("physusp", &format_args!("{}", self.physusp().bit()))
                    .field(
                        "enable_l1gating",
                        &format_args!("{}", self.enable_l1gating().bit()),
                    )
                    .field("physleep", &format_args!("{}", self.physleep().bit()))
                    .field("deepsleep", &format_args!("{}", self.deepsleep().bit()))
                    .field(
                        "resetaftersusp",
                        &format_args!("{}", self.resetaftersusp().bit()),
                    )
                    .field("restoremode", &format_args!("{}", self.restoremode().bit()))
                    .field(
                        "enextndedhiber",
                        &format_args!("{}", self.enextndedhiber().bit()),
                    )
                    .field(
                        "extndedhibernationclamp",
                        &format_args!("{}", self.extndedhibernationclamp().bit()),
                    )
                    .field(
                        "extndedhibernationswitch",
                        &format_args!("{}", self.extndedhibernationswitch().bit()),
                    )
                    .field(
                        "essregrestored",
                        &format_args!("{}", self.essregrestored().bit()),
                    )
                    .field(
                        "restore_value",
                        &format_args!("{}", self.restore_value().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PCGCCTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Stop PHY clock"]
            #[inline(always)]
            #[must_use]
            pub fn stppclk(&mut self) -> STPPCLK_W<PCGCCTL_SPEC, 0> {
                STPPCLK_W::new(self)
            }
            #[doc = "Bit 1 - Gate HCLK"]
            #[inline(always)]
            #[must_use]
            pub fn gatehclk(&mut self) -> GATEHCLK_W<PCGCCTL_SPEC, 1> {
                GATEHCLK_W::new(self)
            }
            #[doc = "Bit 2 - Power clamp"]
            #[inline(always)]
            #[must_use]
            pub fn pwrclmp(&mut self) -> PWRCLMP_W<PCGCCTL_SPEC, 2> {
                PWRCLMP_W::new(self)
            }
            #[doc = "Bit 3 - Power down modules"]
            #[inline(always)]
            #[must_use]
            pub fn rstpdwnmodule(&mut self) -> RSTPDWNMODULE_W<PCGCCTL_SPEC, 3> {
                RSTPDWNMODULE_W::new(self)
            }
            #[doc = "Bit 4 - PHY Suspended"]
            #[inline(always)]
            #[must_use]
            pub fn physusp(&mut self) -> PHYSUSP_W<PCGCCTL_SPEC, 4> {
                PHYSUSP_W::new(self)
            }
            #[doc = "Bit 5 - Enable sleep clock gating"]
            #[inline(always)]
            #[must_use]
            pub fn enable_l1gating(&mut self) -> ENABLE_L1GATING_W<PCGCCTL_SPEC, 5> {
                ENABLE_L1GATING_W::new(self)
            }
            #[doc = "Bit 6 - PHY is in sleep mode"]
            #[inline(always)]
            #[must_use]
            pub fn physleep(&mut self) -> PHYSLEEP_W<PCGCCTL_SPEC, 6> {
                PHYSLEEP_W::new(self)
            }
            #[doc = "Bit 7 - PHY is in deep sleep"]
            #[inline(always)]
            #[must_use]
            pub fn deepsleep(&mut self) -> DEEPSLEEP_W<PCGCCTL_SPEC, 7> {
                DEEPSLEEP_W::new(self)
            }
            #[doc = "Bit 8 - Reset after suspend"]
            #[inline(always)]
            #[must_use]
            pub fn resetaftersusp(&mut self) -> RESETAFTERSUSP_W<PCGCCTL_SPEC, 8> {
                RESETAFTERSUSP_W::new(self)
            }
            #[doc = "Bit 9 - Restore mode"]
            #[inline(always)]
            #[must_use]
            pub fn restoremode(&mut self) -> RESTOREMODE_W<PCGCCTL_SPEC, 9> {
                RESTOREMODE_W::new(self)
            }
            #[doc = "Bit 10 - Enable extended hibernation"]
            #[inline(always)]
            #[must_use]
            pub fn enextndedhiber(&mut self) -> ENEXTNDEDHIBER_W<PCGCCTL_SPEC, 10> {
                ENEXTNDEDHIBER_W::new(self)
            }
            #[doc = "Bit 11 - Extended hibernation clamp"]
            #[inline(always)]
            #[must_use]
            pub fn extndedhibernationclamp(
                &mut self,
            ) -> EXTNDEDHIBERNATIONCLAMP_W<PCGCCTL_SPEC, 11> {
                EXTNDEDHIBERNATIONCLAMP_W::new(self)
            }
            #[doc = "Bit 12 - Extended hibernation switch"]
            #[inline(always)]
            #[must_use]
            pub fn extndedhibernationswitch(
                &mut self,
            ) -> EXTNDEDHIBERNATIONSWITCH_W<PCGCCTL_SPEC, 12> {
                EXTNDEDHIBERNATIONSWITCH_W::new(self)
            }
            #[doc = "Bit 13 - Essential register values restored"]
            #[inline(always)]
            #[must_use]
            pub fn essregrestored(&mut self) -> ESSREGRESTORED_W<PCGCCTL_SPEC, 13> {
                ESSREGRESTORED_W::new(self)
            }
            #[doc = "Bits 14:31 - Restore value"]
            #[inline(always)]
            #[must_use]
            pub fn restore_value(&mut self) -> RESTORE_VALUE_W<PCGCCTL_SPEC, 14> {
                RESTORE_VALUE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "power and clock gating control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pcgcctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pcgcctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PCGCCTL_SPEC;
        impl crate::RegisterSpec for PCGCCTL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pcgcctl::R`](R) reader structure"]
        impl crate::Readable for PCGCCTL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`pcgcctl::W`](W) writer structure"]
        impl crate::Writable for PCGCCTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets PCGCCTL to value 0x200b_8000"]
        impl crate::Resettable for PCGCCTL_SPEC {
            const RESET_VALUE: Self::Ux = 0x200b_8000;
        }
    }
}
#[doc = "Arasan SD3.0 Host AHB eMMC 4.4"]
pub struct EMMC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EMMC {}
impl EMMC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const emmc::RegisterBlock = 0x2030_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const emmc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EMMC {
    type Target = emmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EMMC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EMMC").finish()
    }
}
#[doc = "Arasan SD3.0 Host AHB eMMC 4.4"]
pub mod emmc {
    #[doc = r"Register block"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Argument for ACMD23 command"]
        pub arg2: ARG2,
        #[doc = "0x04 - Numer and size in bytes for data block to be transferred"]
        pub blksizecnt: BLKSIZECNT,
        #[doc = "0x08 - Argument for everything but ACMD23"]
        pub arg1: ARG1,
        #[doc = "0x0c - Issue commands to the card"]
        pub cmdtm: CMDTM,
        #[doc = "0x10 - Status bits of the response"]
        pub resp0: RESP0,
        #[doc = "0x14 - Bits 63:32 of CMD2 and CMD10 responses"]
        pub resp1: RESP1,
        #[doc = "0x18 - Bits 95:64 of CMD2 and CMD10 responses"]
        pub resp2: RESP2,
        #[doc = "0x1c - Bits 127:96 of CMD2 and CMD10 responses"]
        pub resp3: RESP3,
        #[doc = "0x20 - Data to/from the card"]
        pub data: DATA,
        #[doc = "0x24 - Status info for debugging"]
        pub status: STATUS,
        #[doc = "0x28 - Control"]
        pub control0: CONTROL0,
        #[doc = "0x2c - Configure"]
        pub control1: CONTROL1,
        #[doc = "0x30 - Interrupt flags"]
        pub interrupt: INTERRUPT,
        #[doc = "0x34 - Mask interrupts that change in INTERRUPT"]
        pub irpt_mask: IRPT_MASK,
        #[doc = "0x38 - Enable interrupt to core"]
        pub irpt_en: IRPT_EN,
        #[doc = "0x3c - Control 2"]
        pub control2: CONTROL2,
        _reserved16: [u8; 0x10],
        #[doc = "0x50 - Force an interrupt"]
        pub force_irpt: FORCE_IRPT,
        _reserved17: [u8; 0x1c],
        #[doc = "0x70 - Number of SD clock cycles to wait for boot"]
        pub boot_timeout: BOOT_TIMEOUT,
        #[doc = "0x74 - What submodules are accessed by the debug bus"]
        pub dbg_sel: DBG_SEL,
        _reserved19: [u8; 0x08],
        #[doc = "0x80 - Fine tune DMA request generation"]
        pub exrdfifo_cfg: EXRDFIFO_CFG,
        #[doc = "0x84 - Enable the extension data register"]
        pub exrdfifo_en: EXRDFIFO_EN,
        #[doc = "0x88 - Sample clock delay step duration"]
        pub tune_step: TUNE_STEP,
        #[doc = "0x8c - Sample clock delay step count for SDR"]
        pub tune_steps_std: TUNE_STEPS_STD,
        #[doc = "0x90 - Sample clock delay step count for DDR"]
        pub tune_steps_ddr: TUNE_STEPS_DDR,
        _reserved24: [u8; 0x5c],
        #[doc = "0xf0 - Interrupts in SPI mode depend on CS"]
        pub spi_int_spt: SPI_INT_SPT,
        _reserved25: [u8; 0x08],
        #[doc = "0xfc - Version information and slot interrupt status"]
        pub slotisr_ver: SLOTISR_VER,
    }
    #[doc = "ARG2 (rw) register accessor: Argument for ACMD23 command\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`arg2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`arg2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arg2`]
module"]
    pub type ARG2 = crate::Reg<arg2::ARG2_SPEC>;
    #[doc = "Argument for ACMD23 command"]
    pub mod arg2 {
        #[doc = "Register `ARG2` reader"]
        pub type R = crate::R<ARG2_SPEC>;
        #[doc = "Register `ARG2` writer"]
        pub type W = crate::W<ARG2_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<ARG2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Argument for ACMD23 command\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`arg2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`arg2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ARG2_SPEC;
        impl crate::RegisterSpec for ARG2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`arg2::R`](R) reader structure"]
        impl crate::Readable for ARG2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`arg2::W`](W) writer structure"]
        impl crate::Writable for ARG2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ARG2 to value 0"]
        impl crate::Resettable for ARG2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "BLKSIZECNT (rw) register accessor: Numer and size in bytes for data block to be transferred\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`blksizecnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`blksizecnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@blksizecnt`]
module"]
    pub type BLKSIZECNT = crate::Reg<blksizecnt::BLKSIZECNT_SPEC>;
    #[doc = "Numer and size in bytes for data block to be transferred"]
    pub mod blksizecnt {
        #[doc = "Register `BLKSIZECNT` reader"]
        pub type R = crate::R<BLKSIZECNT_SPEC>;
        #[doc = "Register `BLKSIZECNT` writer"]
        pub type W = crate::W<BLKSIZECNT_SPEC>;
        #[doc = "Field `BLKSIZE` reader - Block size in bytes"]
        pub type BLKSIZE_R = crate::FieldReader<u16>;
        #[doc = "Field `BLKSIZE` writer - Block size in bytes"]
        pub type BLKSIZE_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 10, O, u16>;
        #[doc = "Field `BLKCNT` reader - Number of blocks to be transferred"]
        pub type BLKCNT_R = crate::FieldReader<u16>;
        #[doc = "Field `BLKCNT` writer - Number of blocks to be transferred"]
        pub type BLKCNT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:9 - Block size in bytes"]
            #[inline(always)]
            pub fn blksize(&self) -> BLKSIZE_R {
                BLKSIZE_R::new((self.bits & 0x03ff) as u16)
            }
            #[doc = "Bits 16:31 - Number of blocks to be transferred"]
            #[inline(always)]
            pub fn blkcnt(&self) -> BLKCNT_R {
                BLKCNT_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BLKSIZECNT")
                    .field("blkcnt", &format_args!("{}", self.blkcnt().bits()))
                    .field("blksize", &format_args!("{}", self.blksize().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<BLKSIZECNT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:9 - Block size in bytes"]
            #[inline(always)]
            #[must_use]
            pub fn blksize(&mut self) -> BLKSIZE_W<BLKSIZECNT_SPEC, 0> {
                BLKSIZE_W::new(self)
            }
            #[doc = "Bits 16:31 - Number of blocks to be transferred"]
            #[inline(always)]
            #[must_use]
            pub fn blkcnt(&mut self) -> BLKCNT_W<BLKSIZECNT_SPEC, 16> {
                BLKCNT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Numer and size in bytes for data block to be transferred\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`blksizecnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`blksizecnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BLKSIZECNT_SPEC;
        impl crate::RegisterSpec for BLKSIZECNT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`blksizecnt::R`](R) reader structure"]
        impl crate::Readable for BLKSIZECNT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`blksizecnt::W`](W) writer structure"]
        impl crate::Writable for BLKSIZECNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets BLKSIZECNT to value 0"]
        impl crate::Resettable for BLKSIZECNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ARG1 (rw) register accessor: Argument for everything but ACMD23\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`arg1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`arg1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arg1`]
module"]
    pub type ARG1 = crate::Reg<arg1::ARG1_SPEC>;
    #[doc = "Argument for everything but ACMD23"]
    pub mod arg1 {
        #[doc = "Register `ARG1` reader"]
        pub type R = crate::R<ARG1_SPEC>;
        #[doc = "Register `ARG1` writer"]
        pub type W = crate::W<ARG1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<ARG1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Argument for everything but ACMD23\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`arg1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`arg1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ARG1_SPEC;
        impl crate::RegisterSpec for ARG1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`arg1::R`](R) reader structure"]
        impl crate::Readable for ARG1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`arg1::W`](W) writer structure"]
        impl crate::Writable for ARG1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ARG1 to value 0"]
        impl crate::Resettable for ARG1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CMDTM (rw) register accessor: Issue commands to the card\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cmdtm::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmdtm::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmdtm`]
module"]
    pub type CMDTM = crate::Reg<cmdtm::CMDTM_SPEC>;
    #[doc = "Issue commands to the card"]
    pub mod cmdtm {
        #[doc = "Register `CMDTM` reader"]
        pub type R = crate::R<CMDTM_SPEC>;
        #[doc = "Register `CMDTM` writer"]
        pub type W = crate::W<CMDTM_SPEC>;
        #[doc = "Field `TM_BLKCNT_EN` reader - Enable block counter"]
        pub type TM_BLKCNT_EN_R = crate::BitReader;
        #[doc = "Field `TM_BLKCNT_EN` writer - Enable block counter"]
        pub type TM_BLKCNT_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TM_AUTO_CMD_EN` reader - Command after completion"]
        pub type TM_AUTO_CMD_EN_R = crate::FieldReader<TM_AUTO_CMD_EN_A>;
        #[doc = "Command after completion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TM_AUTO_CMD_EN_A {
            #[doc = "0: `0`"]
            NONE = 0,
            #[doc = "1: `1`"]
            CMD12 = 1,
            #[doc = "2: `10`"]
            CMD23 = 2,
        }
        impl From<TM_AUTO_CMD_EN_A> for u8 {
            #[inline(always)]
            fn from(variant: TM_AUTO_CMD_EN_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TM_AUTO_CMD_EN_A {
            type Ux = u8;
        }
        impl TM_AUTO_CMD_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<TM_AUTO_CMD_EN_A> {
                match self.bits {
                    0 => Some(TM_AUTO_CMD_EN_A::NONE),
                    1 => Some(TM_AUTO_CMD_EN_A::CMD12),
                    2 => Some(TM_AUTO_CMD_EN_A::CMD23),
                    _ => None,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == TM_AUTO_CMD_EN_A::NONE
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_cmd12(&self) -> bool {
                *self == TM_AUTO_CMD_EN_A::CMD12
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_cmd23(&self) -> bool {
                *self == TM_AUTO_CMD_EN_A::CMD23
            }
        }
        #[doc = "Field `TM_AUTO_CMD_EN` writer - Command after completion"]
        pub type TM_AUTO_CMD_EN_W<'a, REG, const O: u8> =
            crate::FieldWriter<'a, REG, 2, O, TM_AUTO_CMD_EN_A>;
        impl<'a, REG, const O: u8> TM_AUTO_CMD_EN_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn none(self) -> &'a mut crate::W<REG> {
                self.variant(TM_AUTO_CMD_EN_A::NONE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn cmd12(self) -> &'a mut crate::W<REG> {
                self.variant(TM_AUTO_CMD_EN_A::CMD12)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn cmd23(self) -> &'a mut crate::W<REG> {
                self.variant(TM_AUTO_CMD_EN_A::CMD23)
            }
        }
        #[doc = "Field `TM_DAT_DIR` reader - Direction of data transfer"]
        pub type TM_DAT_DIR_R = crate::BitReader<TM_DAT_DIR_A>;
        #[doc = "Direction of data transfer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TM_DAT_DIR_A {
            #[doc = "0: `0`"]
            HOST_TO_CARD = 0,
            #[doc = "1: `1`"]
            CARD_TO_HOST = 1,
        }
        impl From<TM_DAT_DIR_A> for bool {
            #[inline(always)]
            fn from(variant: TM_DAT_DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TM_DAT_DIR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TM_DAT_DIR_A {
                match self.bits {
                    false => TM_DAT_DIR_A::HOST_TO_CARD,
                    true => TM_DAT_DIR_A::CARD_TO_HOST,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_host_to_card(&self) -> bool {
                *self == TM_DAT_DIR_A::HOST_TO_CARD
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_card_to_host(&self) -> bool {
                *self == TM_DAT_DIR_A::CARD_TO_HOST
            }
        }
        #[doc = "Field `TM_DAT_DIR` writer - Direction of data transfer"]
        pub type TM_DAT_DIR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, TM_DAT_DIR_A>;
        impl<'a, REG, const O: u8> TM_DAT_DIR_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn host_to_card(self) -> &'a mut crate::W<REG> {
                self.variant(TM_DAT_DIR_A::HOST_TO_CARD)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn card_to_host(self) -> &'a mut crate::W<REG> {
                self.variant(TM_DAT_DIR_A::CARD_TO_HOST)
            }
        }
        #[doc = "Field `TM_MULTI_BLOCK` reader - Type of data transfer"]
        pub type TM_MULTI_BLOCK_R = crate::BitReader<TM_MULTI_BLOCK_A>;
        #[doc = "Type of data transfer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TM_MULTI_BLOCK_A {
            #[doc = "0: `0`"]
            SINGLE = 0,
            #[doc = "1: `1`"]
            MULTIPLE = 1,
        }
        impl From<TM_MULTI_BLOCK_A> for bool {
            #[inline(always)]
            fn from(variant: TM_MULTI_BLOCK_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TM_MULTI_BLOCK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TM_MULTI_BLOCK_A {
                match self.bits {
                    false => TM_MULTI_BLOCK_A::SINGLE,
                    true => TM_MULTI_BLOCK_A::MULTIPLE,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == TM_MULTI_BLOCK_A::SINGLE
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_multiple(&self) -> bool {
                *self == TM_MULTI_BLOCK_A::MULTIPLE
            }
        }
        #[doc = "Field `TM_MULTI_BLOCK` writer - Type of data transfer"]
        pub type TM_MULTI_BLOCK_W<'a, REG, const O: u8> =
            crate::BitWriter<'a, REG, O, TM_MULTI_BLOCK_A>;
        impl<'a, REG, const O: u8> TM_MULTI_BLOCK_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn single(self) -> &'a mut crate::W<REG> {
                self.variant(TM_MULTI_BLOCK_A::SINGLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn multiple(self) -> &'a mut crate::W<REG> {
                self.variant(TM_MULTI_BLOCK_A::MULTIPLE)
            }
        }
        #[doc = "Field `CMD_RSPNS_TYPE` reader - Type of expected response"]
        pub type CMD_RSPNS_TYPE_R = crate::FieldReader<RESPONSE_A>;
        #[doc = "Type of expected response\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum RESPONSE_A {
            #[doc = "0: `0`"]
            NONE = 0,
            #[doc = "1: `1`"]
            _136BITS = 1,
            #[doc = "2: `10`"]
            _48BITS = 2,
            #[doc = "3: `11`"]
            _48BITS_USING_BUSY = 3,
        }
        impl From<RESPONSE_A> for u8 {
            #[inline(always)]
            fn from(variant: RESPONSE_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for RESPONSE_A {
            type Ux = u8;
        }
        impl CMD_RSPNS_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RESPONSE_A {
                match self.bits {
                    0 => RESPONSE_A::NONE,
                    1 => RESPONSE_A::_136BITS,
                    2 => RESPONSE_A::_48BITS,
                    3 => RESPONSE_A::_48BITS_USING_BUSY,
                    _ => unreachable!(),
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == RESPONSE_A::NONE
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_136bits(&self) -> bool {
                *self == RESPONSE_A::_136BITS
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_48bits(&self) -> bool {
                *self == RESPONSE_A::_48BITS
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_48bits_using_busy(&self) -> bool {
                *self == RESPONSE_A::_48BITS_USING_BUSY
            }
        }
        #[doc = "Field `CMD_RSPNS_TYPE` writer - Type of expected response"]
        pub type CMD_RSPNS_TYPE_W<'a, REG, const O: u8> =
            crate::FieldWriterSafe<'a, REG, 2, O, RESPONSE_A>;
        impl<'a, REG, const O: u8> CMD_RSPNS_TYPE_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn none(self) -> &'a mut crate::W<REG> {
                self.variant(RESPONSE_A::NONE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn _136bits(self) -> &'a mut crate::W<REG> {
                self.variant(RESPONSE_A::_136BITS)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn _48bits(self) -> &'a mut crate::W<REG> {
                self.variant(RESPONSE_A::_48BITS)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn _48bits_using_busy(self) -> &'a mut crate::W<REG> {
                self.variant(RESPONSE_A::_48BITS_USING_BUSY)
            }
        }
        #[doc = "Field `CMD_CRCCHK_EN` reader - Check the responses CRC"]
        pub type CMD_CRCCHK_EN_R = crate::BitReader;
        #[doc = "Field `CMD_CRCCHK_EN` writer - Check the responses CRC"]
        pub type CMD_CRCCHK_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CMD_IXCHK_EN` reader - Check that the response has the same command index"]
        pub type CMD_IXCHK_EN_R = crate::BitReader;
        #[doc = "Field `CMD_IXCHK_EN` writer - Check that the response has the same command index"]
        pub type CMD_IXCHK_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CMD_ISDATA` reader - Command involves data"]
        pub type CMD_ISDATA_R = crate::BitReader;
        #[doc = "Field `CMD_ISDATA` writer - Command involves data"]
        pub type CMD_ISDATA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CMD_TYPE` reader - Type of command to be issued"]
        pub type CMD_TYPE_R = crate::FieldReader<CMD_TYPE_A>;
        #[doc = "Type of command to be issued\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CMD_TYPE_A {
            #[doc = "0: `0`"]
            NORMAL = 0,
            #[doc = "1: `1`"]
            SUSPEND = 1,
            #[doc = "2: `10`"]
            RESUME = 2,
            #[doc = "3: `11`"]
            ABORT = 3,
        }
        impl From<CMD_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: CMD_TYPE_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CMD_TYPE_A {
            type Ux = u8;
        }
        impl CMD_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CMD_TYPE_A {
                match self.bits {
                    0 => CMD_TYPE_A::NORMAL,
                    1 => CMD_TYPE_A::SUSPEND,
                    2 => CMD_TYPE_A::RESUME,
                    3 => CMD_TYPE_A::ABORT,
                    _ => unreachable!(),
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == CMD_TYPE_A::NORMAL
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_suspend(&self) -> bool {
                *self == CMD_TYPE_A::SUSPEND
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_resume(&self) -> bool {
                *self == CMD_TYPE_A::RESUME
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_abort(&self) -> bool {
                *self == CMD_TYPE_A::ABORT
            }
        }
        #[doc = "Field `CMD_TYPE` writer - Type of command to be issued"]
        pub type CMD_TYPE_W<'a, REG, const O: u8> =
            crate::FieldWriterSafe<'a, REG, 2, O, CMD_TYPE_A>;
        impl<'a, REG, const O: u8> CMD_TYPE_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut crate::W<REG> {
                self.variant(CMD_TYPE_A::NORMAL)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn suspend(self) -> &'a mut crate::W<REG> {
                self.variant(CMD_TYPE_A::SUSPEND)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn resume(self) -> &'a mut crate::W<REG> {
                self.variant(CMD_TYPE_A::RESUME)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn abort(self) -> &'a mut crate::W<REG> {
                self.variant(CMD_TYPE_A::ABORT)
            }
        }
        #[doc = "Field `CMD_INDEX` reader - Command index to be issued"]
        pub type CMD_INDEX_R = crate::FieldReader;
        #[doc = "Field `CMD_INDEX` writer - Command index to be issued"]
        pub type CMD_INDEX_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 6, O>;
        impl R {
            #[doc = "Bit 1 - Enable block counter"]
            #[inline(always)]
            pub fn tm_blkcnt_en(&self) -> TM_BLKCNT_EN_R {
                TM_BLKCNT_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:3 - Command after completion"]
            #[inline(always)]
            pub fn tm_auto_cmd_en(&self) -> TM_AUTO_CMD_EN_R {
                TM_AUTO_CMD_EN_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bit 4 - Direction of data transfer"]
            #[inline(always)]
            pub fn tm_dat_dir(&self) -> TM_DAT_DIR_R {
                TM_DAT_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Type of data transfer"]
            #[inline(always)]
            pub fn tm_multi_block(&self) -> TM_MULTI_BLOCK_R {
                TM_MULTI_BLOCK_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bits 16:17 - Type of expected response"]
            #[inline(always)]
            pub fn cmd_rspns_type(&self) -> CMD_RSPNS_TYPE_R {
                CMD_RSPNS_TYPE_R::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bit 19 - Check the responses CRC"]
            #[inline(always)]
            pub fn cmd_crcchk_en(&self) -> CMD_CRCCHK_EN_R {
                CMD_CRCCHK_EN_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Check that the response has the same command index"]
            #[inline(always)]
            pub fn cmd_ixchk_en(&self) -> CMD_IXCHK_EN_R {
                CMD_IXCHK_EN_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Command involves data"]
            #[inline(always)]
            pub fn cmd_isdata(&self) -> CMD_ISDATA_R {
                CMD_ISDATA_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bits 22:23 - Type of command to be issued"]
            #[inline(always)]
            pub fn cmd_type(&self) -> CMD_TYPE_R {
                CMD_TYPE_R::new(((self.bits >> 22) & 3) as u8)
            }
            #[doc = "Bits 24:29 - Command index to be issued"]
            #[inline(always)]
            pub fn cmd_index(&self) -> CMD_INDEX_R {
                CMD_INDEX_R::new(((self.bits >> 24) & 0x3f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CMDTM")
                    .field("cmd_index", &format_args!("{}", self.cmd_index().bits()))
                    .field("cmd_type", &format_args!("{}", self.cmd_type().bits()))
                    .field("cmd_isdata", &format_args!("{}", self.cmd_isdata().bit()))
                    .field(
                        "cmd_ixchk_en",
                        &format_args!("{}", self.cmd_ixchk_en().bit()),
                    )
                    .field(
                        "cmd_crcchk_en",
                        &format_args!("{}", self.cmd_crcchk_en().bit()),
                    )
                    .field(
                        "cmd_rspns_type",
                        &format_args!("{}", self.cmd_rspns_type().bits()),
                    )
                    .field(
                        "tm_multi_block",
                        &format_args!("{}", self.tm_multi_block().bit()),
                    )
                    .field("tm_dat_dir", &format_args!("{}", self.tm_dat_dir().bit()))
                    .field(
                        "tm_auto_cmd_en",
                        &format_args!("{}", self.tm_auto_cmd_en().bits()),
                    )
                    .field(
                        "tm_blkcnt_en",
                        &format_args!("{}", self.tm_blkcnt_en().bit()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CMDTM_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - Enable block counter"]
            #[inline(always)]
            #[must_use]
            pub fn tm_blkcnt_en(&mut self) -> TM_BLKCNT_EN_W<CMDTM_SPEC, 1> {
                TM_BLKCNT_EN_W::new(self)
            }
            #[doc = "Bits 2:3 - Command after completion"]
            #[inline(always)]
            #[must_use]
            pub fn tm_auto_cmd_en(&mut self) -> TM_AUTO_CMD_EN_W<CMDTM_SPEC, 2> {
                TM_AUTO_CMD_EN_W::new(self)
            }
            #[doc = "Bit 4 - Direction of data transfer"]
            #[inline(always)]
            #[must_use]
            pub fn tm_dat_dir(&mut self) -> TM_DAT_DIR_W<CMDTM_SPEC, 4> {
                TM_DAT_DIR_W::new(self)
            }
            #[doc = "Bit 5 - Type of data transfer"]
            #[inline(always)]
            #[must_use]
            pub fn tm_multi_block(&mut self) -> TM_MULTI_BLOCK_W<CMDTM_SPEC, 5> {
                TM_MULTI_BLOCK_W::new(self)
            }
            #[doc = "Bits 16:17 - Type of expected response"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_rspns_type(&mut self) -> CMD_RSPNS_TYPE_W<CMDTM_SPEC, 16> {
                CMD_RSPNS_TYPE_W::new(self)
            }
            #[doc = "Bit 19 - Check the responses CRC"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_crcchk_en(&mut self) -> CMD_CRCCHK_EN_W<CMDTM_SPEC, 19> {
                CMD_CRCCHK_EN_W::new(self)
            }
            #[doc = "Bit 20 - Check that the response has the same command index"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_ixchk_en(&mut self) -> CMD_IXCHK_EN_W<CMDTM_SPEC, 20> {
                CMD_IXCHK_EN_W::new(self)
            }
            #[doc = "Bit 21 - Command involves data"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_isdata(&mut self) -> CMD_ISDATA_W<CMDTM_SPEC, 21> {
                CMD_ISDATA_W::new(self)
            }
            #[doc = "Bits 22:23 - Type of command to be issued"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_type(&mut self) -> CMD_TYPE_W<CMDTM_SPEC, 22> {
                CMD_TYPE_W::new(self)
            }
            #[doc = "Bits 24:29 - Command index to be issued"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_index(&mut self) -> CMD_INDEX_W<CMDTM_SPEC, 24> {
                CMD_INDEX_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Issue commands to the card\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cmdtm::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmdtm::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CMDTM_SPEC;
        impl crate::RegisterSpec for CMDTM_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cmdtm::R`](R) reader structure"]
        impl crate::Readable for CMDTM_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cmdtm::W`](W) writer structure"]
        impl crate::Writable for CMDTM_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CMDTM to value 0"]
        impl crate::Resettable for CMDTM_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RESP0 (rw) register accessor: Status bits of the response\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`resp0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`resp0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@resp0`]
module"]
    pub type RESP0 = crate::Reg<resp0::RESP0_SPEC>;
    #[doc = "Status bits of the response"]
    pub mod resp0 {
        #[doc = "Register `RESP0` reader"]
        pub type R = crate::R<RESP0_SPEC>;
        #[doc = "Register `RESP0` writer"]
        pub type W = crate::W<RESP0_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RESP0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Status bits of the response\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`resp0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`resp0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RESP0_SPEC;
        impl crate::RegisterSpec for RESP0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`resp0::R`](R) reader structure"]
        impl crate::Readable for RESP0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`resp0::W`](W) writer structure"]
        impl crate::Writable for RESP0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets RESP0 to value 0"]
        impl crate::Resettable for RESP0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RESP1 (rw) register accessor: Bits 63:32 of CMD2 and CMD10 responses\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`resp1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`resp1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@resp1`]
module"]
    pub type RESP1 = crate::Reg<resp1::RESP1_SPEC>;
    #[doc = "Bits 63:32 of CMD2 and CMD10 responses"]
    pub mod resp1 {
        #[doc = "Register `RESP1` reader"]
        pub type R = crate::R<RESP1_SPEC>;
        #[doc = "Register `RESP1` writer"]
        pub type W = crate::W<RESP1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RESP1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Bits 63:32 of CMD2 and CMD10 responses\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`resp1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`resp1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RESP1_SPEC;
        impl crate::RegisterSpec for RESP1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`resp1::R`](R) reader structure"]
        impl crate::Readable for RESP1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`resp1::W`](W) writer structure"]
        impl crate::Writable for RESP1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets RESP1 to value 0"]
        impl crate::Resettable for RESP1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RESP2 (rw) register accessor: Bits 95:64 of CMD2 and CMD10 responses\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`resp2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`resp2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@resp2`]
module"]
    pub type RESP2 = crate::Reg<resp2::RESP2_SPEC>;
    #[doc = "Bits 95:64 of CMD2 and CMD10 responses"]
    pub mod resp2 {
        #[doc = "Register `RESP2` reader"]
        pub type R = crate::R<RESP2_SPEC>;
        #[doc = "Register `RESP2` writer"]
        pub type W = crate::W<RESP2_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RESP2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Bits 95:64 of CMD2 and CMD10 responses\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`resp2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`resp2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RESP2_SPEC;
        impl crate::RegisterSpec for RESP2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`resp2::R`](R) reader structure"]
        impl crate::Readable for RESP2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`resp2::W`](W) writer structure"]
        impl crate::Writable for RESP2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets RESP2 to value 0"]
        impl crate::Resettable for RESP2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RESP3 (rw) register accessor: Bits 127:96 of CMD2 and CMD10 responses\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`resp3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`resp3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@resp3`]
module"]
    pub type RESP3 = crate::Reg<resp3::RESP3_SPEC>;
    #[doc = "Bits 127:96 of CMD2 and CMD10 responses"]
    pub mod resp3 {
        #[doc = "Register `RESP3` reader"]
        pub type R = crate::R<RESP3_SPEC>;
        #[doc = "Register `RESP3` writer"]
        pub type W = crate::W<RESP3_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RESP3_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Bits 127:96 of CMD2 and CMD10 responses\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`resp3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`resp3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RESP3_SPEC;
        impl crate::RegisterSpec for RESP3_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`resp3::R`](R) reader structure"]
        impl crate::Readable for RESP3_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`resp3::W`](W) writer structure"]
        impl crate::Writable for RESP3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets RESP3 to value 0"]
        impl crate::Resettable for RESP3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DATA (rw) register accessor: Data to/from the card\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data`]
module"]
    pub type DATA = crate::Reg<data::DATA_SPEC>;
    #[doc = "Data to/from the card"]
    pub mod data {
        #[doc = "Register `DATA` reader"]
        pub type R = crate::R<DATA_SPEC>;
        #[doc = "Register `DATA` writer"]
        pub type W = crate::W<DATA_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DATA_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Data to/from the card\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DATA_SPEC;
        impl crate::RegisterSpec for DATA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`data::R`](R) reader structure"]
        impl crate::Readable for DATA_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"]
        impl crate::Writable for DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DATA to value 0"]
        impl crate::Resettable for DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "STATUS (rw) register accessor: Status info for debugging\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status`]
module"]
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    #[doc = "Status info for debugging"]
    pub mod status {
        #[doc = "Register `STATUS` reader"]
        pub type R = crate::R<STATUS_SPEC>;
        #[doc = "Register `STATUS` writer"]
        pub type W = crate::W<STATUS_SPEC>;
        #[doc = "Field `CMD_INHIBIT` reader - Command line still in use"]
        pub type CMD_INHIBIT_R = crate::BitReader;
        #[doc = "Field `CMD_INHIBIT` writer - Command line still in use"]
        pub type CMD_INHIBIT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DAT_INHIBIT` reader - Data lines still in use"]
        pub type DAT_INHIBIT_R = crate::BitReader;
        #[doc = "Field `DAT_INHIBIT` writer - Data lines still in use"]
        pub type DAT_INHIBIT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DAT_ACTIVE` reader - At least one data line is active"]
        pub type DAT_ACTIVE_R = crate::BitReader;
        #[doc = "Field `DAT_ACTIVE` writer - At least one data line is active"]
        pub type DAT_ACTIVE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WRITE_TRANSFER` reader - Write transfer is active"]
        pub type WRITE_TRANSFER_R = crate::BitReader;
        #[doc = "Field `WRITE_TRANSFER` writer - Write transfer is active"]
        pub type WRITE_TRANSFER_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `READ_TRANSFER` reader - Read transfer is active"]
        pub type READ_TRANSFER_R = crate::BitReader;
        #[doc = "Field `READ_TRANSFER` writer - Read transfer is active"]
        pub type READ_TRANSFER_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BUFFER_WRITE_ENABLE` reader - The buffer has space for new data"]
        pub type BUFFER_WRITE_ENABLE_R = crate::BitReader;
        #[doc = "Field `BUFFER_WRITE_ENABLE` writer - The buffer has space for new data"]
        pub type BUFFER_WRITE_ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BUFFER_READ_ENABLE` reader - New data is available to read"]
        pub type BUFFER_READ_ENABLE_R = crate::BitReader;
        #[doc = "Field `BUFFER_READ_ENABLE` writer - New data is available to read"]
        pub type BUFFER_READ_ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DAT_LEVEL0` reader - Value of DAT\\[3:0\\]"]
        pub type DAT_LEVEL0_R = crate::FieldReader;
        #[doc = "Field `DAT_LEVEL0` writer - Value of DAT\\[3:0\\]"]
        pub type DAT_LEVEL0_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        #[doc = "Field `CMD_LEVEL` reader - Value of CMD"]
        pub type CMD_LEVEL_R = crate::BitReader;
        #[doc = "Field `CMD_LEVEL` writer - Value of CMD"]
        pub type CMD_LEVEL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DAT_LEVEL1` reader - Value of DAT\\[7:4\\]"]
        pub type DAT_LEVEL1_R = crate::FieldReader;
        #[doc = "Field `DAT_LEVEL1` writer - Value of DAT\\[7:4\\]"]
        pub type DAT_LEVEL1_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        impl R {
            #[doc = "Bit 0 - Command line still in use"]
            #[inline(always)]
            pub fn cmd_inhibit(&self) -> CMD_INHIBIT_R {
                CMD_INHIBIT_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Data lines still in use"]
            #[inline(always)]
            pub fn dat_inhibit(&self) -> DAT_INHIBIT_R {
                DAT_INHIBIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - At least one data line is active"]
            #[inline(always)]
            pub fn dat_active(&self) -> DAT_ACTIVE_R {
                DAT_ACTIVE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 8 - Write transfer is active"]
            #[inline(always)]
            pub fn write_transfer(&self) -> WRITE_TRANSFER_R {
                WRITE_TRANSFER_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Read transfer is active"]
            #[inline(always)]
            pub fn read_transfer(&self) -> READ_TRANSFER_R {
                READ_TRANSFER_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - The buffer has space for new data"]
            #[inline(always)]
            pub fn buffer_write_enable(&self) -> BUFFER_WRITE_ENABLE_R {
                BUFFER_WRITE_ENABLE_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - New data is available to read"]
            #[inline(always)]
            pub fn buffer_read_enable(&self) -> BUFFER_READ_ENABLE_R {
                BUFFER_READ_ENABLE_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 20:23 - Value of DAT\\[3:0\\]"]
            #[inline(always)]
            pub fn dat_level0(&self) -> DAT_LEVEL0_R {
                DAT_LEVEL0_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bit 24 - Value of CMD"]
            #[inline(always)]
            pub fn cmd_level(&self) -> CMD_LEVEL_R {
                CMD_LEVEL_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bits 25:28 - Value of DAT\\[7:4\\]"]
            #[inline(always)]
            pub fn dat_level1(&self) -> DAT_LEVEL1_R {
                DAT_LEVEL1_R::new(((self.bits >> 25) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STATUS")
                    .field("dat_level1", &format_args!("{}", self.dat_level1().bits()))
                    .field("cmd_level", &format_args!("{}", self.cmd_level().bit()))
                    .field("dat_level0", &format_args!("{}", self.dat_level0().bits()))
                    .field(
                        "buffer_read_enable",
                        &format_args!("{}", self.buffer_read_enable().bit()),
                    )
                    .field(
                        "buffer_write_enable",
                        &format_args!("{}", self.buffer_write_enable().bit()),
                    )
                    .field(
                        "read_transfer",
                        &format_args!("{}", self.read_transfer().bit()),
                    )
                    .field(
                        "write_transfer",
                        &format_args!("{}", self.write_transfer().bit()),
                    )
                    .field("dat_active", &format_args!("{}", self.dat_active().bit()))
                    .field("dat_inhibit", &format_args!("{}", self.dat_inhibit().bit()))
                    .field("cmd_inhibit", &format_args!("{}", self.cmd_inhibit().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<STATUS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Command line still in use"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_inhibit(&mut self) -> CMD_INHIBIT_W<STATUS_SPEC, 0> {
                CMD_INHIBIT_W::new(self)
            }
            #[doc = "Bit 1 - Data lines still in use"]
            #[inline(always)]
            #[must_use]
            pub fn dat_inhibit(&mut self) -> DAT_INHIBIT_W<STATUS_SPEC, 1> {
                DAT_INHIBIT_W::new(self)
            }
            #[doc = "Bit 2 - At least one data line is active"]
            #[inline(always)]
            #[must_use]
            pub fn dat_active(&mut self) -> DAT_ACTIVE_W<STATUS_SPEC, 2> {
                DAT_ACTIVE_W::new(self)
            }
            #[doc = "Bit 8 - Write transfer is active"]
            #[inline(always)]
            #[must_use]
            pub fn write_transfer(&mut self) -> WRITE_TRANSFER_W<STATUS_SPEC, 8> {
                WRITE_TRANSFER_W::new(self)
            }
            #[doc = "Bit 9 - Read transfer is active"]
            #[inline(always)]
            #[must_use]
            pub fn read_transfer(&mut self) -> READ_TRANSFER_W<STATUS_SPEC, 9> {
                READ_TRANSFER_W::new(self)
            }
            #[doc = "Bit 10 - The buffer has space for new data"]
            #[inline(always)]
            #[must_use]
            pub fn buffer_write_enable(&mut self) -> BUFFER_WRITE_ENABLE_W<STATUS_SPEC, 10> {
                BUFFER_WRITE_ENABLE_W::new(self)
            }
            #[doc = "Bit 11 - New data is available to read"]
            #[inline(always)]
            #[must_use]
            pub fn buffer_read_enable(&mut self) -> BUFFER_READ_ENABLE_W<STATUS_SPEC, 11> {
                BUFFER_READ_ENABLE_W::new(self)
            }
            #[doc = "Bits 20:23 - Value of DAT\\[3:0\\]"]
            #[inline(always)]
            #[must_use]
            pub fn dat_level0(&mut self) -> DAT_LEVEL0_W<STATUS_SPEC, 20> {
                DAT_LEVEL0_W::new(self)
            }
            #[doc = "Bit 24 - Value of CMD"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_level(&mut self) -> CMD_LEVEL_W<STATUS_SPEC, 24> {
                CMD_LEVEL_W::new(self)
            }
            #[doc = "Bits 25:28 - Value of DAT\\[7:4\\]"]
            #[inline(always)]
            #[must_use]
            pub fn dat_level1(&mut self) -> DAT_LEVEL1_W<STATUS_SPEC, 25> {
                DAT_LEVEL1_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Status info for debugging\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`status::R`](R) reader structure"]
        impl crate::Readable for STATUS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`status::W`](W) writer structure"]
        impl crate::Writable for STATUS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets STATUS to value 0"]
        impl crate::Resettable for STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CONTROL0 (rw) register accessor: Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`control0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control0`]
module"]
    pub type CONTROL0 = crate::Reg<control0::CONTROL0_SPEC>;
    #[doc = "Control"]
    pub mod control0 {
        #[doc = "Register `CONTROL0` reader"]
        pub type R = crate::R<CONTROL0_SPEC>;
        #[doc = "Register `CONTROL0` writer"]
        pub type W = crate::W<CONTROL0_SPEC>;
        #[doc = "Field `HCTL_DWIDTH` reader - Use 4 data lines"]
        pub type HCTL_DWIDTH_R = crate::BitReader;
        #[doc = "Field `HCTL_DWIDTH` writer - Use 4 data lines"]
        pub type HCTL_DWIDTH_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HCTL_HS_EN` reader - Enable high speed mode"]
        pub type HCTL_HS_EN_R = crate::BitReader;
        #[doc = "Field `HCTL_HS_EN` writer - Enable high speed mode"]
        pub type HCTL_HS_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `HCTL_8BIT` reader - Use 8 data lines"]
        pub type HCTL_8BIT_R = crate::BitReader;
        #[doc = "Field `HCTL_8BIT` writer - Use 8 data lines"]
        pub type HCTL_8BIT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GAP_STOP` reader - Stop the current transaction at the next block gap"]
        pub type GAP_STOP_R = crate::BitReader;
        #[doc = "Field `GAP_STOP` writer - Stop the current transaction at the next block gap"]
        pub type GAP_STOP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GAP_RESTART` reader - Restart a transaction stopped by GAP_STOP"]
        pub type GAP_RESTART_R = crate::BitReader;
        #[doc = "Field `GAP_RESTART` writer - Restart a transaction stopped by GAP_STOP"]
        pub type GAP_RESTART_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `READWAIT_EN` reader - Use DAT2 read/wait protocol"]
        pub type READWAIT_EN_R = crate::BitReader;
        #[doc = "Field `READWAIT_EN` writer - Use DAT2 read/wait protocol"]
        pub type READWAIT_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `GAP_IEN` reader - Enable interrupt on block gap"]
        pub type GAP_IEN_R = crate::BitReader;
        #[doc = "Field `GAP_IEN` writer - Enable interrupt on block gap"]
        pub type GAP_IEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SPI_MODE` reader - Enable SPI mode"]
        pub type SPI_MODE_R = crate::BitReader;
        #[doc = "Field `SPI_MODE` writer - Enable SPI mode"]
        pub type SPI_MODE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BOOT_EN` reader - Boot mode enabled"]
        pub type BOOT_EN_R = crate::BitReader;
        #[doc = "Field `BOOT_EN` writer - Boot mode enabled"]
        pub type BOOT_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ALT_BOOT_EN` reader - Enable alternate boot mode"]
        pub type ALT_BOOT_EN_R = crate::BitReader;
        #[doc = "Field `ALT_BOOT_EN` writer - Enable alternate boot mode"]
        pub type ALT_BOOT_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 1 - Use 4 data lines"]
            #[inline(always)]
            pub fn hctl_dwidth(&self) -> HCTL_DWIDTH_R {
                HCTL_DWIDTH_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable high speed mode"]
            #[inline(always)]
            pub fn hctl_hs_en(&self) -> HCTL_HS_EN_R {
                HCTL_HS_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 5 - Use 8 data lines"]
            #[inline(always)]
            pub fn hctl_8bit(&self) -> HCTL_8BIT_R {
                HCTL_8BIT_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 16 - Stop the current transaction at the next block gap"]
            #[inline(always)]
            pub fn gap_stop(&self) -> GAP_STOP_R {
                GAP_STOP_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Restart a transaction stopped by GAP_STOP"]
            #[inline(always)]
            pub fn gap_restart(&self) -> GAP_RESTART_R {
                GAP_RESTART_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Use DAT2 read/wait protocol"]
            #[inline(always)]
            pub fn readwait_en(&self) -> READWAIT_EN_R {
                READWAIT_EN_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Enable interrupt on block gap"]
            #[inline(always)]
            pub fn gap_ien(&self) -> GAP_IEN_R {
                GAP_IEN_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Enable SPI mode"]
            #[inline(always)]
            pub fn spi_mode(&self) -> SPI_MODE_R {
                SPI_MODE_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Boot mode enabled"]
            #[inline(always)]
            pub fn boot_en(&self) -> BOOT_EN_R {
                BOOT_EN_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Enable alternate boot mode"]
            #[inline(always)]
            pub fn alt_boot_en(&self) -> ALT_BOOT_EN_R {
                ALT_BOOT_EN_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CONTROL0")
                    .field("alt_boot_en", &format_args!("{}", self.alt_boot_en().bit()))
                    .field("boot_en", &format_args!("{}", self.boot_en().bit()))
                    .field("spi_mode", &format_args!("{}", self.spi_mode().bit()))
                    .field("gap_ien", &format_args!("{}", self.gap_ien().bit()))
                    .field("readwait_en", &format_args!("{}", self.readwait_en().bit()))
                    .field("gap_restart", &format_args!("{}", self.gap_restart().bit()))
                    .field("gap_stop", &format_args!("{}", self.gap_stop().bit()))
                    .field("hctl_8bit", &format_args!("{}", self.hctl_8bit().bit()))
                    .field("hctl_hs_en", &format_args!("{}", self.hctl_hs_en().bit()))
                    .field("hctl_dwidth", &format_args!("{}", self.hctl_dwidth().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CONTROL0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 1 - Use 4 data lines"]
            #[inline(always)]
            #[must_use]
            pub fn hctl_dwidth(&mut self) -> HCTL_DWIDTH_W<CONTROL0_SPEC, 1> {
                HCTL_DWIDTH_W::new(self)
            }
            #[doc = "Bit 2 - Enable high speed mode"]
            #[inline(always)]
            #[must_use]
            pub fn hctl_hs_en(&mut self) -> HCTL_HS_EN_W<CONTROL0_SPEC, 2> {
                HCTL_HS_EN_W::new(self)
            }
            #[doc = "Bit 5 - Use 8 data lines"]
            #[inline(always)]
            #[must_use]
            pub fn hctl_8bit(&mut self) -> HCTL_8BIT_W<CONTROL0_SPEC, 5> {
                HCTL_8BIT_W::new(self)
            }
            #[doc = "Bit 16 - Stop the current transaction at the next block gap"]
            #[inline(always)]
            #[must_use]
            pub fn gap_stop(&mut self) -> GAP_STOP_W<CONTROL0_SPEC, 16> {
                GAP_STOP_W::new(self)
            }
            #[doc = "Bit 17 - Restart a transaction stopped by GAP_STOP"]
            #[inline(always)]
            #[must_use]
            pub fn gap_restart(&mut self) -> GAP_RESTART_W<CONTROL0_SPEC, 17> {
                GAP_RESTART_W::new(self)
            }
            #[doc = "Bit 18 - Use DAT2 read/wait protocol"]
            #[inline(always)]
            #[must_use]
            pub fn readwait_en(&mut self) -> READWAIT_EN_W<CONTROL0_SPEC, 18> {
                READWAIT_EN_W::new(self)
            }
            #[doc = "Bit 19 - Enable interrupt on block gap"]
            #[inline(always)]
            #[must_use]
            pub fn gap_ien(&mut self) -> GAP_IEN_W<CONTROL0_SPEC, 19> {
                GAP_IEN_W::new(self)
            }
            #[doc = "Bit 20 - Enable SPI mode"]
            #[inline(always)]
            #[must_use]
            pub fn spi_mode(&mut self) -> SPI_MODE_W<CONTROL0_SPEC, 20> {
                SPI_MODE_W::new(self)
            }
            #[doc = "Bit 21 - Boot mode enabled"]
            #[inline(always)]
            #[must_use]
            pub fn boot_en(&mut self) -> BOOT_EN_W<CONTROL0_SPEC, 21> {
                BOOT_EN_W::new(self)
            }
            #[doc = "Bit 22 - Enable alternate boot mode"]
            #[inline(always)]
            #[must_use]
            pub fn alt_boot_en(&mut self) -> ALT_BOOT_EN_W<CONTROL0_SPEC, 22> {
                ALT_BOOT_EN_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`control0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CONTROL0_SPEC;
        impl crate::RegisterSpec for CONTROL0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`control0::R`](R) reader structure"]
        impl crate::Readable for CONTROL0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`control0::W`](W) writer structure"]
        impl crate::Writable for CONTROL0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CONTROL0 to value 0"]
        impl crate::Resettable for CONTROL0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CONTROL1 (rw) register accessor: Configure\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`control1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control1`]
module"]
    pub type CONTROL1 = crate::Reg<control1::CONTROL1_SPEC>;
    #[doc = "Configure"]
    pub mod control1 {
        #[doc = "Register `CONTROL1` reader"]
        pub type R = crate::R<CONTROL1_SPEC>;
        #[doc = "Register `CONTROL1` writer"]
        pub type W = crate::W<CONTROL1_SPEC>;
        #[doc = "Field `CLK_INTLEN` reader - Enable internal clock"]
        pub type CLK_INTLEN_R = crate::BitReader;
        #[doc = "Field `CLK_INTLEN` writer - Enable internal clock"]
        pub type CLK_INTLEN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CLK_STABLE` reader - SD Clock stable"]
        pub type CLK_STABLE_R = crate::BitReader;
        #[doc = "Field `CLK_EN` reader - SD Clock enable"]
        pub type CLK_EN_R = crate::BitReader;
        #[doc = "Field `CLK_EN` writer - SD Clock enable"]
        pub type CLK_EN_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CLK_GENSEL` reader - Mode of clock generation"]
        pub type CLK_GENSEL_R = crate::BitReader<CLK_GENSEL_A>;
        #[doc = "Mode of clock generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CLK_GENSEL_A {
            #[doc = "0: `0`"]
            DIVIDED = 0,
            #[doc = "1: `1`"]
            PROGRAMMABLE = 1,
        }
        impl From<CLK_GENSEL_A> for bool {
            #[inline(always)]
            fn from(variant: CLK_GENSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CLK_GENSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CLK_GENSEL_A {
                match self.bits {
                    false => CLK_GENSEL_A::DIVIDED,
                    true => CLK_GENSEL_A::PROGRAMMABLE,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_divided(&self) -> bool {
                *self == CLK_GENSEL_A::DIVIDED
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_programmable(&self) -> bool {
                *self == CLK_GENSEL_A::PROGRAMMABLE
            }
        }
        #[doc = "Field `CLK_GENSEL` writer - Mode of clock generation"]
        pub type CLK_GENSEL_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, CLK_GENSEL_A>;
        impl<'a, REG, const O: u8> CLK_GENSEL_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn divided(self) -> &'a mut crate::W<REG> {
                self.variant(CLK_GENSEL_A::DIVIDED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn programmable(self) -> &'a mut crate::W<REG> {
                self.variant(CLK_GENSEL_A::PROGRAMMABLE)
            }
        }
        #[doc = "Field `CLK_FREQ_MS2` reader - Clock base divider MSBs"]
        pub type CLK_FREQ_MS2_R = crate::FieldReader;
        #[doc = "Field `CLK_FREQ_MS2` writer - Clock base divider MSBs"]
        pub type CLK_FREQ_MS2_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 2, O>;
        #[doc = "Field `CLK_FREQ8` reader - Clock base divider LSB"]
        pub type CLK_FREQ8_R = crate::FieldReader;
        #[doc = "Field `CLK_FREQ8` writer - Clock base divider LSB"]
        pub type CLK_FREQ8_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `DATA_TOUNIT` reader - Data timeout exponent (TMCLK * 2 ** (x + 13)) 1111 disabled"]
        pub type DATA_TOUNIT_R = crate::FieldReader;
        #[doc = "Field `DATA_TOUNIT` writer - Data timeout exponent (TMCLK * 2 ** (x + 13)) 1111 disabled"]
        pub type DATA_TOUNIT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 4, O>;
        #[doc = "Field `SRST_HC` reader - Reset the complete host circuit"]
        pub type SRST_HC_R = crate::BitReader;
        #[doc = "Field `SRST_HC` writer - Reset the complete host circuit"]
        pub type SRST_HC_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SRST_CMD` reader - Reset the command handling circuit"]
        pub type SRST_CMD_R = crate::BitReader;
        #[doc = "Field `SRST_CMD` writer - Reset the command handling circuit"]
        pub type SRST_CMD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `SRST_DATA` reader - Reset the data handling circuit"]
        pub type SRST_DATA_R = crate::BitReader;
        #[doc = "Field `SRST_DATA` writer - Reset the data handling circuit"]
        pub type SRST_DATA_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Enable internal clock"]
            #[inline(always)]
            pub fn clk_intlen(&self) -> CLK_INTLEN_R {
                CLK_INTLEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - SD Clock stable"]
            #[inline(always)]
            pub fn clk_stable(&self) -> CLK_STABLE_R {
                CLK_STABLE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - SD Clock enable"]
            #[inline(always)]
            pub fn clk_en(&self) -> CLK_EN_R {
                CLK_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 5 - Mode of clock generation"]
            #[inline(always)]
            pub fn clk_gensel(&self) -> CLK_GENSEL_R {
                CLK_GENSEL_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bits 6:7 - Clock base divider MSBs"]
            #[inline(always)]
            pub fn clk_freq_ms2(&self) -> CLK_FREQ_MS2_R {
                CLK_FREQ_MS2_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:15 - Clock base divider LSB"]
            #[inline(always)]
            pub fn clk_freq8(&self) -> CLK_FREQ8_R {
                CLK_FREQ8_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:19 - Data timeout exponent (TMCLK * 2 ** (x + 13)) 1111 disabled"]
            #[inline(always)]
            pub fn data_tounit(&self) -> DATA_TOUNIT_R {
                DATA_TOUNIT_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bit 24 - Reset the complete host circuit"]
            #[inline(always)]
            pub fn srst_hc(&self) -> SRST_HC_R {
                SRST_HC_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Reset the command handling circuit"]
            #[inline(always)]
            pub fn srst_cmd(&self) -> SRST_CMD_R {
                SRST_CMD_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - Reset the data handling circuit"]
            #[inline(always)]
            pub fn srst_data(&self) -> SRST_DATA_R {
                SRST_DATA_R::new(((self.bits >> 26) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CONTROL1")
                    .field("srst_data", &format_args!("{}", self.srst_data().bit()))
                    .field("srst_cmd", &format_args!("{}", self.srst_cmd().bit()))
                    .field("srst_hc", &format_args!("{}", self.srst_hc().bit()))
                    .field(
                        "data_tounit",
                        &format_args!("{}", self.data_tounit().bits()),
                    )
                    .field("clk_freq8", &format_args!("{}", self.clk_freq8().bits()))
                    .field(
                        "clk_freq_ms2",
                        &format_args!("{}", self.clk_freq_ms2().bits()),
                    )
                    .field("clk_gensel", &format_args!("{}", self.clk_gensel().bit()))
                    .field("clk_en", &format_args!("{}", self.clk_en().bit()))
                    .field("clk_stable", &format_args!("{}", self.clk_stable().bit()))
                    .field("clk_intlen", &format_args!("{}", self.clk_intlen().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CONTROL1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable internal clock"]
            #[inline(always)]
            #[must_use]
            pub fn clk_intlen(&mut self) -> CLK_INTLEN_W<CONTROL1_SPEC, 0> {
                CLK_INTLEN_W::new(self)
            }
            #[doc = "Bit 2 - SD Clock enable"]
            #[inline(always)]
            #[must_use]
            pub fn clk_en(&mut self) -> CLK_EN_W<CONTROL1_SPEC, 2> {
                CLK_EN_W::new(self)
            }
            #[doc = "Bit 5 - Mode of clock generation"]
            #[inline(always)]
            #[must_use]
            pub fn clk_gensel(&mut self) -> CLK_GENSEL_W<CONTROL1_SPEC, 5> {
                CLK_GENSEL_W::new(self)
            }
            #[doc = "Bits 6:7 - Clock base divider MSBs"]
            #[inline(always)]
            #[must_use]
            pub fn clk_freq_ms2(&mut self) -> CLK_FREQ_MS2_W<CONTROL1_SPEC, 6> {
                CLK_FREQ_MS2_W::new(self)
            }
            #[doc = "Bits 8:15 - Clock base divider LSB"]
            #[inline(always)]
            #[must_use]
            pub fn clk_freq8(&mut self) -> CLK_FREQ8_W<CONTROL1_SPEC, 8> {
                CLK_FREQ8_W::new(self)
            }
            #[doc = "Bits 16:19 - Data timeout exponent (TMCLK * 2 ** (x + 13)) 1111 disabled"]
            #[inline(always)]
            #[must_use]
            pub fn data_tounit(&mut self) -> DATA_TOUNIT_W<CONTROL1_SPEC, 16> {
                DATA_TOUNIT_W::new(self)
            }
            #[doc = "Bit 24 - Reset the complete host circuit"]
            #[inline(always)]
            #[must_use]
            pub fn srst_hc(&mut self) -> SRST_HC_W<CONTROL1_SPEC, 24> {
                SRST_HC_W::new(self)
            }
            #[doc = "Bit 25 - Reset the command handling circuit"]
            #[inline(always)]
            #[must_use]
            pub fn srst_cmd(&mut self) -> SRST_CMD_W<CONTROL1_SPEC, 25> {
                SRST_CMD_W::new(self)
            }
            #[doc = "Bit 26 - Reset the data handling circuit"]
            #[inline(always)]
            #[must_use]
            pub fn srst_data(&mut self) -> SRST_DATA_W<CONTROL1_SPEC, 26> {
                SRST_DATA_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Configure\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`control1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CONTROL1_SPEC;
        impl crate::RegisterSpec for CONTROL1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`control1::R`](R) reader structure"]
        impl crate::Readable for CONTROL1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`control1::W`](W) writer structure"]
        impl crate::Writable for CONTROL1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CONTROL1 to value 0"]
        impl crate::Resettable for CONTROL1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "INTERRUPT (rw) register accessor: Interrupt flags\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`interrupt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`interrupt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@interrupt`]
module"]
    pub type INTERRUPT = crate::Reg<interrupt::INTERRUPT_SPEC>;
    #[doc = "Interrupt flags"]
    pub mod interrupt {
        #[doc = "Register `INTERRUPT` reader"]
        pub type R = crate::R<INTERRUPT_SPEC>;
        #[doc = "Register `INTERRUPT` writer"]
        pub type W = crate::W<INTERRUPT_SPEC>;
        #[doc = "Field `CMD_DONE` reader - Command has finished"]
        pub type CMD_DONE_R = crate::BitReader;
        #[doc = "Field `CMD_DONE` writer - Command has finished"]
        pub type CMD_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DATA_DONE` reader - Data transfer has finished"]
        pub type DATA_DONE_R = crate::BitReader;
        #[doc = "Field `DATA_DONE` writer - Data transfer has finished"]
        pub type DATA_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BLOCK_GAP` reader - Data transfer has stopped at block gap"]
        pub type BLOCK_GAP_R = crate::BitReader;
        #[doc = "Field `BLOCK_GAP` writer - Data transfer has stopped at block gap"]
        pub type BLOCK_GAP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WRITE_RDY` reader - DATA can be written to"]
        pub type WRITE_RDY_R = crate::BitReader;
        #[doc = "Field `WRITE_RDY` writer - DATA can be written to"]
        pub type WRITE_RDY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `READ_RDY` reader - DATA contains data to be read"]
        pub type READ_RDY_R = crate::BitReader;
        #[doc = "Field `READ_RDY` writer - DATA contains data to be read"]
        pub type READ_RDY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CARD` reader - Card made interrupt request"]
        pub type CARD_R = crate::BitReader;
        #[doc = "Field `CARD` writer - Card made interrupt request"]
        pub type CARD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RETUNE` reader - Clock retune request"]
        pub type RETUNE_R = crate::BitReader;
        #[doc = "Field `RETUNE` writer - Clock retune request"]
        pub type RETUNE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BOOTACK` reader - Boot has been acknowledged"]
        pub type BOOTACK_R = crate::BitReader;
        #[doc = "Field `BOOTACK` writer - Boot has been acknowledged"]
        pub type BOOTACK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENDBOOT` reader - Boot operation has terminated"]
        pub type ENDBOOT_R = crate::BitReader;
        #[doc = "Field `ENDBOOT` writer - Boot operation has terminated"]
        pub type ENDBOOT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ERR` reader - An error has occured"]
        pub type ERR_R = crate::BitReader;
        #[doc = "Field `CTO_ERR` reader - Command timeout"]
        pub type CTO_ERR_R = crate::BitReader;
        #[doc = "Field `CTO_ERR` writer - Command timeout"]
        pub type CTO_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CCRC_ERR` reader - Command CRC error"]
        pub type CCRC_ERR_R = crate::BitReader;
        #[doc = "Field `CCRC_ERR` writer - Command CRC error"]
        pub type CCRC_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CEND_ERR` reader - Command end bit error (not 1)"]
        pub type CEND_ERR_R = crate::BitReader;
        #[doc = "Field `CEND_ERR` writer - Command end bit error (not 1)"]
        pub type CEND_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CBAD_ERR` reader - Incorrect response command index"]
        pub type CBAD_ERR_R = crate::BitReader;
        #[doc = "Field `CBAD_ERR` writer - Incorrect response command index"]
        pub type CBAD_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DTO_ERR` reader - Data timeout"]
        pub type DTO_ERR_R = crate::BitReader;
        #[doc = "Field `DTO_ERR` writer - Data timeout"]
        pub type DTO_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DCRC_ERR` reader - Data CRC error"]
        pub type DCRC_ERR_R = crate::BitReader;
        #[doc = "Field `DCRC_ERR` writer - Data CRC error"]
        pub type DCRC_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DEND_ERR` reader - Data end bit error (not 1)"]
        pub type DEND_ERR_R = crate::BitReader;
        #[doc = "Field `DEND_ERR` writer - Data end bit error (not 1)"]
        pub type DEND_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ACMD_ERR` reader - Auto command error"]
        pub type ACMD_ERR_R = crate::BitReader;
        #[doc = "Field `ACMD_ERR` writer - Auto command error"]
        pub type ACMD_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Command has finished"]
            #[inline(always)]
            pub fn cmd_done(&self) -> CMD_DONE_R {
                CMD_DONE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Data transfer has finished"]
            #[inline(always)]
            pub fn data_done(&self) -> DATA_DONE_R {
                DATA_DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Data transfer has stopped at block gap"]
            #[inline(always)]
            pub fn block_gap(&self) -> BLOCK_GAP_R {
                BLOCK_GAP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - DATA can be written to"]
            #[inline(always)]
            pub fn write_rdy(&self) -> WRITE_RDY_R {
                WRITE_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DATA contains data to be read"]
            #[inline(always)]
            pub fn read_rdy(&self) -> READ_RDY_R {
                READ_RDY_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 8 - Card made interrupt request"]
            #[inline(always)]
            pub fn card(&self) -> CARD_R {
                CARD_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 12 - Clock retune request"]
            #[inline(always)]
            pub fn retune(&self) -> RETUNE_R {
                RETUNE_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Boot has been acknowledged"]
            #[inline(always)]
            pub fn bootack(&self) -> BOOTACK_R {
                BOOTACK_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Boot operation has terminated"]
            #[inline(always)]
            pub fn endboot(&self) -> ENDBOOT_R {
                ENDBOOT_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - An error has occured"]
            #[inline(always)]
            pub fn err(&self) -> ERR_R {
                ERR_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Command timeout"]
            #[inline(always)]
            pub fn cto_err(&self) -> CTO_ERR_R {
                CTO_ERR_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Command CRC error"]
            #[inline(always)]
            pub fn ccrc_err(&self) -> CCRC_ERR_R {
                CCRC_ERR_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Command end bit error (not 1)"]
            #[inline(always)]
            pub fn cend_err(&self) -> CEND_ERR_R {
                CEND_ERR_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Incorrect response command index"]
            #[inline(always)]
            pub fn cbad_err(&self) -> CBAD_ERR_R {
                CBAD_ERR_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Data timeout"]
            #[inline(always)]
            pub fn dto_err(&self) -> DTO_ERR_R {
                DTO_ERR_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Data CRC error"]
            #[inline(always)]
            pub fn dcrc_err(&self) -> DCRC_ERR_R {
                DCRC_ERR_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Data end bit error (not 1)"]
            #[inline(always)]
            pub fn dend_err(&self) -> DEND_ERR_R {
                DEND_ERR_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 24 - Auto command error"]
            #[inline(always)]
            pub fn acmd_err(&self) -> ACMD_ERR_R {
                ACMD_ERR_R::new(((self.bits >> 24) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("INTERRUPT")
                    .field("acmd_err", &format_args!("{}", self.acmd_err().bit()))
                    .field("dend_err", &format_args!("{}", self.dend_err().bit()))
                    .field("dcrc_err", &format_args!("{}", self.dcrc_err().bit()))
                    .field("dto_err", &format_args!("{}", self.dto_err().bit()))
                    .field("cbad_err", &format_args!("{}", self.cbad_err().bit()))
                    .field("cend_err", &format_args!("{}", self.cend_err().bit()))
                    .field("ccrc_err", &format_args!("{}", self.ccrc_err().bit()))
                    .field("cto_err", &format_args!("{}", self.cto_err().bit()))
                    .field("err", &format_args!("{}", self.err().bit()))
                    .field("endboot", &format_args!("{}", self.endboot().bit()))
                    .field("bootack", &format_args!("{}", self.bootack().bit()))
                    .field("retune", &format_args!("{}", self.retune().bit()))
                    .field("card", &format_args!("{}", self.card().bit()))
                    .field("read_rdy", &format_args!("{}", self.read_rdy().bit()))
                    .field("write_rdy", &format_args!("{}", self.write_rdy().bit()))
                    .field("block_gap", &format_args!("{}", self.block_gap().bit()))
                    .field("data_done", &format_args!("{}", self.data_done().bit()))
                    .field("cmd_done", &format_args!("{}", self.cmd_done().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<INTERRUPT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Command has finished"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_done(&mut self) -> CMD_DONE_W<INTERRUPT_SPEC, 0> {
                CMD_DONE_W::new(self)
            }
            #[doc = "Bit 1 - Data transfer has finished"]
            #[inline(always)]
            #[must_use]
            pub fn data_done(&mut self) -> DATA_DONE_W<INTERRUPT_SPEC, 1> {
                DATA_DONE_W::new(self)
            }
            #[doc = "Bit 2 - Data transfer has stopped at block gap"]
            #[inline(always)]
            #[must_use]
            pub fn block_gap(&mut self) -> BLOCK_GAP_W<INTERRUPT_SPEC, 2> {
                BLOCK_GAP_W::new(self)
            }
            #[doc = "Bit 4 - DATA can be written to"]
            #[inline(always)]
            #[must_use]
            pub fn write_rdy(&mut self) -> WRITE_RDY_W<INTERRUPT_SPEC, 4> {
                WRITE_RDY_W::new(self)
            }
            #[doc = "Bit 5 - DATA contains data to be read"]
            #[inline(always)]
            #[must_use]
            pub fn read_rdy(&mut self) -> READ_RDY_W<INTERRUPT_SPEC, 5> {
                READ_RDY_W::new(self)
            }
            #[doc = "Bit 8 - Card made interrupt request"]
            #[inline(always)]
            #[must_use]
            pub fn card(&mut self) -> CARD_W<INTERRUPT_SPEC, 8> {
                CARD_W::new(self)
            }
            #[doc = "Bit 12 - Clock retune request"]
            #[inline(always)]
            #[must_use]
            pub fn retune(&mut self) -> RETUNE_W<INTERRUPT_SPEC, 12> {
                RETUNE_W::new(self)
            }
            #[doc = "Bit 13 - Boot has been acknowledged"]
            #[inline(always)]
            #[must_use]
            pub fn bootack(&mut self) -> BOOTACK_W<INTERRUPT_SPEC, 13> {
                BOOTACK_W::new(self)
            }
            #[doc = "Bit 14 - Boot operation has terminated"]
            #[inline(always)]
            #[must_use]
            pub fn endboot(&mut self) -> ENDBOOT_W<INTERRUPT_SPEC, 14> {
                ENDBOOT_W::new(self)
            }
            #[doc = "Bit 16 - Command timeout"]
            #[inline(always)]
            #[must_use]
            pub fn cto_err(&mut self) -> CTO_ERR_W<INTERRUPT_SPEC, 16> {
                CTO_ERR_W::new(self)
            }
            #[doc = "Bit 17 - Command CRC error"]
            #[inline(always)]
            #[must_use]
            pub fn ccrc_err(&mut self) -> CCRC_ERR_W<INTERRUPT_SPEC, 17> {
                CCRC_ERR_W::new(self)
            }
            #[doc = "Bit 18 - Command end bit error (not 1)"]
            #[inline(always)]
            #[must_use]
            pub fn cend_err(&mut self) -> CEND_ERR_W<INTERRUPT_SPEC, 18> {
                CEND_ERR_W::new(self)
            }
            #[doc = "Bit 19 - Incorrect response command index"]
            #[inline(always)]
            #[must_use]
            pub fn cbad_err(&mut self) -> CBAD_ERR_W<INTERRUPT_SPEC, 19> {
                CBAD_ERR_W::new(self)
            }
            #[doc = "Bit 20 - Data timeout"]
            #[inline(always)]
            #[must_use]
            pub fn dto_err(&mut self) -> DTO_ERR_W<INTERRUPT_SPEC, 20> {
                DTO_ERR_W::new(self)
            }
            #[doc = "Bit 21 - Data CRC error"]
            #[inline(always)]
            #[must_use]
            pub fn dcrc_err(&mut self) -> DCRC_ERR_W<INTERRUPT_SPEC, 21> {
                DCRC_ERR_W::new(self)
            }
            #[doc = "Bit 22 - Data end bit error (not 1)"]
            #[inline(always)]
            #[must_use]
            pub fn dend_err(&mut self) -> DEND_ERR_W<INTERRUPT_SPEC, 22> {
                DEND_ERR_W::new(self)
            }
            #[doc = "Bit 24 - Auto command error"]
            #[inline(always)]
            #[must_use]
            pub fn acmd_err(&mut self) -> ACMD_ERR_W<INTERRUPT_SPEC, 24> {
                ACMD_ERR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt flags\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`interrupt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`interrupt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INTERRUPT_SPEC;
        impl crate::RegisterSpec for INTERRUPT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`interrupt::R`](R) reader structure"]
        impl crate::Readable for INTERRUPT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`interrupt::W`](W) writer structure"]
        impl crate::Writable for INTERRUPT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets INTERRUPT to value 0"]
        impl crate::Resettable for INTERRUPT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IRPT_MASK (rw) register accessor: Mask interrupts that change in INTERRUPT\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`irpt_mask::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irpt_mask::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irpt_mask`]
module"]
    pub type IRPT_MASK = crate::Reg<irpt_mask::IRPT_MASK_SPEC>;
    #[doc = "Mask interrupts that change in INTERRUPT"]
    pub mod irpt_mask {
        #[doc = "Register `IRPT_MASK` reader"]
        pub type R = crate::R<IRPT_MASK_SPEC>;
        #[doc = "Register `IRPT_MASK` writer"]
        pub type W = crate::W<IRPT_MASK_SPEC>;
        #[doc = "Field `CMD_DONE` reader - Command has finished"]
        pub type CMD_DONE_R = crate::BitReader;
        #[doc = "Field `CMD_DONE` writer - Command has finished"]
        pub type CMD_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DATA_DONE` reader - Data transfer has finished"]
        pub type DATA_DONE_R = crate::BitReader;
        #[doc = "Field `DATA_DONE` writer - Data transfer has finished"]
        pub type DATA_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BLOCK_GAP` reader - Data transfer has stopped at block gap"]
        pub type BLOCK_GAP_R = crate::BitReader;
        #[doc = "Field `BLOCK_GAP` writer - Data transfer has stopped at block gap"]
        pub type BLOCK_GAP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WRITE_RDY` reader - DATA can be written to"]
        pub type WRITE_RDY_R = crate::BitReader;
        #[doc = "Field `WRITE_RDY` writer - DATA can be written to"]
        pub type WRITE_RDY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `READ_RDY` reader - DATA contains data to be read"]
        pub type READ_RDY_R = crate::BitReader;
        #[doc = "Field `READ_RDY` writer - DATA contains data to be read"]
        pub type READ_RDY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CARD` reader - Card made interrupt request"]
        pub type CARD_R = crate::BitReader;
        #[doc = "Field `CARD` writer - Card made interrupt request"]
        pub type CARD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RETUNE` reader - Clock retune request"]
        pub type RETUNE_R = crate::BitReader;
        #[doc = "Field `RETUNE` writer - Clock retune request"]
        pub type RETUNE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BOOTACK` reader - Boot has been acknowledged"]
        pub type BOOTACK_R = crate::BitReader;
        #[doc = "Field `BOOTACK` writer - Boot has been acknowledged"]
        pub type BOOTACK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENDBOOT` reader - Boot operation has terminated"]
        pub type ENDBOOT_R = crate::BitReader;
        #[doc = "Field `ENDBOOT` writer - Boot operation has terminated"]
        pub type ENDBOOT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTO_ERR` reader - Command timeout"]
        pub type CTO_ERR_R = crate::BitReader;
        #[doc = "Field `CTO_ERR` writer - Command timeout"]
        pub type CTO_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CCRC_ERR` reader - Command CRC error"]
        pub type CCRC_ERR_R = crate::BitReader;
        #[doc = "Field `CCRC_ERR` writer - Command CRC error"]
        pub type CCRC_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CEND_ERR` reader - Command end bit error (not 1)"]
        pub type CEND_ERR_R = crate::BitReader;
        #[doc = "Field `CEND_ERR` writer - Command end bit error (not 1)"]
        pub type CEND_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CBAD_ERR` reader - Incorrect response command index"]
        pub type CBAD_ERR_R = crate::BitReader;
        #[doc = "Field `CBAD_ERR` writer - Incorrect response command index"]
        pub type CBAD_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DTO_ERR` reader - Data timeout"]
        pub type DTO_ERR_R = crate::BitReader;
        #[doc = "Field `DTO_ERR` writer - Data timeout"]
        pub type DTO_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DCRC_ERR` reader - Data CRC error"]
        pub type DCRC_ERR_R = crate::BitReader;
        #[doc = "Field `DCRC_ERR` writer - Data CRC error"]
        pub type DCRC_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DEND_ERR` reader - Data end bit error (not 1)"]
        pub type DEND_ERR_R = crate::BitReader;
        #[doc = "Field `DEND_ERR` writer - Data end bit error (not 1)"]
        pub type DEND_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ACMD_ERR` reader - Auto command error"]
        pub type ACMD_ERR_R = crate::BitReader;
        #[doc = "Field `ACMD_ERR` writer - Auto command error"]
        pub type ACMD_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Command has finished"]
            #[inline(always)]
            pub fn cmd_done(&self) -> CMD_DONE_R {
                CMD_DONE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Data transfer has finished"]
            #[inline(always)]
            pub fn data_done(&self) -> DATA_DONE_R {
                DATA_DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Data transfer has stopped at block gap"]
            #[inline(always)]
            pub fn block_gap(&self) -> BLOCK_GAP_R {
                BLOCK_GAP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - DATA can be written to"]
            #[inline(always)]
            pub fn write_rdy(&self) -> WRITE_RDY_R {
                WRITE_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DATA contains data to be read"]
            #[inline(always)]
            pub fn read_rdy(&self) -> READ_RDY_R {
                READ_RDY_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 8 - Card made interrupt request"]
            #[inline(always)]
            pub fn card(&self) -> CARD_R {
                CARD_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 12 - Clock retune request"]
            #[inline(always)]
            pub fn retune(&self) -> RETUNE_R {
                RETUNE_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Boot has been acknowledged"]
            #[inline(always)]
            pub fn bootack(&self) -> BOOTACK_R {
                BOOTACK_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Boot operation has terminated"]
            #[inline(always)]
            pub fn endboot(&self) -> ENDBOOT_R {
                ENDBOOT_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 16 - Command timeout"]
            #[inline(always)]
            pub fn cto_err(&self) -> CTO_ERR_R {
                CTO_ERR_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Command CRC error"]
            #[inline(always)]
            pub fn ccrc_err(&self) -> CCRC_ERR_R {
                CCRC_ERR_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Command end bit error (not 1)"]
            #[inline(always)]
            pub fn cend_err(&self) -> CEND_ERR_R {
                CEND_ERR_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Incorrect response command index"]
            #[inline(always)]
            pub fn cbad_err(&self) -> CBAD_ERR_R {
                CBAD_ERR_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Data timeout"]
            #[inline(always)]
            pub fn dto_err(&self) -> DTO_ERR_R {
                DTO_ERR_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Data CRC error"]
            #[inline(always)]
            pub fn dcrc_err(&self) -> DCRC_ERR_R {
                DCRC_ERR_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Data end bit error (not 1)"]
            #[inline(always)]
            pub fn dend_err(&self) -> DEND_ERR_R {
                DEND_ERR_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 24 - Auto command error"]
            #[inline(always)]
            pub fn acmd_err(&self) -> ACMD_ERR_R {
                ACMD_ERR_R::new(((self.bits >> 24) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IRPT_MASK")
                    .field("acmd_err", &format_args!("{}", self.acmd_err().bit()))
                    .field("dend_err", &format_args!("{}", self.dend_err().bit()))
                    .field("dcrc_err", &format_args!("{}", self.dcrc_err().bit()))
                    .field("dto_err", &format_args!("{}", self.dto_err().bit()))
                    .field("cbad_err", &format_args!("{}", self.cbad_err().bit()))
                    .field("cend_err", &format_args!("{}", self.cend_err().bit()))
                    .field("ccrc_err", &format_args!("{}", self.ccrc_err().bit()))
                    .field("cto_err", &format_args!("{}", self.cto_err().bit()))
                    .field("endboot", &format_args!("{}", self.endboot().bit()))
                    .field("bootack", &format_args!("{}", self.bootack().bit()))
                    .field("retune", &format_args!("{}", self.retune().bit()))
                    .field("card", &format_args!("{}", self.card().bit()))
                    .field("read_rdy", &format_args!("{}", self.read_rdy().bit()))
                    .field("write_rdy", &format_args!("{}", self.write_rdy().bit()))
                    .field("block_gap", &format_args!("{}", self.block_gap().bit()))
                    .field("data_done", &format_args!("{}", self.data_done().bit()))
                    .field("cmd_done", &format_args!("{}", self.cmd_done().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IRPT_MASK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Command has finished"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_done(&mut self) -> CMD_DONE_W<IRPT_MASK_SPEC, 0> {
                CMD_DONE_W::new(self)
            }
            #[doc = "Bit 1 - Data transfer has finished"]
            #[inline(always)]
            #[must_use]
            pub fn data_done(&mut self) -> DATA_DONE_W<IRPT_MASK_SPEC, 1> {
                DATA_DONE_W::new(self)
            }
            #[doc = "Bit 2 - Data transfer has stopped at block gap"]
            #[inline(always)]
            #[must_use]
            pub fn block_gap(&mut self) -> BLOCK_GAP_W<IRPT_MASK_SPEC, 2> {
                BLOCK_GAP_W::new(self)
            }
            #[doc = "Bit 4 - DATA can be written to"]
            #[inline(always)]
            #[must_use]
            pub fn write_rdy(&mut self) -> WRITE_RDY_W<IRPT_MASK_SPEC, 4> {
                WRITE_RDY_W::new(self)
            }
            #[doc = "Bit 5 - DATA contains data to be read"]
            #[inline(always)]
            #[must_use]
            pub fn read_rdy(&mut self) -> READ_RDY_W<IRPT_MASK_SPEC, 5> {
                READ_RDY_W::new(self)
            }
            #[doc = "Bit 8 - Card made interrupt request"]
            #[inline(always)]
            #[must_use]
            pub fn card(&mut self) -> CARD_W<IRPT_MASK_SPEC, 8> {
                CARD_W::new(self)
            }
            #[doc = "Bit 12 - Clock retune request"]
            #[inline(always)]
            #[must_use]
            pub fn retune(&mut self) -> RETUNE_W<IRPT_MASK_SPEC, 12> {
                RETUNE_W::new(self)
            }
            #[doc = "Bit 13 - Boot has been acknowledged"]
            #[inline(always)]
            #[must_use]
            pub fn bootack(&mut self) -> BOOTACK_W<IRPT_MASK_SPEC, 13> {
                BOOTACK_W::new(self)
            }
            #[doc = "Bit 14 - Boot operation has terminated"]
            #[inline(always)]
            #[must_use]
            pub fn endboot(&mut self) -> ENDBOOT_W<IRPT_MASK_SPEC, 14> {
                ENDBOOT_W::new(self)
            }
            #[doc = "Bit 16 - Command timeout"]
            #[inline(always)]
            #[must_use]
            pub fn cto_err(&mut self) -> CTO_ERR_W<IRPT_MASK_SPEC, 16> {
                CTO_ERR_W::new(self)
            }
            #[doc = "Bit 17 - Command CRC error"]
            #[inline(always)]
            #[must_use]
            pub fn ccrc_err(&mut self) -> CCRC_ERR_W<IRPT_MASK_SPEC, 17> {
                CCRC_ERR_W::new(self)
            }
            #[doc = "Bit 18 - Command end bit error (not 1)"]
            #[inline(always)]
            #[must_use]
            pub fn cend_err(&mut self) -> CEND_ERR_W<IRPT_MASK_SPEC, 18> {
                CEND_ERR_W::new(self)
            }
            #[doc = "Bit 19 - Incorrect response command index"]
            #[inline(always)]
            #[must_use]
            pub fn cbad_err(&mut self) -> CBAD_ERR_W<IRPT_MASK_SPEC, 19> {
                CBAD_ERR_W::new(self)
            }
            #[doc = "Bit 20 - Data timeout"]
            #[inline(always)]
            #[must_use]
            pub fn dto_err(&mut self) -> DTO_ERR_W<IRPT_MASK_SPEC, 20> {
                DTO_ERR_W::new(self)
            }
            #[doc = "Bit 21 - Data CRC error"]
            #[inline(always)]
            #[must_use]
            pub fn dcrc_err(&mut self) -> DCRC_ERR_W<IRPT_MASK_SPEC, 21> {
                DCRC_ERR_W::new(self)
            }
            #[doc = "Bit 22 - Data end bit error (not 1)"]
            #[inline(always)]
            #[must_use]
            pub fn dend_err(&mut self) -> DEND_ERR_W<IRPT_MASK_SPEC, 22> {
                DEND_ERR_W::new(self)
            }
            #[doc = "Bit 24 - Auto command error"]
            #[inline(always)]
            #[must_use]
            pub fn acmd_err(&mut self) -> ACMD_ERR_W<IRPT_MASK_SPEC, 24> {
                ACMD_ERR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Mask interrupts that change in INTERRUPT\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`irpt_mask::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irpt_mask::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IRPT_MASK_SPEC;
        impl crate::RegisterSpec for IRPT_MASK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`irpt_mask::R`](R) reader structure"]
        impl crate::Readable for IRPT_MASK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`irpt_mask::W`](W) writer structure"]
        impl crate::Writable for IRPT_MASK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IRPT_MASK to value 0"]
        impl crate::Resettable for IRPT_MASK_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "IRPT_EN (rw) register accessor: Enable interrupt to core\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`irpt_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irpt_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irpt_en`]
module"]
    pub type IRPT_EN = crate::Reg<irpt_en::IRPT_EN_SPEC>;
    #[doc = "Enable interrupt to core"]
    pub mod irpt_en {
        #[doc = "Register `IRPT_EN` reader"]
        pub type R = crate::R<IRPT_EN_SPEC>;
        #[doc = "Register `IRPT_EN` writer"]
        pub type W = crate::W<IRPT_EN_SPEC>;
        #[doc = "Field `CMD_DONE` reader - Command has finished"]
        pub type CMD_DONE_R = crate::BitReader;
        #[doc = "Field `CMD_DONE` writer - Command has finished"]
        pub type CMD_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DATA_DONE` reader - Data transfer has finished"]
        pub type DATA_DONE_R = crate::BitReader;
        #[doc = "Field `DATA_DONE` writer - Data transfer has finished"]
        pub type DATA_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BLOCK_GAP` reader - Data transfer has stopped at block gap"]
        pub type BLOCK_GAP_R = crate::BitReader;
        #[doc = "Field `BLOCK_GAP` writer - Data transfer has stopped at block gap"]
        pub type BLOCK_GAP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WRITE_RDY` reader - DATA can be written to"]
        pub type WRITE_RDY_R = crate::BitReader;
        #[doc = "Field `WRITE_RDY` writer - DATA can be written to"]
        pub type WRITE_RDY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `READ_RDY` reader - DATA contains data to be read"]
        pub type READ_RDY_R = crate::BitReader;
        #[doc = "Field `READ_RDY` writer - DATA contains data to be read"]
        pub type READ_RDY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CARD` reader - Card made interrupt request"]
        pub type CARD_R = crate::BitReader;
        #[doc = "Field `CARD` writer - Card made interrupt request"]
        pub type CARD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RETUNE` reader - Clock retune request"]
        pub type RETUNE_R = crate::BitReader;
        #[doc = "Field `RETUNE` writer - Clock retune request"]
        pub type RETUNE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BOOTACK` reader - Boot has been acknowledged"]
        pub type BOOTACK_R = crate::BitReader;
        #[doc = "Field `BOOTACK` writer - Boot has been acknowledged"]
        pub type BOOTACK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENDBOOT` reader - Boot operation has terminated"]
        pub type ENDBOOT_R = crate::BitReader;
        #[doc = "Field `ENDBOOT` writer - Boot operation has terminated"]
        pub type ENDBOOT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTO_ERR` reader - Command timeout"]
        pub type CTO_ERR_R = crate::BitReader;
        #[doc = "Field `CTO_ERR` writer - Command timeout"]
        pub type CTO_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CCRC_ERR` reader - Command CRC error"]
        pub type CCRC_ERR_R = crate::BitReader;
        #[doc = "Field `CCRC_ERR` writer - Command CRC error"]
        pub type CCRC_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CEND_ERR` reader - Command end bit error (not 1)"]
        pub type CEND_ERR_R = crate::BitReader;
        #[doc = "Field `CEND_ERR` writer - Command end bit error (not 1)"]
        pub type CEND_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CBAD_ERR` reader - Incorrect response command index"]
        pub type CBAD_ERR_R = crate::BitReader;
        #[doc = "Field `CBAD_ERR` writer - Incorrect response command index"]
        pub type CBAD_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DTO_ERR` reader - Data timeout"]
        pub type DTO_ERR_R = crate::BitReader;
        #[doc = "Field `DTO_ERR` writer - Data timeout"]
        pub type DTO_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DCRC_ERR` reader - Data CRC error"]
        pub type DCRC_ERR_R = crate::BitReader;
        #[doc = "Field `DCRC_ERR` writer - Data CRC error"]
        pub type DCRC_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DEND_ERR` reader - Data end bit error (not 1)"]
        pub type DEND_ERR_R = crate::BitReader;
        #[doc = "Field `DEND_ERR` writer - Data end bit error (not 1)"]
        pub type DEND_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ACMD_ERR` reader - Auto command error"]
        pub type ACMD_ERR_R = crate::BitReader;
        #[doc = "Field `ACMD_ERR` writer - Auto command error"]
        pub type ACMD_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Command has finished"]
            #[inline(always)]
            pub fn cmd_done(&self) -> CMD_DONE_R {
                CMD_DONE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Data transfer has finished"]
            #[inline(always)]
            pub fn data_done(&self) -> DATA_DONE_R {
                DATA_DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Data transfer has stopped at block gap"]
            #[inline(always)]
            pub fn block_gap(&self) -> BLOCK_GAP_R {
                BLOCK_GAP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - DATA can be written to"]
            #[inline(always)]
            pub fn write_rdy(&self) -> WRITE_RDY_R {
                WRITE_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DATA contains data to be read"]
            #[inline(always)]
            pub fn read_rdy(&self) -> READ_RDY_R {
                READ_RDY_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 8 - Card made interrupt request"]
            #[inline(always)]
            pub fn card(&self) -> CARD_R {
                CARD_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 12 - Clock retune request"]
            #[inline(always)]
            pub fn retune(&self) -> RETUNE_R {
                RETUNE_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Boot has been acknowledged"]
            #[inline(always)]
            pub fn bootack(&self) -> BOOTACK_R {
                BOOTACK_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Boot operation has terminated"]
            #[inline(always)]
            pub fn endboot(&self) -> ENDBOOT_R {
                ENDBOOT_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 16 - Command timeout"]
            #[inline(always)]
            pub fn cto_err(&self) -> CTO_ERR_R {
                CTO_ERR_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Command CRC error"]
            #[inline(always)]
            pub fn ccrc_err(&self) -> CCRC_ERR_R {
                CCRC_ERR_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Command end bit error (not 1)"]
            #[inline(always)]
            pub fn cend_err(&self) -> CEND_ERR_R {
                CEND_ERR_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Incorrect response command index"]
            #[inline(always)]
            pub fn cbad_err(&self) -> CBAD_ERR_R {
                CBAD_ERR_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Data timeout"]
            #[inline(always)]
            pub fn dto_err(&self) -> DTO_ERR_R {
                DTO_ERR_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Data CRC error"]
            #[inline(always)]
            pub fn dcrc_err(&self) -> DCRC_ERR_R {
                DCRC_ERR_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Data end bit error (not 1)"]
            #[inline(always)]
            pub fn dend_err(&self) -> DEND_ERR_R {
                DEND_ERR_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 24 - Auto command error"]
            #[inline(always)]
            pub fn acmd_err(&self) -> ACMD_ERR_R {
                ACMD_ERR_R::new(((self.bits >> 24) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IRPT_EN")
                    .field("acmd_err", &format_args!("{}", self.acmd_err().bit()))
                    .field("dend_err", &format_args!("{}", self.dend_err().bit()))
                    .field("dcrc_err", &format_args!("{}", self.dcrc_err().bit()))
                    .field("dto_err", &format_args!("{}", self.dto_err().bit()))
                    .field("cbad_err", &format_args!("{}", self.cbad_err().bit()))
                    .field("cend_err", &format_args!("{}", self.cend_err().bit()))
                    .field("ccrc_err", &format_args!("{}", self.ccrc_err().bit()))
                    .field("cto_err", &format_args!("{}", self.cto_err().bit()))
                    .field("endboot", &format_args!("{}", self.endboot().bit()))
                    .field("bootack", &format_args!("{}", self.bootack().bit()))
                    .field("retune", &format_args!("{}", self.retune().bit()))
                    .field("card", &format_args!("{}", self.card().bit()))
                    .field("read_rdy", &format_args!("{}", self.read_rdy().bit()))
                    .field("write_rdy", &format_args!("{}", self.write_rdy().bit()))
                    .field("block_gap", &format_args!("{}", self.block_gap().bit()))
                    .field("data_done", &format_args!("{}", self.data_done().bit()))
                    .field("cmd_done", &format_args!("{}", self.cmd_done().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IRPT_EN_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Command has finished"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_done(&mut self) -> CMD_DONE_W<IRPT_EN_SPEC, 0> {
                CMD_DONE_W::new(self)
            }
            #[doc = "Bit 1 - Data transfer has finished"]
            #[inline(always)]
            #[must_use]
            pub fn data_done(&mut self) -> DATA_DONE_W<IRPT_EN_SPEC, 1> {
                DATA_DONE_W::new(self)
            }
            #[doc = "Bit 2 - Data transfer has stopped at block gap"]
            #[inline(always)]
            #[must_use]
            pub fn block_gap(&mut self) -> BLOCK_GAP_W<IRPT_EN_SPEC, 2> {
                BLOCK_GAP_W::new(self)
            }
            #[doc = "Bit 4 - DATA can be written to"]
            #[inline(always)]
            #[must_use]
            pub fn write_rdy(&mut self) -> WRITE_RDY_W<IRPT_EN_SPEC, 4> {
                WRITE_RDY_W::new(self)
            }
            #[doc = "Bit 5 - DATA contains data to be read"]
            #[inline(always)]
            #[must_use]
            pub fn read_rdy(&mut self) -> READ_RDY_W<IRPT_EN_SPEC, 5> {
                READ_RDY_W::new(self)
            }
            #[doc = "Bit 8 - Card made interrupt request"]
            #[inline(always)]
            #[must_use]
            pub fn card(&mut self) -> CARD_W<IRPT_EN_SPEC, 8> {
                CARD_W::new(self)
            }
            #[doc = "Bit 12 - Clock retune request"]
            #[inline(always)]
            #[must_use]
            pub fn retune(&mut self) -> RETUNE_W<IRPT_EN_SPEC, 12> {
                RETUNE_W::new(self)
            }
            #[doc = "Bit 13 - Boot has been acknowledged"]
            #[inline(always)]
            #[must_use]
            pub fn bootack(&mut self) -> BOOTACK_W<IRPT_EN_SPEC, 13> {
                BOOTACK_W::new(self)
            }
            #[doc = "Bit 14 - Boot operation has terminated"]
            #[inline(always)]
            #[must_use]
            pub fn endboot(&mut self) -> ENDBOOT_W<IRPT_EN_SPEC, 14> {
                ENDBOOT_W::new(self)
            }
            #[doc = "Bit 16 - Command timeout"]
            #[inline(always)]
            #[must_use]
            pub fn cto_err(&mut self) -> CTO_ERR_W<IRPT_EN_SPEC, 16> {
                CTO_ERR_W::new(self)
            }
            #[doc = "Bit 17 - Command CRC error"]
            #[inline(always)]
            #[must_use]
            pub fn ccrc_err(&mut self) -> CCRC_ERR_W<IRPT_EN_SPEC, 17> {
                CCRC_ERR_W::new(self)
            }
            #[doc = "Bit 18 - Command end bit error (not 1)"]
            #[inline(always)]
            #[must_use]
            pub fn cend_err(&mut self) -> CEND_ERR_W<IRPT_EN_SPEC, 18> {
                CEND_ERR_W::new(self)
            }
            #[doc = "Bit 19 - Incorrect response command index"]
            #[inline(always)]
            #[must_use]
            pub fn cbad_err(&mut self) -> CBAD_ERR_W<IRPT_EN_SPEC, 19> {
                CBAD_ERR_W::new(self)
            }
            #[doc = "Bit 20 - Data timeout"]
            #[inline(always)]
            #[must_use]
            pub fn dto_err(&mut self) -> DTO_ERR_W<IRPT_EN_SPEC, 20> {
                DTO_ERR_W::new(self)
            }
            #[doc = "Bit 21 - Data CRC error"]
            #[inline(always)]
            #[must_use]
            pub fn dcrc_err(&mut self) -> DCRC_ERR_W<IRPT_EN_SPEC, 21> {
                DCRC_ERR_W::new(self)
            }
            #[doc = "Bit 22 - Data end bit error (not 1)"]
            #[inline(always)]
            #[must_use]
            pub fn dend_err(&mut self) -> DEND_ERR_W<IRPT_EN_SPEC, 22> {
                DEND_ERR_W::new(self)
            }
            #[doc = "Bit 24 - Auto command error"]
            #[inline(always)]
            #[must_use]
            pub fn acmd_err(&mut self) -> ACMD_ERR_W<IRPT_EN_SPEC, 24> {
                ACMD_ERR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Enable interrupt to core\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`irpt_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irpt_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IRPT_EN_SPEC;
        impl crate::RegisterSpec for IRPT_EN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`irpt_en::R`](R) reader structure"]
        impl crate::Readable for IRPT_EN_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`irpt_en::W`](W) writer structure"]
        impl crate::Writable for IRPT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets IRPT_EN to value 0"]
        impl crate::Resettable for IRPT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "CONTROL2 (rw) register accessor: Control 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`control2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control2`]
module"]
    pub type CONTROL2 = crate::Reg<control2::CONTROL2_SPEC>;
    #[doc = "Control 2"]
    pub mod control2 {
        #[doc = "Register `CONTROL2` reader"]
        pub type R = crate::R<CONTROL2_SPEC>;
        #[doc = "Register `CONTROL2` writer"]
        pub type W = crate::W<CONTROL2_SPEC>;
        #[doc = "Field `ACNOX_ERR` reader - Auto command not executed due to an error"]
        pub type ACNOX_ERR_R = crate::BitReader;
        #[doc = "Field `ACTO_ERR` reader - Auto command timeout"]
        pub type ACTO_ERR_R = crate::BitReader;
        #[doc = "Field `ACCRC_ERR` reader - Command CRC error during auto command"]
        pub type ACCRC_ERR_R = crate::BitReader;
        #[doc = "Field `ACEND_ERR` reader - End bit is not 1 during auto command"]
        pub type ACEND_ERR_R = crate::BitReader;
        #[doc = "Field `ACBAD_ERR` reader - Command index error during auto command"]
        pub type ACBAD_ERR_R = crate::BitReader;
        #[doc = "Field `NOTC12_ERR` reader - Error during auto CMD12"]
        pub type NOTC12_ERR_R = crate::BitReader;
        #[doc = "Field `UHSMODE` reader - Select the speed of the SD card"]
        pub type UHSMODE_R = crate::FieldReader<UHSMODE_A>;
        #[doc = "Select the speed of the SD card\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum UHSMODE_A {
            #[doc = "0: `0`"]
            SDR12 = 0,
            #[doc = "1: `1`"]
            SDR25 = 1,
            #[doc = "2: `10`"]
            SDR50 = 2,
            #[doc = "3: `11`"]
            SDR104 = 3,
            #[doc = "4: `100`"]
            DDR50 = 4,
        }
        impl From<UHSMODE_A> for u8 {
            #[inline(always)]
            fn from(variant: UHSMODE_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for UHSMODE_A {
            type Ux = u8;
        }
        impl UHSMODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<UHSMODE_A> {
                match self.bits {
                    0 => Some(UHSMODE_A::SDR12),
                    1 => Some(UHSMODE_A::SDR25),
                    2 => Some(UHSMODE_A::SDR50),
                    3 => Some(UHSMODE_A::SDR104),
                    4 => Some(UHSMODE_A::DDR50),
                    _ => None,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_sdr12(&self) -> bool {
                *self == UHSMODE_A::SDR12
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_sdr25(&self) -> bool {
                *self == UHSMODE_A::SDR25
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn is_sdr50(&self) -> bool {
                *self == UHSMODE_A::SDR50
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn is_sdr104(&self) -> bool {
                *self == UHSMODE_A::SDR104
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn is_ddr50(&self) -> bool {
                *self == UHSMODE_A::DDR50
            }
        }
        #[doc = "Field `UHSMODE` writer - Select the speed of the SD card"]
        pub type UHSMODE_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O, UHSMODE_A>;
        impl<'a, REG, const O: u8> UHSMODE_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn sdr12(self) -> &'a mut crate::W<REG> {
                self.variant(UHSMODE_A::SDR12)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn sdr25(self) -> &'a mut crate::W<REG> {
                self.variant(UHSMODE_A::SDR25)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn sdr50(self) -> &'a mut crate::W<REG> {
                self.variant(UHSMODE_A::SDR50)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn sdr104(self) -> &'a mut crate::W<REG> {
                self.variant(UHSMODE_A::SDR104)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn ddr50(self) -> &'a mut crate::W<REG> {
                self.variant(UHSMODE_A::DDR50)
            }
        }
        #[doc = "Field `TUNEON` reader - SD Clock tune in progress"]
        pub type TUNEON_R = crate::BitReader;
        #[doc = "Field `TUNEON` writer - SD Clock tune in progress"]
        pub type TUNEON_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `TUNED` reader - Tuned clock is used for sampling data"]
        pub type TUNED_R = crate::BitReader;
        #[doc = "Field `TUNED` writer - Tuned clock is used for sampling data"]
        pub type TUNED_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Auto command not executed due to an error"]
            #[inline(always)]
            pub fn acnox_err(&self) -> ACNOX_ERR_R {
                ACNOX_ERR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Auto command timeout"]
            #[inline(always)]
            pub fn acto_err(&self) -> ACTO_ERR_R {
                ACTO_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Command CRC error during auto command"]
            #[inline(always)]
            pub fn accrc_err(&self) -> ACCRC_ERR_R {
                ACCRC_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - End bit is not 1 during auto command"]
            #[inline(always)]
            pub fn acend_err(&self) -> ACEND_ERR_R {
                ACEND_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Command index error during auto command"]
            #[inline(always)]
            pub fn acbad_err(&self) -> ACBAD_ERR_R {
                ACBAD_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 7 - Error during auto CMD12"]
            #[inline(always)]
            pub fn notc12_err(&self) -> NOTC12_ERR_R {
                NOTC12_ERR_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 16:18 - Select the speed of the SD card"]
            #[inline(always)]
            pub fn uhsmode(&self) -> UHSMODE_R {
                UHSMODE_R::new(((self.bits >> 16) & 7) as u8)
            }
            #[doc = "Bit 22 - SD Clock tune in progress"]
            #[inline(always)]
            pub fn tuneon(&self) -> TUNEON_R {
                TUNEON_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Tuned clock is used for sampling data"]
            #[inline(always)]
            pub fn tuned(&self) -> TUNED_R {
                TUNED_R::new(((self.bits >> 23) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CONTROL2")
                    .field("tuned", &format_args!("{}", self.tuned().bit()))
                    .field("tuneon", &format_args!("{}", self.tuneon().bit()))
                    .field("uhsmode", &format_args!("{}", self.uhsmode().bits()))
                    .field("notc12_err", &format_args!("{}", self.notc12_err().bit()))
                    .field("acbad_err", &format_args!("{}", self.acbad_err().bit()))
                    .field("acend_err", &format_args!("{}", self.acend_err().bit()))
                    .field("accrc_err", &format_args!("{}", self.accrc_err().bit()))
                    .field("acto_err", &format_args!("{}", self.acto_err().bit()))
                    .field("acnox_err", &format_args!("{}", self.acnox_err().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CONTROL2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 16:18 - Select the speed of the SD card"]
            #[inline(always)]
            #[must_use]
            pub fn uhsmode(&mut self) -> UHSMODE_W<CONTROL2_SPEC, 16> {
                UHSMODE_W::new(self)
            }
            #[doc = "Bit 22 - SD Clock tune in progress"]
            #[inline(always)]
            #[must_use]
            pub fn tuneon(&mut self) -> TUNEON_W<CONTROL2_SPEC, 22> {
                TUNEON_W::new(self)
            }
            #[doc = "Bit 23 - Tuned clock is used for sampling data"]
            #[inline(always)]
            #[must_use]
            pub fn tuned(&mut self) -> TUNED_W<CONTROL2_SPEC, 23> {
                TUNED_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`control2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CONTROL2_SPEC;
        impl crate::RegisterSpec for CONTROL2_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`control2::R`](R) reader structure"]
        impl crate::Readable for CONTROL2_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`control2::W`](W) writer structure"]
        impl crate::Writable for CONTROL2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets CONTROL2 to value 0"]
        impl crate::Resettable for CONTROL2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "FORCE_IRPT (rw) register accessor: Force an interrupt\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`force_irpt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`force_irpt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@force_irpt`]
module"]
    pub type FORCE_IRPT = crate::Reg<force_irpt::FORCE_IRPT_SPEC>;
    #[doc = "Force an interrupt"]
    pub mod force_irpt {
        #[doc = "Register `FORCE_IRPT` reader"]
        pub type R = crate::R<FORCE_IRPT_SPEC>;
        #[doc = "Register `FORCE_IRPT` writer"]
        pub type W = crate::W<FORCE_IRPT_SPEC>;
        #[doc = "Field `CMD_DONE` reader - Command has finished"]
        pub type CMD_DONE_R = crate::BitReader;
        #[doc = "Field `CMD_DONE` writer - Command has finished"]
        pub type CMD_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DATA_DONE` reader - Data transfer has finished"]
        pub type DATA_DONE_R = crate::BitReader;
        #[doc = "Field `DATA_DONE` writer - Data transfer has finished"]
        pub type DATA_DONE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BLOCK_GAP` reader - Data transfer has stopped at block gap"]
        pub type BLOCK_GAP_R = crate::BitReader;
        #[doc = "Field `BLOCK_GAP` writer - Data transfer has stopped at block gap"]
        pub type BLOCK_GAP_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `WRITE_RDY` reader - DATA can be written to"]
        pub type WRITE_RDY_R = crate::BitReader;
        #[doc = "Field `WRITE_RDY` writer - DATA can be written to"]
        pub type WRITE_RDY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `READ_RDY` reader - DATA contains data to be read"]
        pub type READ_RDY_R = crate::BitReader;
        #[doc = "Field `READ_RDY` writer - DATA contains data to be read"]
        pub type READ_RDY_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CARD` reader - Card made interrupt request"]
        pub type CARD_R = crate::BitReader;
        #[doc = "Field `CARD` writer - Card made interrupt request"]
        pub type CARD_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `RETUNE` reader - Clock retune request"]
        pub type RETUNE_R = crate::BitReader;
        #[doc = "Field `RETUNE` writer - Clock retune request"]
        pub type RETUNE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `BOOTACK` reader - Boot has been acknowledged"]
        pub type BOOTACK_R = crate::BitReader;
        #[doc = "Field `BOOTACK` writer - Boot has been acknowledged"]
        pub type BOOTACK_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ENDBOOT` reader - Boot operation has terminated"]
        pub type ENDBOOT_R = crate::BitReader;
        #[doc = "Field `ENDBOOT` writer - Boot operation has terminated"]
        pub type ENDBOOT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CTO_ERR` reader - Command timeout"]
        pub type CTO_ERR_R = crate::BitReader;
        #[doc = "Field `CTO_ERR` writer - Command timeout"]
        pub type CTO_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CCRC_ERR` reader - Command CRC error"]
        pub type CCRC_ERR_R = crate::BitReader;
        #[doc = "Field `CCRC_ERR` writer - Command CRC error"]
        pub type CCRC_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CEND_ERR` reader - Command end bit error (not 1)"]
        pub type CEND_ERR_R = crate::BitReader;
        #[doc = "Field `CEND_ERR` writer - Command end bit error (not 1)"]
        pub type CEND_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `CBAD_ERR` reader - Incorrect response command index"]
        pub type CBAD_ERR_R = crate::BitReader;
        #[doc = "Field `CBAD_ERR` writer - Incorrect response command index"]
        pub type CBAD_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DTO_ERR` reader - Data timeout"]
        pub type DTO_ERR_R = crate::BitReader;
        #[doc = "Field `DTO_ERR` writer - Data timeout"]
        pub type DTO_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DCRC_ERR` reader - Data CRC error"]
        pub type DCRC_ERR_R = crate::BitReader;
        #[doc = "Field `DCRC_ERR` writer - Data CRC error"]
        pub type DCRC_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `DEND_ERR` reader - Data end bit error (not 1)"]
        pub type DEND_ERR_R = crate::BitReader;
        #[doc = "Field `DEND_ERR` writer - Data end bit error (not 1)"]
        pub type DEND_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        #[doc = "Field `ACMD_ERR` reader - Auto command error"]
        pub type ACMD_ERR_R = crate::BitReader;
        #[doc = "Field `ACMD_ERR` writer - Auto command error"]
        pub type ACMD_ERR_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Command has finished"]
            #[inline(always)]
            pub fn cmd_done(&self) -> CMD_DONE_R {
                CMD_DONE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Data transfer has finished"]
            #[inline(always)]
            pub fn data_done(&self) -> DATA_DONE_R {
                DATA_DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Data transfer has stopped at block gap"]
            #[inline(always)]
            pub fn block_gap(&self) -> BLOCK_GAP_R {
                BLOCK_GAP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - DATA can be written to"]
            #[inline(always)]
            pub fn write_rdy(&self) -> WRITE_RDY_R {
                WRITE_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DATA contains data to be read"]
            #[inline(always)]
            pub fn read_rdy(&self) -> READ_RDY_R {
                READ_RDY_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 8 - Card made interrupt request"]
            #[inline(always)]
            pub fn card(&self) -> CARD_R {
                CARD_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 12 - Clock retune request"]
            #[inline(always)]
            pub fn retune(&self) -> RETUNE_R {
                RETUNE_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Boot has been acknowledged"]
            #[inline(always)]
            pub fn bootack(&self) -> BOOTACK_R {
                BOOTACK_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Boot operation has terminated"]
            #[inline(always)]
            pub fn endboot(&self) -> ENDBOOT_R {
                ENDBOOT_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 16 - Command timeout"]
            #[inline(always)]
            pub fn cto_err(&self) -> CTO_ERR_R {
                CTO_ERR_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Command CRC error"]
            #[inline(always)]
            pub fn ccrc_err(&self) -> CCRC_ERR_R {
                CCRC_ERR_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Command end bit error (not 1)"]
            #[inline(always)]
            pub fn cend_err(&self) -> CEND_ERR_R {
                CEND_ERR_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Incorrect response command index"]
            #[inline(always)]
            pub fn cbad_err(&self) -> CBAD_ERR_R {
                CBAD_ERR_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Data timeout"]
            #[inline(always)]
            pub fn dto_err(&self) -> DTO_ERR_R {
                DTO_ERR_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Data CRC error"]
            #[inline(always)]
            pub fn dcrc_err(&self) -> DCRC_ERR_R {
                DCRC_ERR_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Data end bit error (not 1)"]
            #[inline(always)]
            pub fn dend_err(&self) -> DEND_ERR_R {
                DEND_ERR_R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 24 - Auto command error"]
            #[inline(always)]
            pub fn acmd_err(&self) -> ACMD_ERR_R {
                ACMD_ERR_R::new(((self.bits >> 24) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FORCE_IRPT")
                    .field("acmd_err", &format_args!("{}", self.acmd_err().bit()))
                    .field("dend_err", &format_args!("{}", self.dend_err().bit()))
                    .field("dcrc_err", &format_args!("{}", self.dcrc_err().bit()))
                    .field("dto_err", &format_args!("{}", self.dto_err().bit()))
                    .field("cbad_err", &format_args!("{}", self.cbad_err().bit()))
                    .field("cend_err", &format_args!("{}", self.cend_err().bit()))
                    .field("ccrc_err", &format_args!("{}", self.ccrc_err().bit()))
                    .field("cto_err", &format_args!("{}", self.cto_err().bit()))
                    .field("endboot", &format_args!("{}", self.endboot().bit()))
                    .field("bootack", &format_args!("{}", self.bootack().bit()))
                    .field("retune", &format_args!("{}", self.retune().bit()))
                    .field("card", &format_args!("{}", self.card().bit()))
                    .field("read_rdy", &format_args!("{}", self.read_rdy().bit()))
                    .field("write_rdy", &format_args!("{}", self.write_rdy().bit()))
                    .field("block_gap", &format_args!("{}", self.block_gap().bit()))
                    .field("data_done", &format_args!("{}", self.data_done().bit()))
                    .field("cmd_done", &format_args!("{}", self.cmd_done().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FORCE_IRPT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Command has finished"]
            #[inline(always)]
            #[must_use]
            pub fn cmd_done(&mut self) -> CMD_DONE_W<FORCE_IRPT_SPEC, 0> {
                CMD_DONE_W::new(self)
            }
            #[doc = "Bit 1 - Data transfer has finished"]
            #[inline(always)]
            #[must_use]
            pub fn data_done(&mut self) -> DATA_DONE_W<FORCE_IRPT_SPEC, 1> {
                DATA_DONE_W::new(self)
            }
            #[doc = "Bit 2 - Data transfer has stopped at block gap"]
            #[inline(always)]
            #[must_use]
            pub fn block_gap(&mut self) -> BLOCK_GAP_W<FORCE_IRPT_SPEC, 2> {
                BLOCK_GAP_W::new(self)
            }
            #[doc = "Bit 4 - DATA can be written to"]
            #[inline(always)]
            #[must_use]
            pub fn write_rdy(&mut self) -> WRITE_RDY_W<FORCE_IRPT_SPEC, 4> {
                WRITE_RDY_W::new(self)
            }
            #[doc = "Bit 5 - DATA contains data to be read"]
            #[inline(always)]
            #[must_use]
            pub fn read_rdy(&mut self) -> READ_RDY_W<FORCE_IRPT_SPEC, 5> {
                READ_RDY_W::new(self)
            }
            #[doc = "Bit 8 - Card made interrupt request"]
            #[inline(always)]
            #[must_use]
            pub fn card(&mut self) -> CARD_W<FORCE_IRPT_SPEC, 8> {
                CARD_W::new(self)
            }
            #[doc = "Bit 12 - Clock retune request"]
            #[inline(always)]
            #[must_use]
            pub fn retune(&mut self) -> RETUNE_W<FORCE_IRPT_SPEC, 12> {
                RETUNE_W::new(self)
            }
            #[doc = "Bit 13 - Boot has been acknowledged"]
            #[inline(always)]
            #[must_use]
            pub fn bootack(&mut self) -> BOOTACK_W<FORCE_IRPT_SPEC, 13> {
                BOOTACK_W::new(self)
            }
            #[doc = "Bit 14 - Boot operation has terminated"]
            #[inline(always)]
            #[must_use]
            pub fn endboot(&mut self) -> ENDBOOT_W<FORCE_IRPT_SPEC, 14> {
                ENDBOOT_W::new(self)
            }
            #[doc = "Bit 16 - Command timeout"]
            #[inline(always)]
            #[must_use]
            pub fn cto_err(&mut self) -> CTO_ERR_W<FORCE_IRPT_SPEC, 16> {
                CTO_ERR_W::new(self)
            }
            #[doc = "Bit 17 - Command CRC error"]
            #[inline(always)]
            #[must_use]
            pub fn ccrc_err(&mut self) -> CCRC_ERR_W<FORCE_IRPT_SPEC, 17> {
                CCRC_ERR_W::new(self)
            }
            #[doc = "Bit 18 - Command end bit error (not 1)"]
            #[inline(always)]
            #[must_use]
            pub fn cend_err(&mut self) -> CEND_ERR_W<FORCE_IRPT_SPEC, 18> {
                CEND_ERR_W::new(self)
            }
            #[doc = "Bit 19 - Incorrect response command index"]
            #[inline(always)]
            #[must_use]
            pub fn cbad_err(&mut self) -> CBAD_ERR_W<FORCE_IRPT_SPEC, 19> {
                CBAD_ERR_W::new(self)
            }
            #[doc = "Bit 20 - Data timeout"]
            #[inline(always)]
            #[must_use]
            pub fn dto_err(&mut self) -> DTO_ERR_W<FORCE_IRPT_SPEC, 20> {
                DTO_ERR_W::new(self)
            }
            #[doc = "Bit 21 - Data CRC error"]
            #[inline(always)]
            #[must_use]
            pub fn dcrc_err(&mut self) -> DCRC_ERR_W<FORCE_IRPT_SPEC, 21> {
                DCRC_ERR_W::new(self)
            }
            #[doc = "Bit 22 - Data end bit error (not 1)"]
            #[inline(always)]
            #[must_use]
            pub fn dend_err(&mut self) -> DEND_ERR_W<FORCE_IRPT_SPEC, 22> {
                DEND_ERR_W::new(self)
            }
            #[doc = "Bit 24 - Auto command error"]
            #[inline(always)]
            #[must_use]
            pub fn acmd_err(&mut self) -> ACMD_ERR_W<FORCE_IRPT_SPEC, 24> {
                ACMD_ERR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Force an interrupt\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`force_irpt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`force_irpt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FORCE_IRPT_SPEC;
        impl crate::RegisterSpec for FORCE_IRPT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`force_irpt::R`](R) reader structure"]
        impl crate::Readable for FORCE_IRPT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`force_irpt::W`](W) writer structure"]
        impl crate::Writable for FORCE_IRPT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets FORCE_IRPT to value 0"]
        impl crate::Resettable for FORCE_IRPT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "BOOT_TIMEOUT (rw) register accessor: Number of SD clock cycles to wait for boot\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`boot_timeout::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`boot_timeout::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@boot_timeout`]
module"]
    pub type BOOT_TIMEOUT = crate::Reg<boot_timeout::BOOT_TIMEOUT_SPEC>;
    #[doc = "Number of SD clock cycles to wait for boot"]
    pub mod boot_timeout {
        #[doc = "Register `BOOT_TIMEOUT` reader"]
        pub type R = crate::R<BOOT_TIMEOUT_SPEC>;
        #[doc = "Register `BOOT_TIMEOUT` writer"]
        pub type W = crate::W<BOOT_TIMEOUT_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<BOOT_TIMEOUT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Number of SD clock cycles to wait for boot\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`boot_timeout::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`boot_timeout::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BOOT_TIMEOUT_SPEC;
        impl crate::RegisterSpec for BOOT_TIMEOUT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`boot_timeout::R`](R) reader structure"]
        impl crate::Readable for BOOT_TIMEOUT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`boot_timeout::W`](W) writer structure"]
        impl crate::Writable for BOOT_TIMEOUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets BOOT_TIMEOUT to value 0"]
        impl crate::Resettable for BOOT_TIMEOUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "DBG_SEL (rw) register accessor: What submodules are accessed by the debug bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dbg_sel::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dbg_sel::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dbg_sel`]
module"]
    pub type DBG_SEL = crate::Reg<dbg_sel::DBG_SEL_SPEC>;
    #[doc = "What submodules are accessed by the debug bus"]
    pub mod dbg_sel {
        #[doc = "Register `DBG_SEL` reader"]
        pub type R = crate::R<DBG_SEL_SPEC>;
        #[doc = "Register `DBG_SEL` writer"]
        pub type W = crate::W<DBG_SEL_SPEC>;
        #[doc = "Field `SELECT` reader - "]
        pub type SELECT_R = crate::BitReader<SELECT_A>;
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SELECT_A {
            #[doc = "0: `0`"]
            RECEIVER_FIFO = 0,
            #[doc = "1: `1`"]
            OTHERS = 1,
        }
        impl From<SELECT_A> for bool {
            #[inline(always)]
            fn from(variant: SELECT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SELECT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SELECT_A {
                match self.bits {
                    false => SELECT_A::RECEIVER_FIFO,
                    true => SELECT_A::OTHERS,
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn is_receiver_fifo(&self) -> bool {
                *self == SELECT_A::RECEIVER_FIFO
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn is_others(&self) -> bool {
                *self == SELECT_A::OTHERS
            }
        }
        #[doc = "Field `SELECT` writer - "]
        pub type SELECT_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O, SELECT_A>;
        impl<'a, REG, const O: u8> SELECT_W<'a, REG, O>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn receiver_fifo(self) -> &'a mut crate::W<REG> {
                self.variant(SELECT_A::RECEIVER_FIFO)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn others(self) -> &'a mut crate::W<REG> {
                self.variant(SELECT_A::OTHERS)
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn select(&self) -> SELECT_R {
                SELECT_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DBG_SEL")
                    .field("select", &format_args!("{}", self.select().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DBG_SEL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn select(&mut self) -> SELECT_W<DBG_SEL_SPEC, 0> {
                SELECT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "What submodules are accessed by the debug bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dbg_sel::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dbg_sel::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DBG_SEL_SPEC;
        impl crate::RegisterSpec for DBG_SEL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dbg_sel::R`](R) reader structure"]
        impl crate::Readable for DBG_SEL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dbg_sel::W`](W) writer structure"]
        impl crate::Writable for DBG_SEL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets DBG_SEL to value 0"]
        impl crate::Resettable for DBG_SEL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "EXRDFIFO_CFG (rw) register accessor: Fine tune DMA request generation\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`exrdfifo_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exrdfifo_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@exrdfifo_cfg`]
module"]
    pub type EXRDFIFO_CFG = crate::Reg<exrdfifo_cfg::EXRDFIFO_CFG_SPEC>;
    #[doc = "Fine tune DMA request generation"]
    pub mod exrdfifo_cfg {
        #[doc = "Register `EXRDFIFO_CFG` reader"]
        pub type R = crate::R<EXRDFIFO_CFG_SPEC>;
        #[doc = "Register `EXRDFIFO_CFG` writer"]
        pub type W = crate::W<EXRDFIFO_CFG_SPEC>;
        #[doc = "Field `RD_THRSH` reader - Read threshold in 32 bit words"]
        pub type RD_THRSH_R = crate::FieldReader;
        #[doc = "Field `RD_THRSH` writer - Read threshold in 32 bit words"]
        pub type RD_THRSH_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O>;
        impl R {
            #[doc = "Bits 0:2 - Read threshold in 32 bit words"]
            #[inline(always)]
            pub fn rd_thrsh(&self) -> RD_THRSH_R {
                RD_THRSH_R::new((self.bits & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EXRDFIFO_CFG")
                    .field("rd_thrsh", &format_args!("{}", self.rd_thrsh().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<EXRDFIFO_CFG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Read threshold in 32 bit words"]
            #[inline(always)]
            #[must_use]
            pub fn rd_thrsh(&mut self) -> RD_THRSH_W<EXRDFIFO_CFG_SPEC, 0> {
                RD_THRSH_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Fine tune DMA request generation\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`exrdfifo_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exrdfifo_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EXRDFIFO_CFG_SPEC;
        impl crate::RegisterSpec for EXRDFIFO_CFG_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`exrdfifo_cfg::R`](R) reader structure"]
        impl crate::Readable for EXRDFIFO_CFG_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`exrdfifo_cfg::W`](W) writer structure"]
        impl crate::Writable for EXRDFIFO_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets EXRDFIFO_CFG to value 0"]
        impl crate::Resettable for EXRDFIFO_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "EXRDFIFO_EN (rw) register accessor: Enable the extension data register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`exrdfifo_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exrdfifo_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@exrdfifo_en`]
module"]
    pub type EXRDFIFO_EN = crate::Reg<exrdfifo_en::EXRDFIFO_EN_SPEC>;
    #[doc = "Enable the extension data register"]
    pub mod exrdfifo_en {
        #[doc = "Register `EXRDFIFO_EN` reader"]
        pub type R = crate::R<EXRDFIFO_EN_SPEC>;
        #[doc = "Register `EXRDFIFO_EN` writer"]
        pub type W = crate::W<EXRDFIFO_EN_SPEC>;
        #[doc = "Field `ENABLE` reader - Enable the extension FIFO"]
        pub type ENABLE_R = crate::BitReader;
        #[doc = "Field `ENABLE` writer - Enable the extension FIFO"]
        pub type ENABLE_W<'a, REG, const O: u8> = crate::BitWriter<'a, REG, O>;
        impl R {
            #[doc = "Bit 0 - Enable the extension FIFO"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EXRDFIFO_EN")
                    .field("enable", &format_args!("{}", self.enable().bit()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<EXRDFIFO_EN_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable the extension FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<EXRDFIFO_EN_SPEC, 0> {
                ENABLE_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Enable the extension data register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`exrdfifo_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exrdfifo_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EXRDFIFO_EN_SPEC;
        impl crate::RegisterSpec for EXRDFIFO_EN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`exrdfifo_en::R`](R) reader structure"]
        impl crate::Readable for EXRDFIFO_EN_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`exrdfifo_en::W`](W) writer structure"]
        impl crate::Writable for EXRDFIFO_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets EXRDFIFO_EN to value 0"]
        impl crate::Resettable for EXRDFIFO_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "TUNE_STEP (rw) register accessor: Sample clock delay step duration\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tune_step::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tune_step::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tune_step`]
module"]
    pub type TUNE_STEP = crate::Reg<tune_step::TUNE_STEP_SPEC>;
    #[doc = "Sample clock delay step duration"]
    pub mod tune_step {
        #[doc = "Register `TUNE_STEP` reader"]
        pub type R = crate::R<TUNE_STEP_SPEC>;
        #[doc = "Register `TUNE_STEP` writer"]
        pub type W = crate::W<TUNE_STEP_SPEC>;
        #[doc = "Field `DELAY` reader - "]
        pub type DELAY_R = crate::FieldReader;
        #[doc = "Field `DELAY` writer - "]
        pub type DELAY_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 3, O>;
        impl R {
            #[doc = "Bits 0:2"]
            #[inline(always)]
            pub fn delay(&self) -> DELAY_R {
                DELAY_R::new((self.bits & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TUNE_STEP")
                    .field("delay", &format_args!("{}", self.delay().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<TUNE_STEP_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:2"]
            #[inline(always)]
            #[must_use]
            pub fn delay(&mut self) -> DELAY_W<TUNE_STEP_SPEC, 0> {
                DELAY_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Sample clock delay step duration\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tune_step::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tune_step::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TUNE_STEP_SPEC;
        impl crate::RegisterSpec for TUNE_STEP_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tune_step::R`](R) reader structure"]
        impl crate::Readable for TUNE_STEP_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`tune_step::W`](W) writer structure"]
        impl crate::Writable for TUNE_STEP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets TUNE_STEP to value 0"]
        impl crate::Resettable for TUNE_STEP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "TUNE_STEPS_STD (rw) register accessor: Sample clock delay step count for SDR\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tune_steps_std::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tune_steps_std::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tune_steps_std`]
module"]
    pub type TUNE_STEPS_STD = crate::Reg<tune_steps_std::TUNE_STEPS_STD_SPEC>;
    #[doc = "Sample clock delay step count for SDR"]
    pub mod tune_steps_std {
        #[doc = "Register `TUNE_STEPS_STD` reader"]
        pub type R = crate::R<TUNE_STEPS_STD_SPEC>;
        #[doc = "Register `TUNE_STEPS_STD` writer"]
        pub type W = crate::W<TUNE_STEPS_STD_SPEC>;
        #[doc = "Field `STEPS` reader - "]
        pub type STEPS_R = crate::FieldReader;
        #[doc = "Field `STEPS` writer - "]
        pub type STEPS_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 6, O>;
        impl R {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            pub fn steps(&self) -> STEPS_R {
                STEPS_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TUNE_STEPS_STD")
                    .field("steps", &format_args!("{}", self.steps().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<TUNE_STEPS_STD_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            #[must_use]
            pub fn steps(&mut self) -> STEPS_W<TUNE_STEPS_STD_SPEC, 0> {
                STEPS_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Sample clock delay step count for SDR\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tune_steps_std::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tune_steps_std::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TUNE_STEPS_STD_SPEC;
        impl crate::RegisterSpec for TUNE_STEPS_STD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tune_steps_std::R`](R) reader structure"]
        impl crate::Readable for TUNE_STEPS_STD_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`tune_steps_std::W`](W) writer structure"]
        impl crate::Writable for TUNE_STEPS_STD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets TUNE_STEPS_STD to value 0"]
        impl crate::Resettable for TUNE_STEPS_STD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "TUNE_STEPS_DDR (rw) register accessor: Sample clock delay step count for DDR\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tune_steps_ddr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tune_steps_ddr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tune_steps_ddr`]
module"]
    pub type TUNE_STEPS_DDR = crate::Reg<tune_steps_ddr::TUNE_STEPS_DDR_SPEC>;
    #[doc = "Sample clock delay step count for DDR"]
    pub mod tune_steps_ddr {
        #[doc = "Register `TUNE_STEPS_DDR` reader"]
        pub type R = crate::R<TUNE_STEPS_DDR_SPEC>;
        #[doc = "Register `TUNE_STEPS_DDR` writer"]
        pub type W = crate::W<TUNE_STEPS_DDR_SPEC>;
        #[doc = "Field `STEPS` reader - "]
        pub type STEPS_R = crate::FieldReader;
        #[doc = "Field `STEPS` writer - "]
        pub type STEPS_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 6, O>;
        impl R {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            pub fn steps(&self) -> STEPS_R {
                STEPS_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TUNE_STEPS_DDR")
                    .field("steps", &format_args!("{}", self.steps().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<TUNE_STEPS_DDR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            #[must_use]
            pub fn steps(&mut self) -> STEPS_W<TUNE_STEPS_DDR_SPEC, 0> {
                STEPS_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Sample clock delay step count for DDR\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tune_steps_ddr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tune_steps_ddr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TUNE_STEPS_DDR_SPEC;
        impl crate::RegisterSpec for TUNE_STEPS_DDR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tune_steps_ddr::R`](R) reader structure"]
        impl crate::Readable for TUNE_STEPS_DDR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`tune_steps_ddr::W`](W) writer structure"]
        impl crate::Writable for TUNE_STEPS_DDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets TUNE_STEPS_DDR to value 0"]
        impl crate::Resettable for TUNE_STEPS_DDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "SPI_INT_SPT (rw) register accessor: Interrupts in SPI mode depend on CS\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`spi_int_spt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`spi_int_spt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@spi_int_spt`]
module"]
    pub type SPI_INT_SPT = crate::Reg<spi_int_spt::SPI_INT_SPT_SPEC>;
    #[doc = "Interrupts in SPI mode depend on CS"]
    pub mod spi_int_spt {
        #[doc = "Register `SPI_INT_SPT` reader"]
        pub type R = crate::R<SPI_INT_SPT_SPEC>;
        #[doc = "Register `SPI_INT_SPT` writer"]
        pub type W = crate::W<SPI_INT_SPT_SPEC>;
        #[doc = "Field `SELECT` reader - "]
        pub type SELECT_R = crate::FieldReader;
        #[doc = "Field `SELECT` writer - "]
        pub type SELECT_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn select(&self) -> SELECT_R {
                SELECT_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SPI_INT_SPT")
                    .field("select", &format_args!("{}", self.select().bits()))
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<SPI_INT_SPT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn select(&mut self) -> SELECT_W<SPI_INT_SPT_SPEC, 0> {
                SELECT_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupts in SPI mode depend on CS\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`spi_int_spt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`spi_int_spt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SPI_INT_SPT_SPEC;
        impl crate::RegisterSpec for SPI_INT_SPT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`spi_int_spt::R`](R) reader structure"]
        impl crate::Readable for SPI_INT_SPT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`spi_int_spt::W`](W) writer structure"]
        impl crate::Writable for SPI_INT_SPT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets SPI_INT_SPT to value 0"]
        impl crate::Resettable for SPI_INT_SPT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "SLOTISR_VER (rw) register accessor: Version information and slot interrupt status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`slotisr_ver::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slotisr_ver::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slotisr_ver`]
module"]
    pub type SLOTISR_VER = crate::Reg<slotisr_ver::SLOTISR_VER_SPEC>;
    #[doc = "Version information and slot interrupt status"]
    pub mod slotisr_ver {
        #[doc = "Register `SLOTISR_VER` reader"]
        pub type R = crate::R<SLOTISR_VER_SPEC>;
        #[doc = "Register `SLOTISR_VER` writer"]
        pub type W = crate::W<SLOTISR_VER_SPEC>;
        #[doc = "Field `SLOT_STATUS` reader - OR of interrupt and wakeup signals for each slot"]
        pub type SLOT_STATUS_R = crate::FieldReader;
        #[doc = "Field `SLOT_STATUS` writer - OR of interrupt and wakeup signals for each slot"]
        pub type SLOT_STATUS_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `SDVERSION` reader - Host controller specification version"]
        pub type SDVERSION_R = crate::FieldReader;
        #[doc = "Field `SDVERSION` writer - Host controller specification version"]
        pub type SDVERSION_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        #[doc = "Field `VENDOR` reader - Vendor version number"]
        pub type VENDOR_R = crate::FieldReader;
        #[doc = "Field `VENDOR` writer - Vendor version number"]
        pub type VENDOR_W<'a, REG, const O: u8> = crate::FieldWriter<'a, REG, 8, O>;
        impl R {
            #[doc = "Bits 0:7 - OR of interrupt and wakeup signals for each slot"]
            #[inline(always)]
            pub fn slot_status(&self) -> SLOT_STATUS_R {
                SLOT_STATUS_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - Host controller specification version"]
            #[inline(always)]
            pub fn sdversion(&self) -> SDVERSION_R {
                SDVERSION_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - Vendor version number"]
            #[inline(always)]
            pub fn vendor(&self) -> VENDOR_R {
                VENDOR_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SLOTISR_VER")
                    .field("vendor", &format_args!("{}", self.vendor().bits()))
                    .field("sdversion", &format_args!("{}", self.sdversion().bits()))
                    .field(
                        "slot_status",
                        &format_args!("{}", self.slot_status().bits()),
                    )
                    .finish()
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<SLOTISR_VER_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - OR of interrupt and wakeup signals for each slot"]
            #[inline(always)]
            #[must_use]
            pub fn slot_status(&mut self) -> SLOT_STATUS_W<SLOTISR_VER_SPEC, 0> {
                SLOT_STATUS_W::new(self)
            }
            #[doc = "Bits 16:23 - Host controller specification version"]
            #[inline(always)]
            #[must_use]
            pub fn sdversion(&mut self) -> SDVERSION_W<SLOTISR_VER_SPEC, 16> {
                SDVERSION_W::new(self)
            }
            #[doc = "Bits 24:31 - Vendor version number"]
            #[inline(always)]
            #[must_use]
            pub fn vendor(&mut self) -> VENDOR_W<SLOTISR_VER_SPEC, 24> {
                VENDOR_W::new(self)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Version information and slot interrupt status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`slotisr_ver::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slotisr_ver::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SLOTISR_VER_SPEC;
        impl crate::RegisterSpec for SLOTISR_VER_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`slotisr_ver::R`](R) reader structure"]
        impl crate::Readable for SLOTISR_VER_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`slotisr_ver::W`](W) writer structure"]
        impl crate::Writable for SLOTISR_VER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets SLOTISR_VER to value 0"]
        impl crate::Resettable for SLOTISR_VER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "VCMAILBOX"]
    pub VCMAILBOX: VCMAILBOX,
    #[doc = "PM"]
    pub PM: PM,
    #[doc = "CM_PCM"]
    pub CM_PCM: CM_PCM,
    #[doc = "CM_PWM"]
    pub CM_PWM: CM_PWM,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "SYSTMR"]
    pub SYSTMR: SYSTMR,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "SPI0"]
    pub SPI0: SPI0,
    #[doc = "BSC0"]
    pub BSC0: BSC0,
    #[doc = "PWM0"]
    pub PWM0: PWM0,
    #[doc = "BSC1"]
    pub BSC1: BSC1,
    #[doc = "BSC2"]
    pub BSC2: BSC2,
    #[doc = "AUX"]
    pub AUX: AUX,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    pub SPI2: SPI2,
    #[doc = "LIC"]
    pub LIC: LIC,
    #[doc = "USB_OTG_GLOBAL"]
    pub USB_OTG_GLOBAL: USB_OTG_GLOBAL,
    #[doc = "USB_OTG_HOST"]
    pub USB_OTG_HOST: USB_OTG_HOST,
    #[doc = "USB_OTG_DEVICE"]
    pub USB_OTG_DEVICE: USB_OTG_DEVICE,
    #[doc = "USB_OTG_PWRCLK"]
    pub USB_OTG_PWRCLK: USB_OTG_PWRCLK,
    #[doc = "EMMC"]
    pub EMMC: EMMC,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            VCMAILBOX: VCMAILBOX {
                _marker: PhantomData,
            },
            PM: PM {
                _marker: PhantomData,
            },
            CM_PCM: CM_PCM {
                _marker: PhantomData,
            },
            CM_PWM: CM_PWM {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            SYSTMR: SYSTMR {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            BSC0: BSC0 {
                _marker: PhantomData,
            },
            PWM0: PWM0 {
                _marker: PhantomData,
            },
            BSC1: BSC1 {
                _marker: PhantomData,
            },
            BSC2: BSC2 {
                _marker: PhantomData,
            },
            AUX: AUX {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            LIC: LIC {
                _marker: PhantomData,
            },
            USB_OTG_GLOBAL: USB_OTG_GLOBAL {
                _marker: PhantomData,
            },
            USB_OTG_HOST: USB_OTG_HOST {
                _marker: PhantomData,
            },
            USB_OTG_DEVICE: USB_OTG_DEVICE {
                _marker: PhantomData,
            },
            USB_OTG_PWRCLK: USB_OTG_PWRCLK {
                _marker: PhantomData,
            },
            EMMC: EMMC {
                _marker: PhantomData,
            },
        }
    }
}
